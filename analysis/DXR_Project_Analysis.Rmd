---
title: "DXR DE Analysis"
author: "Emma M Pfortmiller"
date: "2025-05-14"
site: workflowr::wflow_site
output:
  workflowr::wflow_html:
    toc: true
    toc_depth: 4
    toc_float: true
    theme: journal
    highlight: textmate
---

editor_options: 
  chunk_output_type: inline

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{css, echo=FALSE}
pre {
  max-height: 400px;
  overflow-y: auto;
}

pre[class] {
  max-height: 200px;
  
}
```

I did this part with Sayan according to his analysis to ensure that my matrix was consistent with his - allowing me to work on downstream analysis
#Read in Libraries
```{r Necessary Libraries, message=FALSE, warning=FALSE, include=FALSE}
library(tidyverse)
library(Biobase)
library(limma)
library(edgeR)
library(edgebundleR)
library(scales)
library(biomaRt)
library(ggrepel)
library(ggfortify)
library(corrplot)
library(readr)
library(org.Hs.eg.db)
library(AnnotationDbi)
library(ComplexHeatmap)
library(circlize)
library(grid)
library(reshape2)
library(ggVennDiagram)
library(UpSetR)
library(ggpubr)
library(VennDiagram)
library(VennDetail)
library(BiocParallel)
library(RUVSeq)
library(SummarizedExperiment)
```


#Read in Counts Files from FeatureCounts
```{r Create My Dataframe With All Counts Files}
#load in libraries needed
#these counts files are from featureCounts, all saved as RDS objects

# ####Individual 1 - 84-1####
# Counts_84_DOX_24 <- readRDS("data/counts/Counts_84_DOX_24.RDS")
# Counts_84_DMSO_24 <- readRDS("data/counts/Counts_84_DMSO_24.RDS")
# Counts_84_DOX_24rec <- readRDS("data/counts/Counts_84_DOX_24rec.RDS")
# Counts_84_DMSO_24rec <- readRDS("data/counts/Counts_84_DMSO_24rec.RDS")
# Counts_84_DOX_144rec <- readRDS("data/counts/Counts_84_DOX_144rec.RDS")
# Counts_84_DMSO_144rec <- readRDS("data/counts/Counts_84_DMSO_144rec.RDS")
# 
# ####Individual 2 - 87-1####
# Counts_87_DOX_24 <- readRDS("data/counts/Counts_87_DOX_24.RDS")
# Counts_87_DMSO_24 <- readRDS("data/counts/Counts_87_DMSO_24.RDS")
# Counts_87_DOX_24rec <- readRDS("data/counts/Counts_87_DOX_24rec.RDS")
# Counts_87_DMSO_24rec <- readRDS("data/counts/Counts_87_DMSO_24rec.RDS")
# Counts_87_DOX_144rec <- readRDS("data/counts/Counts_87_DOX_144rec.RDS")
# Counts_87_DMSO_144rec <- readRDS("data/counts/Counts_87_DMSO_144rec.RDS")
# 
# ####Individual 3 - 78-1####
# Counts_78_DOX_24 <- readRDS("data/counts/Counts_78_DOX_24.RDS")
# Counts_78_DMSO_24 <- readRDS("data/counts/Counts_78_DMSO_24.RDS")
# Counts_78_DOX_24rec <- readRDS("data/counts/Counts_78_DOX_24rec.RDS")
# Counts_78_DMSO_24rec <- readRDS("data/counts/Counts_78_DMSO_24rec.RDS")
# Counts_78_DOX_144rec <- readRDS("data/counts/Counts_78_DOX_144rec.RDS")
# Counts_78_DMSO_144rec <- readRDS("data/counts/Counts_78_DMSO_144rec.RDS")
# 
# ####Individual 4 - 75-1####
# Counts_75_DOX_24 <- readRDS("data/counts/Counts_75_DOX_24.RDS")
# Counts_75_DMSO_24 <- readRDS("data/counts/Counts_75_DMSO_24.RDS")
# Counts_75_DOX_24rec <- readRDS("data/counts/Counts_75_DOX_24rec.RDS")
# Counts_75_DMSO_24rec <- readRDS("data/counts/Counts_75_DMSO_24rec.RDS")
# Counts_75_DOX_144rec <- readRDS("data/counts/Counts_75_DOX_144rec.RDS")
# Counts_75_DMSO_144rec <- readRDS("data/counts/Counts_75_DMSO_144rec.RDS")
# 
# ####Individual 5 - 17-3####
# Counts_17_DOX_24 <- readRDS("data/counts/Counts_17_DOX_24.RDS")
# Counts_17_DMSO_24 <- readRDS("data/counts/Counts_17_DMSO_24.RDS")
# Counts_17_DOX_24rec <- readRDS("data/counts/Counts_17_DOX_24rec.RDS")
# Counts_17_DMSO_24rec <- readRDS("data/counts/Counts_17_DMSO_24rec.RDS")
# Counts_17_DOX_144rec <- readRDS("data/counts/Counts_17_DOX_144rec.RDS")
# Counts_17_DMSO_144rec <- readRDS("data/counts/Counts_17_DMSO_144rec.RDS")
# 
# ####Individual 6 - 90-1####
# Counts_90_DOX_24 <- readRDS("data/counts/Counts_90_DOX_24.RDS")
# Counts_90_DMSO_24 <- readRDS("data/counts/Counts_90_DMSO_24.RDS")
# Counts_90_DOX_24rec <- readRDS("data/counts/Counts_90_DOX_24rec.RDS")
# Counts_90_DMSO_24rec <- readRDS("data/counts/Counts_90_DMSO_24rec.RDS")
# Counts_90_DOX_144rec <- readRDS("data/counts/Counts_90_DOX_144rec.RDS")
# Counts_90_DMSO_144rec <- readRDS("data/counts/Counts_90_DMSO_144rec.RDS")
# 
# ####Individual 7 - 90-1REP####
# Counts_90REP_DOX_24 <- readRDS("data/counts/Counts_90REP_DOX_24.RDS")
# Counts_90REP_DMSO_24 <- readRDS("data/counts/Counts_90REP_DMSO_24.RDS")
# Counts_90REP_DOX_24rec <- readRDS("data/counts/Counts_90REP_DOX_24rec.RDS")
# Counts_90REP_DMSO_24rec <- readRDS("data/counts/Counts_90REP_DMSO_24rec.RDS")
# Counts_90REP_DOX_144rec <- readRDS("data/counts/Counts_90REP_DOX_144rec.RDS")
# Counts_90REP_DMSO_144rec <- readRDS("data/counts/Counts_90REP_DMSO_144rec.RDS")

```

##Create my Dataframe from Counts Files
```{r Put Counts Together Into Dataframe}
# counts_raw_df <-
#    data.frame(
#      Counts_84_DOX_24,
#      Counts_84_DMSO_24$MCW_EMP_JT_R29_R1.bam,
#      Counts_84_DOX_24rec$MCW_EMP_JT_R30_R1.bam,
#      Counts_84_DMSO_24rec$MCW_EMP_JT_R32_R1.bam,
#      Counts_84_DOX_144rec$MCW_EMP_JT_R33_R1.bam,
#      Counts_84_DMSO_144rec$MCW_EMP_JT_R35_R1.bam,
#      Counts_87_DOX_24$MCW_EMP_JT_R36_R1.bam,
#      Counts_87_DMSO_24$MCW_EMP_JT_R38_R1.bam,
#      Counts_87_DOX_24rec$MCW_EMP_JT_R39_R1.bam,
#      Counts_87_DMSO_24rec$MCW_EMP_JT_R41_R1.bam,
#      Counts_87_DOX_144rec$MCW_EMP_JT_R42_R1.bam,
#      Counts_87_DMSO_144rec$MCW_EMP_JT_R44_R1.bam,
#      Counts_78_DOX_24$MCW_EMP_JT_R45_R1.bam,
#      Counts_78_DMSO_24$MCW_EMP_JT_R47_R1.bam,
#      Counts_78_DOX_24rec$MCW_EMP_JT_R48_R1.bam,
#      Counts_78_DMSO_24rec$MCW_EMP_JT_R50_R1.bam,
#      Counts_78_DOX_144rec$MCW_EMP_JT_R51_R1.bam,
#      Counts_78_DMSO_144rec$MCW_EMP_JT_R53_R1.bam,
#      Counts_75_DOX_24$MCW_EMP_JT_R54_R1.bam,
#      Counts_75_DMSO_24$MCW_EMP_JT_R56_R1.bam,
#      Counts_75_DOX_24rec$MCW_EMP_JT_R57_R1.bam,
#      Counts_75_DMSO_24rec$MCW_EMP_JT_R59_R1.bam,
#      Counts_75_DOX_144rec$MCW_EMP_JT_R60_R1.bam,
#      Counts_75_DMSO_144rec$MCW_EMP_JT_R62_R1.bam,
#      Counts_17_DOX_24$MCW_EMP_JT_R63_R1.bam,
#      Counts_17_DMSO_24$MCW_EMP_JT_R65_R1.bam,
#      Counts_17_DOX_24rec$MCW_EMP_JT_R66_R1.bam,
#      Counts_17_DMSO_24rec$MCW_EMP_JT_R68_R1.bam,
#      Counts_17_DOX_144rec$MCW_EMP_JT_R69_R1.bam,
#      Counts_17_DMSO_144rec$MCW_EMP_JT_R71_R1.bam,
#      Counts_90_DOX_24$MCW_EMP_JT_R72_R1.bam,
#      Counts_90_DMSO_24$MCW_EMP_JT_R74_R1.bam,
#      Counts_90_DOX_24rec$MCW_EMP_JT_R75_R1.bam,
#      Counts_90_DMSO_24rec$MCW_EMP_JT_R77_R1.bam,
#      Counts_90_DOX_144rec$MCW_EMP_JT_R78_R1.bam,
#      Counts_90_DMSO_144rec$MCW_EMP_JT_R80_R1.bam,
#      Counts_90REP_DOX_24$MCW_EMP_JT_R81_R1.bam,
#      Counts_90REP_DMSO_24$MCW_EMP_JT_R83_R1.bam,
#      Counts_90REP_DOX_24rec$MCW_EMP_JT_R84_R1.bam,
#      Counts_90REP_DMSO_24rec$MCW_EMP_JT_R86_R1.bam,
#      Counts_90REP_DOX_144rec$MCW_EMP_JT_R87_R1.bam,
#      Counts_90REP_DMSO_144rec$MCW_EMP_JT_R89_R1.bam
#    )

#now save this as a matrix
# counts_raw_matrix <- counts_raw_df %>% column_to_rownames(var = "X") %>% as.matrix()

counts_raw_matrix <- readRDS("data/new/counts_raw_matrix.RDS")

dim(counts_raw_matrix)
#28395 is my initial amount of genes prior to filtering

#write this to a csv so I can save it for later
#write.csv(counts_raw_matrix, "C:/Users/emmap/RDirectory/Recovery_RNAseq/Recovery_5FU/data/new/counts_raw_matrix_EMP_250514.csv")

#I also want to save this as an R object so I don't have to run the counts every time
#saveRDS(counts_raw_matrix, "data/new/counts_raw_matrix.RDS")

```
###Include colors and factors for analysis
```{r Colors + Factors}
#I want to include the color schemes I have for my treatment, individuals, and timepoints
####Colors####
tx_col <- c("DOX" = "#499FBD", "DMSO" = "#BBBBBC")
col_tx_large <- rep(c("#499FBD" , "#BBBBBC"), 21)
col_tx_large_2 <- c(rep("#499FBD" , 3), rep("#BBBBBC", 3), 21)

ind_col <- c("#003F5C", "#45AE91",  "#58209D", "#8B3E9B", "#FF6361", "#BC4169", "#FF2362")

ind_col_norep <- c("#003F5C", "#45AE91",  "#58209D", "#8B3E9B", "#FF6361", "#BC4169")

time_col <- c("#238B45", "#74C476", "#C7E9C0")

cond_col <- c("#003F5C", "#45AE91",  "#58209D", "#8B3E9B", "#FF6361", "#BC4169")

```

#QC Mapping Plots
```{r QC Mapping Plots}
#this dataframe contains my alignment percentages from featureCounts
##already filtered to only include DOX + DMSO samples
fC_DOXCounts <- readRDS("data/fC_DOXCounts.RDS")

#Now I want to plot these values out

####Reads by Sample####
reads_by_sample <- c("DOX" = "#499FBD", "DMSO" = "#BBBBBC")
fC_DOXCounts %>% 
  ggplot(., aes (x = Conditions, y = Total_Align, fill = Treatment, group_by = Line))+
  geom_col()+
 geom_hline(aes(yintercept=20000000))+
 scale_fill_manual(values=reads_by_sample)+
  ggtitle(expression("Total number of reads by sample"))+
  xlab("")+
  ylab(expression("RNA-sequencing reads"))+
  theme_bw()+
  theme(plot.title = element_text(size = rel(2), hjust = 0.5),
        axis.title = element_text(size = 15, color = "black"),
        axis.ticks = element_line(linewidth = 1.5),
        axis.text.y = element_text(size =10, color = "black", angle = 0, hjust = 0.8, vjust = 0.5),
        axis.text.x = element_text(size =10, color = "black", angle = 90, hjust = 1, vjust = 0.2),
        #strip.text.x = element_text(size = 15, color = "black", face = "bold"),
        strip.text.y = element_text(color = "white"))


####Read Counts by Treatment####
fC_DOXCounts %>% 
  ggplot(., aes (x =Treatment, y= Total_Align, fill = Treatment))+
  geom_boxplot()+
 scale_fill_manual(values=reads_by_sample)+
  ggtitle(expression("Total number of reads by treatment"))+
  xlab("")+
  ylab(expression("RNA-sequencing reads"))+
  theme_bw()+
  
  theme(plot.title = element_text(size = rel(2), hjust = 0.5),
        axis.title = element_text(size = 15, color = "black"),
        axis.ticks = element_line(linewidth = 1.5),
        axis.text.y = element_text(size =10, color = "black", angle = 0, hjust = 0.8, vjust = 0.5),
        axis.text.x = element_text(size =10, color = "black", angle = 90, hjust = 1, vjust = 0.2),
        #strip.text.x = element_text(size = 15, color = "black", face = "bold"),
        strip.text.y = element_text(color = "white"))

####Total Reads Per Individual####
fC_DOXCounts %>% 
  ggplot(., aes (x =as.factor(Line), y=Total_Align))+
  geom_boxplot(aes(fill=as.factor(Line)))+
 scale_fill_brewer(palette = "Dark2", name = "Individual")+
  ggtitle(expression("Total number of reads by individual"))+
  xlab("")+
  ylab(expression("RNA-sequencing reads"))+
  theme_bw()+

  theme(plot.title = element_text(size = rel(2), hjust = 0.5),
        axis.title = element_text(size = 15, color = "black"),
        axis.ticks = element_line(linewidth = 1.5),
        axis.text.y = element_text(size =10, color = "black", angle = 0, hjust = 0.8, vjust = 0.5),
        axis.text.x = element_text(size =10, color = "black", angle = 0, hjust = 1),
        #strip.text.x = element_text(size = 15, color = "black", face = "bold"),
        strip.text.y = element_text(color = "white"))

####Total Mapped Reads Per Drug####

reads_by_sample <- c("DOX" = "#499FBD", "DMSO" = "#BBBBBC")
fC_DOXCounts %>% 
  ggplot(., aes (x = Conditions, y = Assigned_Align, fill = Treatment, group_by = Line))+
  geom_col()+
 geom_hline(aes(yintercept=20000000))+
 scale_fill_manual(values=reads_by_sample)+
  ggtitle(expression("Total number of mapped reads by sample"))+
  xlab("")+
  ylab(expression("RNA-sequencing reads"))+
  theme_bw()+
  theme(plot.title = element_text(size = rel(2), hjust = 0.5),
        axis.title = element_text(size = 15, color = "black"),
        axis.ticks = element_line(linewidth = 1.5),
        axis.text.y = element_text(size =10, color = "black", angle = 0, hjust = 0.8, vjust = 0.5),
        axis.text.x = element_text(size =10, color = "black", angle = 90, hjust = 1, vjust = 0.2),
        #strip.text.x = element_text(size = 15, color = "black", face = "bold"),
        strip.text.y = element_text(color = "white"))


####Read Counts by Treatment####
fC_DOXCounts %>% 
  ggplot(., aes (x =Treatment, y= Assigned_Align, fill = Treatment))+
  geom_boxplot()+
 scale_fill_manual(values=reads_by_sample)+
  ggtitle(expression("Total number of mapped reads by treatment"))+
  xlab("")+
  ylab(expression("RNA-sequencing reads"))+
  theme_bw()+
  
  theme(plot.title = element_text(size = rel(2), hjust = 0.5),
        axis.title = element_text(size = 15, color = "black"),
        axis.ticks = element_line(linewidth = 1.5),
        axis.text.y = element_text(size =10, color = "black", angle = 0, hjust = 0.8, vjust = 0.5),
        axis.text.x = element_text(size =10, color = "black", angle = 90, hjust = 1, vjust = 0.2),
        #strip.text.x = element_text(size = 15, color = "black", face = "bold"),
        strip.text.y = element_text(color = "white"))

####Total Reads Per Individual####
fC_DOXCounts %>% 
  ggplot(., aes (x =as.factor(Line), y=Assigned_Align))+
  geom_boxplot(aes(fill=as.factor(Line)))+
 scale_fill_brewer(palette = "Dark2", name = "Individual")+
  ggtitle(expression("Total number of mapped reads by individual"))+
  xlab("")+
  ylab(expression("RNA-sequencing reads"))+
  theme_bw()+

  theme(plot.title = element_text(size = rel(2), hjust = 0.5),
        axis.title = element_text(size = 15, color = "black"),
        axis.ticks = element_line(linewidth = 1.5),
        axis.text.y = element_text(size =10, color = "black", angle = 0, hjust = 0.8, vjust = 0.5),
        axis.text.x = element_text(size =10, color = "black", angle = 0, hjust = 1),
        #strip.text.x = element_text(size = 15, color = "black", face = "bold"),
        strip.text.y = element_text(color = "white"))

```

Now, I want to filter my dataframe
Before I can filter by rowMeans, I must convert to log2cpm
#Filter my Dataframe and Convert to log2cpm
```{r Dataframe Filtering}
#transform counts to cpm as a first step
counts_cpm_unfilt <- cpm(counts_raw_matrix, log = TRUE)
dim(counts_cpm_unfilt)
#I should have 28395 genes here since this is unfiltered

hist(counts_cpm_unfilt,  
     main = "Histogram of Unfiltered Counts", 
     xlab = expression("Log"[2]*" counts-per-million"), 
     col = 4)

###filter my data by rowMeans > 0 to exclude lowly expressed genes

filcpm_matrix <- subset(counts_cpm_unfilt, (rowMeans(counts_cpm_unfilt) > 0))
dim(filcpm_matrix)
#I should have 14319 genes here

#now let's make a histogram of this to check the difference
hist(filcpm_matrix,  
     main = "Histogram of Filtered Counts by rowMeans > 0", 
     xlab = expression("Log"[2]*" counts-per-million"), 
     col = 2)

#change the column names to match my samples - make sure that they are in the right order
#Individual 1 = 84-1 (M)
#Individual 2 = 87-1 (F)
#Individual 3 = 78-1 (F)
#Individual 4 = 75-1 (F)
#Individual 5 = 17-3 (M)
#Individual 6 = 90-1 (M)
#Individual 6REP = 90-1REP (M)

#Treatment/time should follow this order:
#DOX24tx
#DMSO24tx
#DOX24rec
#DMSO24rec
#DOX144rec
#DMSO144rec

colnames(filcpm_matrix) <- c("DOX_24T_Ind1",
                                "DMSO_24T_Ind1",
                                "DOX_24R_Ind1",
                                "DMSO_24R_Ind1",
                                "DOX_144R_Ind1",
                                "DMSO_144R_Ind1",
                                "DOX_24T_Ind2",
                                "DMSO_24T_Ind2",
                                "DOX_24R_Ind2",
                                "DMSO_24R_Ind2",
                                "DOX_144R_Ind2",
                                "DMSO_144R_Ind2",
                                "DOX_24T_Ind3",
                                "DMSO_24T_Ind3",
                                "DOX_24R_Ind3",
                                "DMSO_24R_Ind3",
                                "DOX_144R_Ind3",
                                "DMSO_144R_Ind3",
                                "DOX_24T_Ind4",
                                "DMSO_24T_Ind4",
                                "DOX_24R_Ind4",
                                "DMSO_24R_Ind4",
                                "DOX_144R_Ind4",
                                "DMSO_144R_Ind4",
                                "DOX_24T_Ind5",
                                "DMSO_24T_Ind5",
                                "DOX_24R_Ind5",
                                "DMSO_24R_Ind5",
                                "DOX_144R_Ind5",
                                "DMSO_144R_Ind5",
                                "DOX_24T_Ind6",
                                "DMSO_24T_Ind6",
                                "DOX_24R_Ind6",
                                "DMSO_24R_Ind6",
                                "DOX_144R_Ind6",
                                "DMSO_144R_Ind6",
                                "DOX_24T_Ind6REP",
                                "DMSO_24T_Ind6REP",
                                "DOX_24R_Ind6REP",
                                "DMSO_24R_Ind6REP",
                                "DOX_144R_Ind6REP",
                                "DMSO_144R_Ind6REP")

#export this as a csv
#write.csv(filcpm_matrix, "data/new/filcpm_final_matrix.csv")

```
##QC Boxplots of Filtered vs Unfiltered Data
```{r QC Filtering Boxplots}
#make boxplots of all counts vs log2cpm filtered counts

#set the margins so the x axis isn't cut off
##I don't mind if this one is partially cut off since all you need is the library number and not the whole name
par(mar = c(8,4,2,2))
#boxplot of unfiltered cpm matrix
boxplot(counts_cpm_unfilt, 
        main = "Boxplots of Unfiltered log2cpm", 
        names = colnames(counts_cpm_unfilt), 
        adj=1, las = 2, cex.axis = 0.7)

#set the margins so the x axis isn't cut off
par(mar = c(8,4,2,2))
#boxplot of filtered cpm matrix
boxplot(filcpm_matrix, 
        main = "Boxplots of Filtered log2cpm (rowMeans > 0)", 
        names = colnames(filcpm_matrix), 
        adj=1, las = 2, cex.axis = 0.7)

```

After making my final matrix, I pulled the gene symbols from the entrez IDs I had as my rownames
I ran this initially and then moved the column into my final matrix
My final matrix is called filcpm_final_matrix.csv saved under data
#Put together my Data for Filtered Gene List
```{r Put Together My Data for Filtered Gene List}
##I did this earlier so don't run again, I put the list into the filcpm_final_matrix.csv
# # ----------------- Load Required Libraries -----------------
# library(dplyr)
# library(readr)
# library(org.Hs.eg.db)
# library(AnnotationDbi)
# # ----------------- Load Data -----------------
# sample_data <- read_csv("data/filcpm_final_matrix.csv", show_col_types = FALSE)
# # ----------------- Ensure Entrez_ID is Present and in Character Format -----------------
# # Check column names
# print(colnames(sample_data))
# # Rename if needed (adjust if the column name is not exactly 'Entrez_ID')
# # sample_data <- sample_data %>% rename(Entrez_ID = `actual_column_name`)
# # Convert Entrez_ID to character
# sample_data <- sample_data %>%
#   mutate(Entrez_ID = as.character(Entrez_ID))
# # ----------------- Map Entrez_ID to Gene Symbol -----------------
# gene_symbols <- AnnotationDbi::select(
#   org.Hs.eg.db,
#   keys = sample_data$Entrez_ID,
#   columns = c("SYMBOL"),
#   keytype = "ENTREZID"
# )
# # ----------------- Join Back to Main Data -----------------
# sample_annotated <- left_join(sample_data, gene_symbols, by = c("Entrez_ID" = "ENTREZID"))
# # ----------------- Save Annotated Output -----------------
# #write_csv(sample_annotated, "data/Sample_annotated.csv")

#Since I ran this before, Sample_annotated.csv columns of EntrezID and Symbol have been copied into my final matrix - so disregard this file except for record-keeping
```

Now that I have my final matrix, I would like to check some key genes
I want to make sure that these genes are responding as we expect
We have triple checked this dataset to ensure that columns are in order
#Check my Response Genes in log2cpm format
```{r Check Response Genes log2cpm}
#Load in my count matrix
boxplot1 <- read.csv("data/new/filcpm_final_matrix.csv") %>% 
  as.data.frame()

#save boxplot1 as an object filcpm_matrix_genes
#saveRDS(boxplot1, "data/new/filcpm_matrix_genes.RDS")

#Define gene list(s)
initial_test_genes <- c("CDKN1A", "MDM2", "BAX", "RARG", "TP53", "TOP2B", "TOP2A")  
#Add more gene symbols as needed or add more categories

#Now put in the function I want to use to generate boxplots of genes
process_gene_data <- function(gene) {
  gene_data <- boxplot1 %>% filter(SYMBOL == gene)
  long_data <- gene_data %>%
    pivot_longer(cols = -c(Entrez_ID, SYMBOL), names_to = "Sample", values_to = "log2CPM") %>%
    mutate(
      Drug = case_when(
        grepl("DOX", Sample) ~ "DOX",
        grepl("DMSO", Sample) ~ "DMSO",
        TRUE ~ NA_character_
      ),
      Timepoint = case_when(
        grepl("_24T_", Sample) ~ "24T",
        grepl("_24R_", Sample) ~ "24R",
        grepl("_144R_", Sample) ~ "144R",
        TRUE ~ NA_character_
      ),
      Indv = case_when(
        grepl("Ind1$", Sample) ~ "1",
        grepl("Ind2$", Sample) ~ "2",
        grepl("Ind3$", Sample) ~ "3",
        grepl("Ind4$", Sample) ~ "4",
        grepl("Ind5$", Sample) ~ "5",
        grepl("Ind6$", Sample) ~ "6",
        grepl("Ind6REP$", Sample) ~ "6R",
        TRUE ~ NA_character_
      ),
      Condition = paste(Drug, Timepoint, sep = "_")
    )
  long_data$Condition <- factor(
    long_data$Condition,
    levels = c(
      "DOX_24T", 
      "DMSO_24T", 
      "DOX_24R", 
      "DMSO_24R", 
      "DOX_144R", 
      "DMSO_144R"
    )
  )
  return(long_data)
}

#this function is saved under process_gene_data so I will save as an R object

#saveRDS(process_gene_data, "data/new/process_gene_data_funct.RDS")

#Generate Boxplots from the above function using our gene list above
for (gene in initial_test_genes) {
  gene_data <- process_gene_data(gene)
  p <- ggplot(gene_data, aes(x = Condition, y = log2CPM, fill = Drug)) +
    geom_boxplot(outlier.shape = NA) +
    geom_point(aes(color = Indv), size = 2, alpha = 0.5, position = position_jitter(width = -1, height = 0)) +
    scale_fill_manual(values = c("DOX" = "#499FBD", "DMSO" = "#BBBBBC")) +
    ggtitle(paste("Log2CPM Expression of", gene)) +
    labs(x = "Treatment", y = "log2CPM") +
    theme_bw() +
    theme(
      plot.title = element_text(size = rel(2), hjust = 0.5),
      axis.title = element_text(size = 15, color = "black"),
      axis.text.x = element_text(size = 10, color = "black", angle = 90, hjust = 1)
    )
  print(p)
}

```

Now I've confirmed with some boxplots that my genes are present and (mostly) behaving as they should
- Sayan's CDKN1A and MDM2 are initially high at 24hr in DOX 0.5
- My CDKN1A and MDM2 are similar to DMSO at 24hr DOX 0.5
  - These genes increase at DOX24R
  - These genes are also high at DOX144R but not as high as 24R
However, TP53 and BAX are acting similarly across our data
#PCA Analysis
```{r PCA Analysis}
#Now I want to check if my data is as expected on a PCA plot
#perform PCA calculations
prcomp_res_unfilt <- prcomp(t(counts_cpm_unfilt %>% as.matrix()), center =  TRUE)

prcomp_res_filt <- prcomp(t(filcpm_matrix %>% as.matrix()), center =  TRUE)

#read in my metadata annotations
Metadata <- read.csv("data/new/Metadata.csv")

#add in labels for individual numbers
ind_num <- c("1", "1", "1", "1", "1", "1", 
             "2", "2", "2", "2", "2", "2", 
             "3", "3", "3", "3", "3", "3", 
             "4", "4", "4", "4", "4", "4", 
             "5", "5", "5", "5", "5", "5", 
             "6", "6", "6", "6", "6", "6", 
             "6R", "6R", "6R", "6R", "6R", "6R")

# saveRDS(ind_num, "data/new/ind_num.RDS")

#now plot my PCA for unfiltered log2cpm
####PC1/PC2####
ggplot2::autoplot(prcomp_res_unfilt, data = Metadata, colour = "Condition", shape = "Time", size =4, x=1, y=2) +
  ggrepel::geom_text_repel(label=ind_num, vjust = -.5, max.overlaps = 30) +
  scale_color_manual(values=cond_col) +
  ggtitle(expression("PCA of Unfiltered log"[2]*"cpm")) +
  theme_bw()

####PC2/PC3####
ggplot2::autoplot(prcomp_res_unfilt, data = Metadata, colour = "Condition", shape = "Time", size =4, x=2, y=3) +
  ggrepel::geom_text_repel(label=ind_num, vjust = -.5, max.overlaps = 30) +
  scale_color_manual(values=cond_col) +
  ggtitle(expression("PCA of Unfiltered log"[2]*"cpm")) +
  theme_bw()

####PC3/PC4####
ggplot2::autoplot(prcomp_res_unfilt, data = Metadata, colour = "Condition", shape = "Time", size =4, x=3, y=4) +
  ggrepel::geom_text_repel(label=ind_num, vjust = -.5, max.overlaps = 30) +
  scale_color_manual(values=cond_col) +
  ggtitle(expression("PCA of Unfiltered log"[2]*"cpm")) +
  theme_bw()


#Now plot my PCA for filtered log2cpm
####PC1/PC2####
ggplot2::autoplot(prcomp_res_filt, data = Metadata, colour = "Condition", shape = "Time", size =4, x=1, y=2) +
  ggrepel::geom_text_repel(label=ind_num, vjust = -.5, max.overlaps = 30) +
  scale_color_manual(values=cond_col) +
  ggtitle(expression("PCA of Filtered log"[2]*"cpm")) +
  theme_bw()


ggplot2::autoplot(prcomp_res_filt, data = Metadata, colour = "Condition", shape = "Time", size =4, x=1, y=2) +
  ggrepel::geom_text_repel(label=ind_num, vjust = -.5, max.overlaps = 30) +
  scale_color_manual(values=cond_col) +
  ggtitle(expression("PCA of Filtered log"[2]*"cpm")) +
  theme_bw()


####PC2/PC3####
ggplot2::autoplot(prcomp_res_filt, data = Metadata, colour = "Condition", shape = "Time", size =4, x=2, y=3) +
  ggrepel::geom_text_repel(label=ind_num, vjust = -.5, max.overlaps = 30) +
  scale_color_manual(values=cond_col) +
  ggtitle(expression("PCA of Filtered log"[2]*"cpm")) +
  theme_bw()

####PC3/PC4####
ggplot2::autoplot(prcomp_res_filt, data = Metadata, colour = "Condition", shape = "Time", size =4, x=3, y=4) +
  ggrepel::geom_text_repel(label=ind_num, vjust = -.5, max.overlaps = 30) +
  scale_color_manual(values=cond_col) +
  ggtitle(expression("PCA of Filtered log"[2]*"cpm")) +
  theme_bw()
```
#Correlation Heatmaps
```{r Correlation Heatmaps, fig.width=12, fig.height=10}

#check to make sure that the column names are correct
lcpm_2 <- filcpm_matrix
colnames(lcpm_2) <- Metadata$Final_sample_name

#compute the correlation matrices, one pearson and one spearman
cor_matrix_pearson <- cor(lcpm_2, 
                          y = NULL, 
                          use = "everything",  
                          method = "pearson")
cor_matrix_spearman <- cor(lcpm_2,
                           y = NULL,
                           use = "everything",
                           method = "spearman")

# Extract metadata columns
Individual <- as.character(Metadata$Ind)
Time <- as.character(Metadata$Time)
Treatment <- as.character(Metadata$Drug)

# Define color palettes for annotations
annot_col_cor = list(drugs = c("DOX" = "#499FBD", 
                               "DMSO" = "#BBBBBC"),
                     individuals = c("1" = "#003F5C", 
                                     "2" = "#45AE91", 
                                     "3" = "#58209D", 
                                     "4" = "#8B3E9B", 
                                     "5" = "#FF6361", 
                                     "6" = "#BC4169", 
                                     "6R" = "#FF2362"),
                     timepoints = c("24T" = "#238B45",
                                    "24R" = "#74C476", 
                                    "144R" = "#C7E9C0"))

drug_colors <- c("DOX" = "#499FBD", 
                 "DMSO" = "#BBBBBC")
ind_colors <- c("1" = "red",
                "2" = "orange",
                "3" = "yellow",
                "4" = "green",
                "5" = "blue",
                "6" = "violet",
                "6R" = "purple")
time_colors <- c("24T" = "#238B45",
                 "24R" = "#74C476",
                 "144R" = "#C7E9C0")

# Create annotations
top_annotation <- HeatmapAnnotation(
  Individual = Individual, 
  Time = Time,
  Treatment = Treatment,
  col = list(
    Individual = ind_colors, 
    Time = time_colors,
    Treatment = drug_colors
  )
)

####ANNOTATED HEATMAPS####
# pheatmap(cor_matrix_pearson, border_color = "black", legend = TRUE, angle_col = 90, display_numbers = FALSE, number_color = "black", fontsize = 10, fontsize_number = 5, annotation_col = top_annotation, annotation_colors = annot_col)

####Pearson Heatmap####
heatmap_pearson <- Heatmap(cor_matrix_pearson,
                           name = "Pearson",
                           top_annotation = top_annotation,
                           show_row_names = TRUE,
                           show_column_names = TRUE,
                           cluster_rows = TRUE,
                           cluster_columns = TRUE,
                           border = TRUE)

# Draw the heatmap
draw(heatmap_pearson)

####Spearman Heatmap####
heatmap_spearman <- Heatmap(cor_matrix_spearman,
                           name = "Spearman",
                           top_annotation = top_annotation,
                           show_row_names = TRUE,
                           show_column_names = TRUE,
                           cluster_rows = TRUE,
                           cluster_columns = TRUE,
                           border = TRUE)

# Draw the heatmap
draw(heatmap_spearman)

```
#Make my Filtered Gene List
```{r Make Filtered Gene List}
#Now I want to make a filtered gene list (my rownames)
##I will use this to filter my counts for limma + Cormotif

filt_gene_list <- rownames(filcpm_matrix)
#save this filtered gene list as I'll use it to filter my counts
#saveRDS(filt_gene_list, "data/new/filt_gene_list.RDS")

```

##Filter my Counts For DE Analysis
```{r Filter Counts for DE}
counts_raw_matrix <- readRDS("data/new/counts_raw_matrix.RDS")
#change column names to match samples for my raw counts matrix
colnames(counts_raw_matrix) <- c("DOX_24T_Ind1",
                                "DMSO_24T_Ind1",
                                "DOX_24R_Ind1",
                                "DMSO_24R_Ind1",
                                "DOX_144R_Ind1",
                                "DMSO_144R_Ind1",
                                "DOX_24T_Ind2",
                                "DMSO_24T_Ind2",
                                "DOX_24R_Ind2",
                                "DMSO_24R_Ind2",
                                "DOX_144R_Ind2",
                                "DMSO_144R_Ind2",
                                "DOX_24T_Ind3",
                                "DMSO_24T_Ind3",
                                "DOX_24R_Ind3",
                                "DMSO_24R_Ind3",
                                "DOX_144R_Ind3",
                                "DMSO_144R_Ind3",
                                "DOX_24T_Ind4",
                                "DMSO_24T_Ind4",
                                "DOX_24R_Ind4",
                                "DMSO_24R_Ind4",
                                "DOX_144R_Ind4",
                                "DMSO_144R_Ind4",
                                "DOX_24T_Ind5",
                                "DMSO_24T_Ind5",
                                "DOX_24R_Ind5",
                                "DMSO_24R_Ind5",
                                "DOX_144R_Ind5",
                                "DMSO_144R_Ind5",
                                "DOX_24T_Ind6",
                                "DMSO_24T_Ind6",
                                "DOX_24R_Ind6",
                                "DMSO_24R_Ind6",
                                "DOX_144R_Ind6",
                                "DMSO_144R_Ind6",
                                "DOX_24T_Ind6REP",
                                "DMSO_24T_Ind6REP",
                                "DOX_24R_Ind6REP",
                                "DMSO_24R_Ind6REP",
                                "DOX_144R_Ind6REP",
                                "DMSO_144R_Ind6REP")


#subset my count matrix based on filtered CPM matrix
x <- counts_raw_matrix[row.names(filcpm_matrix),]
dim(x)
#14319 genes as expected!
#this is still in counts form

#remove my replicate individual at this time
x_norep <- x[,1:36]

#modify my metadata to match
Metadata_2 <- Metadata[1:36,]
rownames(Metadata_2) <- Metadata_2$Sample_bam
colnames(x_norep) <- Metadata_2$Sample_ID
rownames(Metadata_2) <- Metadata_2$Sample_ID

Metadata_2$Condition <- make.names(Metadata_2$Condition)
Metadata_2$Ind <- as.character(Metadata_2$Ind)

#saveRDS(Metadata_2, "data/new/Metadata_2_norep.RDS")
```
#Perform Differential Expression Analysis 
```{r Differential Expression Analysis}

#create DGEList object
dge <- DGEList(counts = x_norep)
dge$samples$group <- factor(Metadata_2$Condition)
dge <- calcNormFactors(dge, method = "TMM")

#saveRDS(dge, "data/new/dge_matrix.RDS")

#check normalization factors from TMM normalization of LIBRARIES
dge$samples

#create my design matrix for DE
design <- model.matrix(~ 0 + Metadata_2$Condition)
colnames(design) <- gsub("Metadata_2\\$Condition", "", colnames(design))

#take care that the matrix automatically sorts cols alphabetically
##currently DMSO144R, DMSO24R, DMSO24T, DOX144R, DOX24R, DOX24T

#run duplicate correlation for individual effect
corfit <- duplicateCorrelation(object = dge$counts, design = design, block = Metadata_2$Ind)

#voom transformation and plot
v <- voom(dge, design, block = Metadata_2$Ind, correlation = corfit$consensus.correlation, plot = TRUE)

#fit my linear model
fit <- lmFit(v, design, block = Metadata_2$Ind, correlation = corfit$consensus.correlation)

#make my contrast matrix to compare across tx and veh
contrast_matrix <- makeContrasts(
  V.D24T = DOX_24T - DMSO_24T,
  V.D24R = DOX_24R - DMSO_24R, 
  V.D144R = DOX_144R - DMSO_144R,
  levels = design
)

#apply these contrasts to compare DOX to DMSO VEH
fit2 <- contrasts.fit(fit, contrast_matrix)
fit2 <- eBayes(fit2)

#plot the mean-variance trend
plotSA(fit2, main = "Final model: Mean-Variance trend")

#look at the summary of your results
##this tells you the number of DEGs in each condition
results_summary <- decideTests(fit2, adjust.method = "BH", p.value = 0.05)
summary(results_summary)
#        V.D24 V.D24r V.D144r
# Down    4723   3593     359
# NotSig  5076   7151   13810
# Up      4520   3575     150

vennDiagram(object = results_summary, include = c("up", "down"))

```
##Create Toptables of my DEGs
```{r Make Toptables of DEGs}

# Generate Top Table for Specific Comparisons

Toptable_V.D24T <- topTable(fit = fit2, coef = "V.D24T", number = nrow(x), adjust.method = "BH", p.value = 1, sort.by = "none")
#write.csv(Toptable_V.D24T, "data/new/DEGs/Toptable_V.D24T.csv")

Toptable_V.D24R <- topTable(fit = fit2, coef = "V.D24R", number = nrow(x), adjust.method = "BH", p.value = 1, sort.by = "none")
#write.csv(Toptable_V.D24R, "data/new/DEGs/Toptable_V.D24R.csv")

Toptable_V.D144R <- topTable(fit = fit2, coef = "V.D144R", number = nrow(x), adjust.method = "BH", p.value = 1, sort.by = "none")
#write.csv(Toptable_V.D144R, "data/new/DEGs/Toptable_V.D144R.csv")

#save all of these toptables as R objects
# saveRDS(list(
#   V.D24T = Toptable_V.D24T,
#   V.D24R = Toptable_V.D24R,
#   V.D144R = Toptable_V.D144R
# ), file = "data/new/Toptable_list.RDS")

Toptable_list <- readRDS("data/new/Toptable_list.RDS")

```

##Top 5 DEGs after DE Analysis per Condition
```{r Top 5 DEGs Limma}
#use your three toptables so I can pull out top 5 genes from each based on adj. p val

top5_D24T <- Toptable_V.D24T[order(Toptable_V.D24T$adj.P.Val), ][1:5,] %>% 
  rownames_to_column(., var = "Entrez_ID")
top5_D24R <- Toptable_V.D24R[order(Toptable_V.D24R$adj.P.Val), ][1:5,] %>% 
  rownames_to_column(., var = "Entrez_ID")
top5_D144R <- Toptable_V.D144R[order(Toptable_V.D144R$adj.P.Val), ][1:5,] %>% 
  rownames_to_column(., var = "Entrez_ID")

#now that I've pulled the top 5 DEGs from each, make a list to pull them from my log2cpm data

boxplot1 <- read.csv("data/new/filcpm_final_matrix.csv") %>% 
  as.data.frame()

#Define gene list
#these are the top 5 genes pulled from my toptables
top5_D24T_geneslist <- c(top5_D24T$Entrez_ID)
top5_D24R_geneslist <- c(top5_D24R$Entrez_ID)
top5_D144R_geneslist <- c(top5_D144R$Entrez_ID)
#Add more gene symbols as needed or add more categories

#now pull these from my log2cpm matrix
top5_D24T_genes <- boxplot1[boxplot1$Entrez_ID %in% top5_D24T_geneslist,]
dim(top5_D24T_genes)
#5 genes in 44 cols
top5_D24R_genes <- boxplot1[boxplot1$Entrez_ID %in% top5_D24R_geneslist,]
dim(top5_D24R_genes)
#5 genes in 44 cols
top5_D144R_genes <- boxplot1[boxplot1$Entrez_ID %in% top5_D144R_geneslist,]
dim(top5_D144R_genes)
#5 genes in 44 cols

#Now put in the function I want to use to generate boxplots of genes
#####D24T#####
process_top5_D24T <- function(gene) {
  gene_data <- top5_D24T_genes %>% filter(Entrez_ID == gene)
  long_data <- gene_data %>%
    pivot_longer(cols = -c(Entrez_ID, SYMBOL), names_to = "Sample", values_to = "log2cpm") %>%
    mutate(
      Drug = case_when(
        grepl("DOX", Sample) ~ "DOX",
        grepl("DMSO", Sample) ~ "DMSO",
        TRUE ~ NA_character_
      ),
      Timepoint = case_when(
        grepl("_24T_", Sample) ~ "24T",
        grepl("_24R_", Sample) ~ "24R",
        grepl("_144R_", Sample) ~ "144R",
        TRUE ~ NA_character_
      ),
      Indv = case_when(
        grepl("Ind1$", Sample) ~ "1",
        grepl("Ind2$", Sample) ~ "2",
        grepl("Ind3$", Sample) ~ "3",
        grepl("Ind4$", Sample) ~ "4",
        grepl("Ind5$", Sample) ~ "5",
        grepl("Ind6$", Sample) ~ "6",
        grepl("Ind6R$", Sample) ~ "6R",
        TRUE ~ NA_character_
      ),
      Condition = paste(Drug, Timepoint, sep = "_")
    )
  long_data$Condition <- factor(
    long_data$Condition,
    levels = c(
      "DOX_24T", 
      "DMSO_24T", 
      "DOX_24R", 
      "DMSO_24R", 
      "DOX_144R", 
      "DMSO_144R"
    )
  )
  return(long_data)
}


#Generate Boxplots from the above function using our gene list above
for (gene in top5_D24T_geneslist) {
  gene_data <- process_top5_D24T(gene)
  p <- ggplot(gene_data, aes(x = Condition, y = log2cpm, fill = Drug)) +
    geom_boxplot(outlier.shape = NA) +
    geom_point(aes(color = Indv), size = 2, alpha = 0.5, position = position_jitter(width = -1, height = 0)) +
    scale_fill_manual(values = c("DOX" = "#499FBD", "DMSO" = "#BBBBBC")) +
    ggtitle(paste("Log2cpm Expression of", gene, "top 5 DEGs D24T")) +
    labs(x = "Treatment", y = "log2cpm") +
    theme_bw() +
    theme(
      plot.title = element_text(size = rel(2), hjust = 0.5),
      axis.title = element_text(size = 15, color = "black"),
      axis.text.x = element_text(size = 10, color = "black", angle = 90, hjust = 1)
    )
  print(p)
}

#####D24R#####
process_top5_D24R <- function(gene) {
  gene_data <- top5_D24R_genes %>% filter(Entrez_ID == gene)
  long_data <- gene_data %>%
    pivot_longer(cols = -c(Entrez_ID, SYMBOL), names_to = "Sample", values_to = "log2cpm") %>%
    mutate(
      Drug = case_when(
        grepl("DOX", Sample) ~ "DOX",
        grepl("DMSO", Sample) ~ "DMSO",
        TRUE ~ NA_character_
      ),
      Timepoint = case_when(
        grepl("_24T_", Sample) ~ "24T",
        grepl("_24R_", Sample) ~ "24R",
        grepl("_144R_", Sample) ~ "144R",
        TRUE ~ NA_character_
      ),
      Indv = case_when(
        grepl("Ind1$", Sample) ~ "1",
        grepl("Ind2$", Sample) ~ "2",
        grepl("Ind3$", Sample) ~ "3",
        grepl("Ind4$", Sample) ~ "4",
        grepl("Ind5$", Sample) ~ "5",
        grepl("Ind6$", Sample) ~ "6",
        grepl("Ind6R$", Sample) ~ "6R",
        TRUE ~ NA_character_
      ),
      Condition = paste(Drug, Timepoint, sep = "_")
    )
  long_data$Condition <- factor(
    long_data$Condition,
    levels = c(
      "DOX_24T", 
      "DMSO_24T", 
      "DOX_24R", 
      "DMSO_24R", 
      "DOX_144R", 
      "DMSO_144R"
    )
  )
  return(long_data)
}


#Generate Boxplots from the above function using our gene list above
for (gene in top5_D24R_geneslist) {
  gene_data <- process_top5_D24R(gene)
  p <- ggplot(gene_data, aes(x = Condition, y = log2cpm, fill = Drug)) +
    geom_boxplot(outlier.shape = NA) +
    geom_point(aes(color = Indv), size = 2, alpha = 0.5, position = position_jitter(width = -1, height = 0)) +
    scale_fill_manual(values = c("DOX" = "#499FBD", "DMSO" = "#BBBBBC")) +
    ggtitle(paste("Log2cpm Expression of", gene, "top 5 DEGs D24R")) +
    labs(x = "Treatment", y = "log2cpm") +
    theme_bw() +
    theme(
      plot.title = element_text(size = rel(2), hjust = 0.5),
      axis.title = element_text(size = 15, color = "black"),
      axis.text.x = element_text(size = 10, color = "black", angle = 90, hjust = 1)
    )
  print(p)
}

#####D144R#####
process_top5_D144R <- function(gene) {
  gene_data <- top5_D144R_genes %>% filter(Entrez_ID == gene)
  long_data <- gene_data %>%
    pivot_longer(cols = -c(Entrez_ID, SYMBOL), names_to = "Sample", values_to = "log2cpm") %>%
    mutate(
      Drug = case_when(
        grepl("DOX", Sample) ~ "DOX",
        grepl("DMSO", Sample) ~ "DMSO",
        TRUE ~ NA_character_
      ),
      Timepoint = case_when(
        grepl("_24T_", Sample) ~ "24T",
        grepl("_24R_", Sample) ~ "24R",
        grepl("_144R_", Sample) ~ "144R",
        TRUE ~ NA_character_
      ),
      Indv = case_when(
        grepl("Ind1$", Sample) ~ "1",
        grepl("Ind2$", Sample) ~ "2",
        grepl("Ind3$", Sample) ~ "3",
        grepl("Ind4$", Sample) ~ "4",
        grepl("Ind5$", Sample) ~ "5",
        grepl("Ind6$", Sample) ~ "6",
        grepl("Ind6R$", Sample) ~ "6R",
        TRUE ~ NA_character_
      ),
      Condition = paste(Drug, Timepoint, sep = "_")
    )
  long_data$Condition <- factor(
    long_data$Condition,
    levels = c(
      "DOX_24T", 
      "DMSO_24T", 
      "DOX_24R", 
      "DMSO_24R", 
      "DOX_144R", 
      "DMSO_144R"
    )
  )
  return(long_data)
}


#Generate Boxplots from the above function using our gene list above
for (gene in top5_D144R_geneslist) {
  gene_data <- process_top5_D144R(gene)
  p <- ggplot(gene_data, aes(x = Condition, y = log2cpm, fill = Drug)) +
    geom_boxplot(outlier.shape = NA) +
    geom_point(aes(color = Indv), size = 2, alpha = 0.5, position = position_jitter(width = -1, height = 0)) +
    scale_fill_manual(values = c("DOX" = "#499FBD", "DMSO" = "#BBBBBC")) +
    ggtitle(paste("Log2cpm Expression of", gene, "top 5 DEGs D144R")) +
    labs(x = "Treatment", y = "log2cpm") +
    theme_bw() +
    theme(
      plot.title = element_text(size = rel(2), hjust = 0.5),
      axis.title = element_text(size = 15, color = "black"),
      axis.text.x = element_text(size = 10, color = "black", angle = 90, hjust = 1)
    )
  print(p)
}


```
##LogFC Boxplots for All Conditions
```{r DOX24T DEGs logFC all Conditions}
# Toptable_V.D24T

# Load DEGs Data
DOX_24T <- read.csv("data/new/DEGs/Toptable_V.D24T.csv")
DOX_24R <- read.csv("data/new/DEGs/Toptable_V.D24R.csv")
DOX_144R <- read.csv("data/new/DEGs/Toptable_V.D144R.csv")

#make a list of all of the genes in this set so I can plot the logFC in other sets
D24T_DEGs <- DOX_24T$Entrez_ID[DOX_24T$adj.P.Val < 0.05]
length(D24T_DEGs)
#9243 genes in length after adj. p value cutoff
#if I did p value only - 9658 genes

#now that I have a list of my DEGs from D24T - pull these genes out from the other DEG lists
# D24R_DEGs <- Toptable_V.D24R[Toptable_V.D24R$adj.P.Val < 0.05,]

# D24R_DEGs_D24T <- D24R_DEGs %>%  
#   rownames_to_column(., var = "Entrez_ID")

# D24R_DEGs_D24T <- D24R_DEGs_D24T[D24R_DEGs_D24T$Entrez_ID %in% D24T_DEGs,]
# dim(D24R_DEGs_D24T)
#4831 genes in common here after adj p value cutoff

# D144R_DEGs <- Toptable_V.D144R[Toptable_V.D144R$adj.P.Val < 0.05,]
# 
# D144R_DEGs_D24T <- D144R_DEGs %>%  
#   rownames_to_column(., var = "Entrez_ID")
# 
# D144R_DEGs_D24T <- D144R_DEGs_D24T[D144R_DEGs_D24T$Entrez_ID %in% D24T_DEGs,]
# dim(D144R_DEGs_D24T)
#322 genes in common after adj p value cutoff

#now I want to plot the logFC of these

#ignore the above for now, just plot those full gene sets in logFC
D24T_DEGs <- DOX_24T$Entrez_ID[DOX_24T$adj.P.Val < 0.05]
length(D24T_DEGs)

D24R_DEGs <- DOX_24R$Entrez_ID[DOX_24R$adj.P.Val < 0.05]
length(D24R_DEGs)

D144R_DEGs <- DOX_144R$Entrez_ID[DOX_144R$adj.P.Val < 0.05]
length(D144R_DEGs)
#now that I have the full list of genes, I want to plot the logFC across conditions
#to do this - make a combined toptable

# Toptable_list

#plot the set of genes across conditions
# 
# logFC_long_allsets <- imap_dfr(Toptable_list, function(tbl, condition) {
#   tbl %>% 
#     rownames_to_column(var = "Entrez_ID") %>% 
#     dplyr::select(Entrez_ID, logFC) %>% 
#     mutate(Condition = condition)
# })
# 
# 
# ggplot(logFC_long_allsets, aes(x = Condition, y = logFC, group = Entrez_ID, color = Entrez_ID)) +
#   geom_boxplot() +
#   geom_point(size = 2) +
#   labs(
#     title = "logFC of Genes Across Conditions",
#     x = "Condition",
#     y = "logFC"
#   ) +
#   theme_minimal()


####Try this####

#Combine the toptables I have from pairwise analysis into a single dataframe
d24_toptable_dxr <- Toptable_V.D24T %>% 
  rownames_to_column(var = "Entrez_ID") %>% 
  mutate(Time = "24")

d24r_toptable_dxr <- Toptable_V.D24R %>% 
  rownames_to_column(var = "Entrez_ID") %>% 
  mutate(Time = "24R")

d144r_toptable_dxr <- Toptable_V.D144R %>% 
  rownames_to_column(var = "Entrez_ID") %>% 
  mutate(Time = "144R")

combined_toptables_dxr <- bind_rows(
  d24_toptable_dxr,
  d24r_toptable_dxr,
  d144r_toptable_dxr)

#Filter the data based on each motif
filt_toptable_dxr <- combined_toptables_dxr %>% 
  dplyr::filter(Entrez_ID  %in% D24T_DEGs) %>% 
  mutate(absFC = abs(logFC)) %>% 
  mutate(time = factor(Time, levels = c("24", "24R", "144R"), labels = c("24hr", "24hr Recovery", "144hr Recovery"))) %>% 
  ggplot(., aes(x = time, y = logFC))+
  geom_boxplot(aes(fill = time))+
  scale_fill_manual(values = time_col)+
  guides(fill = guide_legend(title = "Time"))+
  theme_bw()+
  xlab(" ")+
  ylab("logFC")+
  theme_bw()+
  ggtitle("LogFC for D24T DEGs Across Conditions")+
  theme(plot.title = element_text(size = rel(1.5), hjust = 0.5),
        axis.title = element_text(size = 15, colour = "black"),
        strip.background = element_rect(fill = "#CAD899"),
        axis.text.x = element_text(size = 8, colour = "white", angle = 15),
        strip.text.x = element_text(size = 12, colour = "black", face = "bold"))

#now do the same with the other conditions

filt_toptable_dxr_24r <- combined_toptables_dxr %>% 
  dplyr::filter(Entrez_ID  %in% D24R_DEGs) %>% 
  mutate(absFC = abs(logFC)) %>% 
  mutate(time = factor(Time, levels = c("24", "24R", "144R"), labels = c("24hr", "24hr Recovery", "144hr Recovery"))) %>% 
  ggplot(., aes(x = time, y = logFC))+
  geom_boxplot(aes(fill = time))+
  scale_fill_manual(values = time_col)+
  guides(fill = guide_legend(title = "Time"))+
  theme_bw()+
  xlab(" ")+
  ylab("logFC")+
  theme_bw()+
  ggtitle("LogFC for D24R DEGs Across Conditions")+
  theme(plot.title = element_text(size = rel(1.5), hjust = 0.5),
        axis.title = element_text(size = 15, colour = "black"),
        strip.background = element_rect(fill = "#CAD899"),
        axis.text.x = element_text(size = 8, colour = "white", angle = 15),
        strip.text.x = element_text(size = 12, colour = "black", face = "bold"))

#D144R

filt_toptable_dxr_144r <- combined_toptables_dxr %>% 
  dplyr::filter(Entrez_ID  %in% D144R_DEGs) %>% 
  mutate(absFC = abs(logFC)) %>% 
  mutate(time = factor(Time, levels = c("24", "24R", "144R"), labels = c("24hr", "24hr Recovery", "144hr Recovery"))) %>% 
  ggplot(., aes(x = time, y = logFC))+
  geom_boxplot(aes(fill = time))+
  scale_fill_manual(values = time_col)+
  guides(fill = guide_legend(title = "Time"))+
  theme_bw()+
  xlab(" ")+
  ylab("logFC")+
  theme_bw()+
  ggtitle("LogFC for D144R DEGs Across Conditions")+
  theme(plot.title = element_text(size = rel(1.5), hjust = 0.5),
        axis.title = element_text(size = 15, colour = "black"),
        strip.background = element_rect(fill = "#CAD899"),
        axis.text.x = element_text(size = 8, colour = "white", angle = 15),
        strip.text.x = element_text(size = 12, colour = "black", face = "bold"))

#now put the names of these graphs to print them
filt_toptable_dxr
filt_toptable_dxr_24r
filt_toptable_dxr_144r


```

#Perform RUVs Correction
##Set Up Data and Perform PCAs on Un-normalized Data
```{r RUVs Correction Data Setup - no RUV yet, fig.height=6, fig.width=8}

filt_gene_list <- rownames(filcpm_matrix)
#14319 genes as usual

#in order to make this match with annot later down the line, change the col names for counts_raw_matrix to match final_sample_names in annot

#i'll also want to make sure I keep the replicate for this set

colnames(counts_raw_matrix) <- Metadata$Final_sample_name

RUV_filt_counts <- counts_raw_matrix %>% 
  as.data.frame() %>% 
  dplyr::filter(., row.names(.)%in% filt_gene_list)

#add in the annotation files
ind_num <- readRDS("data/new/ind_num.RDS")
annot <- read.csv("data/new/Metadata.csv")

#  counts need to be integer values and in a numeric matrix
# note: the log transformation needs to be accounted for in the isLog argument in RUVs function.
counts <- as.matrix(RUV_filt_counts)
#saveRDS(counts, "data/new/RUV/filt_counts_matrix.RDS")

# Create a DataFrame for the phenoData
phenoData <- DataFrame(annot)

# Now create the RangedSummarizedExperiment necessary for RUVs input
# looks like it did need both the phenodata and the counts.
set <- SummarizedExperiment(assays =  counts, metadata = phenoData)

# Generate a background matrix
# The column "Cond" holds the comparisons that you actually want to make. DOX_24, DMSO_24,5FU_24, DOX_3,etc.
scIdx <-RUVSeq::makeGroups(phenoData$Condition)
scIdx

#now I've made all of the data I need for this - they are located in each section for k values

#DO NOT USE THESE COUNTS FOR LINEAR MODELING

#colors for all of the plots
fill_col_ind <- c("#66C2A5", "#FC8D62", "#1F78B4", "#E78AC3", "#A6D854", "#FFD92A", "#8B3E9B")

fill_col_ind_dark <- c("#003F5C", "#45AE91",  "#58508D", "#BC4099", "#8B3E9B", "#FF6361", "#FF2362")

fill_col_tx <- c("#63666D", "#499FBD", "#DCACED")

fill_col_txtime <- c("#003F5C", "#45AE91",  "#58508D", "#BC4099", "#8B3E9B", "#FF6361", "#FF2362", "#A6D854", "#FC8D62")

# before ruv (counts PCA)
prcomp_res_counts <- prcomp(t(counts), scale. = FALSE, center = TRUE)
annot_prcomp_res <- prcomp_res_counts$x %>% cbind(., annot)

group_2 <- annot$Condition

#now plot my PCA for filtered counts
####PC1/PC2####
ggplot2::autoplot(prcomp_res_counts, 
                  data = annot, 
                  colour = "Condition", 
                  shape = "Time", 
                  size =4, 
                  x=1, 
                  y=2) +
  ggrepel::geom_text_repel(label=ind_num, 
                           vjust = -0.5, 
                           max.overlaps = 30) +
  scale_color_manual(values=cond_col) +
  ggtitle(expression("PCA of Filtered Counts")) +
  theme_bw()

####PC2/PC3####
ggplot2::autoplot(prcomp_res_counts, 
                  data = annot, 
                  colour = "Condition", 
                  shape = "Time", 
                  size =4, 
                  x=2, 
                  y=3) +
  ggrepel::geom_text_repel(label=ind_num, 
                           vjust = -0.5, 
                           max.overlaps = 30) +
  scale_color_manual(values=cond_col) +
  ggtitle(expression("PCA of Filtered Counts")) +
  theme_bw()

#go ahead and plot PCA of log2cpm to compare (somewhat) later since the norm counts output isn't possible with these data since they don't undergo correction

prcomp_res_cpm <- prcomp(t(filcpm_matrix %>% as.matrix()), center =  TRUE)

####PC1/PC2####
ggplot2::autoplot(prcomp_res_cpm, 
                  data = annot, 
                  colour = "Condition", 
                  shape = "Time", 
                  size =4, 
                  x=1, 
                  y=2) +
  ggrepel::geom_text_repel(label=ind_num, 
                           vjust = -0.5, 
                           max.overlaps = 30) +
  scale_color_manual(values=cond_col) +
  ggtitle(expression("PCA of log2cpm no RUVs")) +
  theme_bw()

####PC2/PC3####
ggplot2::autoplot(prcomp_res_cpm, 
                  data = annot, 
                  colour = "Condition", 
                  shape = "Time", 
                  size =4, 
                  x=2, 
                  y=3) +
  ggrepel::geom_text_repel(label=ind_num, 
                           vjust = -0.5, 
                           max.overlaps = 30) +
  scale_color_manual(values=cond_col) +
  ggtitle(expression("PCA of log2cpm no RUVs")) +
  theme_bw()


####new PCA plots no correction####
#PCA plots for each value of k attached in each section

#####Now start performing RUV 1-3###

```
##RUVs with k = 1 
```{r RUVs k1, fig.height=6, fig.width=8}
#Apply RUVs function from RUVSeq
#"k" will be iteratively adjusted over time depending on your PCA.
set1 <- RUVSeq::RUVs(x = counts, k =1, scIdx = scIdx, isLog = FALSE)

#get the ruv weights to put into the linear model. n weights = k.
#k=1
RUV_df1 <- set1$W %>% as.data.frame()
RUV_df1$Names <- rownames(RUV_df1)

#Check that the names match
#k=1
RUV_df_rm1 <- RUV_df1[RUV_df1$Names %in% annot$Final_sample_name, ] 
RUV_1 <-  RUV_df_rm1$W_1

#saveRDS(RUV_df_rm1, "data/new/RUV_df_rm1.RDS")
#saveRDS(RUV_1, "data/new/RUV_1.RDS")

#PCA checks
#k=1
prcomp_res_1 <- prcomp(t(set1$normalizedCounts), scale. = FALSE, center = TRUE)
annot_prcomp_res_1 <- prcomp_res_1$x %>% cbind(., annot)

ggplot2::autoplot(prcomp_res_1, data = annot, colour = "Condition", shape = "Time", size =4, x = 1, y = 2)+
  theme_bw()+
  scale_color_manual(values=cond_col)+
  ggrepel::geom_text_repel(label= ind_num, vjust = -0.5, max.overlaps = 30)+
  ggtitle("RUVs Correction k=1 NormCounts")

ggplot2::autoplot(prcomp_res_1, data = annot, colour = "Condition", shape = "Time", size =4, x=2, y=3)+
  theme_bw()+
  scale_color_manual(values=cond_col)+
  ggrepel::geom_text_repel(label= ind_num, vjust = -0.5, max.overlaps = 30)+
  ggtitle("RUVs Correction k=1 NormCounts")

#also try by converting these values to log2cpm

RUV_df_rm1_cpm <- cpm(set1$normalizedCounts, log = TRUE)

prcomp_res_1_cpm <- prcomp(t(RUV_df_rm1_cpm), scale. = FALSE, center = TRUE)
annot_prcomp_res_1_cpm <- prcomp_res_1_cpm$x %>% cbind(., annot)

##PC1/2
ggplot2::autoplot(prcomp_res_1_cpm, 
                  data = annot, 
                  colour = "Condition", 
                  shape = "Time", 
                  size = 4,
                  x=1,
                  y=2)+
  theme_bw()+
  scale_color_manual(values=cond_col)+
  ggrepel::geom_text_repel(label= ind_num, 
                           vjust = -0.5, 
                           max.overlaps = 30)+
  ggtitle("RUVs Correction k=1 log2cpm")

###PC2/3
ggplot2::autoplot(prcomp_res_1_cpm, 
                  data = annot, 
                  colour = "Condition", 
                  shape = "Time", 
                  size = 4, 
                  x=2, 
                  y=3)+
  theme_bw()+
  scale_color_manual(values=cond_col)+
  ggrepel::geom_text_repel(label= ind_num, 
                           vjust = -0.5, 
                           max.overlaps = 30)+
  ggtitle("RUVs Correction k=1 log2cpm")

```

##RUVs with k = 2
```{r RUVs k2, fig.height=6, fig.width=8}
#Apply RUVs function from RUVSeq
#"k" will be iteratively adjusted over time depending on your PCA.
set2 <- RUVSeq::RUVs(x = counts, k =2, scIdx = scIdx, isLog = FALSE)

#get the ruv weights to put into the linear model. n weights = k.
#k=2
RUV_df2 <- set2$W %>% as.data.frame()
RUV_df2$Names <- rownames(RUV_df2)

#Check that the names match
#k=2
RUV_df_rm2 <- RUV_df2[RUV_df2$Names %in% annot$Final_sample_name, ] 
RUV_2 <-  RUV_df_rm2$W_2

#PCA checks
#k=2
prcomp_res_2 <- prcomp(t(set2$normalizedCounts), scale. = FALSE, center = TRUE)
annot_prcomp_res_2 <- prcomp_res_2$x %>% cbind(., annot)

##PC1/2
ggplot2::autoplot(prcomp_res_2, 
                  data = annot, 
                  colour = "Condition", 
                  shape = "Time", 
                  size =4, 
                  x=1,
                  y=2)+
  theme_bw()+
  scale_color_manual(values=cond_col)+
  ggrepel::geom_text_repel(label= ind_num, 
                           vjust = -0.5, 
                           max.overlaps = 30)+
  ggtitle("RUVs Correction k=2 NormCounts")

###PC2/3
ggplot2::autoplot(prcomp_res_2, 
                  data = annot, 
                  colour = "Condition", 
                  shape = "Time", 
                  size =4, 
                  x=2, 
                  y=3)+
  theme_bw()+
  scale_color_manual(values=cond_col)+
  ggrepel::geom_text_repel(label= ind_num, 
                           vjust = -0.5, 
                           max.overlaps = 30)+
  ggtitle("RUVs Correction k=2 NormCounts")

#now convert this to log2cpm using the normalized counts from set2

RUV_df_rm2_cpm <- cpm(set2$normalizedCounts, log = TRUE)

prcomp_res_2_cpm <- prcomp(t(RUV_df_rm2_cpm), scale. = FALSE, center = TRUE)
annot_prcomp_res_2_cpm <- prcomp_res_2_cpm$x %>% cbind(., annot)

ggplot2::autoplot(prcomp_res_2_cpm, 
                  data = annot, 
                  colour = "Condition", 
                  shape = "Time", 
                  size =4, 
                  x=1, 
                  y=2)+
  theme_bw()+
  scale_color_manual(values=cond_col)+
  ggrepel::geom_text_repel(label= ind_num, 
                           vjust = -0.5, 
                           max.overlaps = 30)+
  ggtitle("RUVs Correction k=2 log2cpm")

###PC2/3
ggplot2::autoplot(prcomp_res_2_cpm, 
                  data = annot, 
                  colour = "Condition", 
                  shape = "Time", 
                  size =4, 
                  x=2, 
                  y=3)+
  theme_bw()+
  scale_color_manual(values=cond_col)+
  ggrepel::geom_text_repel(label= ind_num, 
                           vjust = -0.5, 
                           max.overlaps = 30)+
  ggtitle("RUVs Correction k=2 log2cpm")

```

#RUVs with k = 3
```{r RUVs k3, fig.height=6, fig.width=8}

#Apply RUVs function from RUVSeq
#"k" will be iteratively adjusted over time depending on your PCA.
set3 <- RUVSeq::RUVs(x = counts, k =3, scIdx = scIdx, isLog = FALSE)

#get the ruv weights to put into the linear model. n weights = k.
#k=3
RUV_df3 <- set3$W %>% as.data.frame()
RUV_df3$Names <- rownames(RUV_df3)

#Check that the names match
#k=3
RUV_df_rm3 <- RUV_df3[RUV_df3$Names %in% annot$Final_sample_name, ] 
RUV_3 <-  RUV_df_rm3$W_3

#PCA checks
#k=3
prcomp_res_3 <- prcomp(t(set3$normalizedCounts), scale. = FALSE, center = TRUE)
annot_prcomp_res_3 <- prcomp_res_3$x %>% cbind(., annot)

###PC1/2
ggplot2::autoplot(prcomp_res_3, 
                  data = annot, 
                  colour = "Condition", 
                  shape = "Time", 
                  size =4, 
                  x=1, 
                  y=2)+
  theme_bw()+
  scale_color_manual(values=cond_col)+
  ggrepel::geom_text_repel(label= ind_num, 
                           vjust = -0.5, 
                           max.overlaps = 30)+
  ggtitle("RUVs Correction k=3 NormCounts")

###PC2/3
ggplot2::autoplot(prcomp_res_3, 
                  data = annot, 
                  colour = "Condition", 
                  shape = "Time", 
                  size =4, 
                  x=2, 
                  y=3)+
  theme_bw()+
  scale_color_manual(values=cond_col)+
  ggrepel::geom_text_repel(label= ind_num, 
                           vjust = -0.5, 
                           max.overlaps = 30)+
  ggtitle("RUVs Correction k=3 NormCounts")

#now convert this to log2cpm using the normalized counts from set3

RUV_df_rm3_cpm <- cpm(set3$normalizedCounts, log = TRUE)

prcomp_res_3_cpm <- prcomp(t(RUV_df_rm3_cpm), scale. = FALSE, center = TRUE)
annot_prcomp_res_3_cpm <- prcomp_res_3_cpm$x %>% cbind(., annot)

##PC1/2
ggplot2::autoplot(prcomp_res_3_cpm, 
                  data = annot, 
                  colour = "Condition", 
                  shape = "Time", 
                  size =4, 
                  x=1, 
                  y=2)+
  theme_bw()+
  scale_color_manual(values=cond_col)+
  ggrepel::geom_text_repel(label= ind_num, 
                           vjust = -0.5, 
                           max.overlaps = 30)+
  ggtitle("RUVs Correction k=3 log2cpm")

###PC2/3
ggplot2::autoplot(prcomp_res_3_cpm, 
                  data = annot, 
                  colour = "Condition", 
                  shape = "Time", 
                  size =4, 
                  x=2, 
                  y=3)+
  theme_bw()+
  scale_color_manual(values=cond_col)+
  ggrepel::geom_text_repel(label= ind_num, 
                           vjust = -0.5, 
                           max.overlaps = 30)+
  ggtitle("RUVs Correction k=3 log2cpm")

```

```{r RUVs Boxplots of Contributing Factors, include = FALSE}
#I want to take a look at my RUV corrected k=3 PCA to see what the major contributing factors are - I'll create boxplots with my metadata to accompany the PCA plots

#load my normalized counts data and my log2cpm converted data
# normcounts_k1_matrix <- set1$normalizedCounts %>% as.matrix()
# RUV_k1_cpm <- cpm(set1$normalizedCounts, log = TRUE)
# 
# #load in my metadata sheet
# Metadata_RUV <- read.csv("data/Metadata.csv")
# Metadata_RUV$Time <- factor(Metadata_RUV$Time, 
#                             levels = c("24T", "24R", "144R"), 
#                             labels = c("24T", "24R", "144R"))
# Metadata_RUV$Ind <- as.factor(Metadata_RUV$Ind)
# Metadata_RUV$Drug <- as.character(Metadata$Drug)
# Metadata_RUV$Sex <- factor(Metadata_RUV$Sex, 
#                            levels = c("M", "F")) 
# 
# 
# #PCA plots in normalized counts and log2cpm
# 
# prcomp_res_3_RUV_normcounts <- prcomp(t(normcounts_k3_matrix), scale. = FALSE, center = TRUE)
# pca_df_3_RUV_normcounts <- as.data.frame(prcomp_res_3_RUV_normcounts$x[, 1:3])  #PC1–PC3
# pca_df_3_RUV_normcounts$Ind <- Metadata_RUV$Ind
# pca_df_3_RUV_normcounts$Drug <- Metadata_RUV$Drug
# pca_df_3_RUV_normcounts$Time <- Metadata_RUV$Time
# pca_df_3_RUV_normcounts$Sex <- Metadata_RUV$Sex
# 
# prcomp_res_3_RUV_cpm <- prcomp(t(RUV_k3_cpm), scale. = FALSE, center = TRUE)
# pca_df_3_RUV_cpm <- as.data.frame(prcomp_res_3_RUV_cpm$x[,1:3]) #PC1-3
# pca_df_3_RUV_cpm$Ind <- Metadata_RUV$Ind
# pca_df_3_RUV_cpm$Drug <- Metadata_RUV$Drug
# pca_df_3_RUV_cpm$Time <- Metadata_RUV$Time
# pca_df_3_RUV_cpm$Sex <- Metadata_RUV$Sex
# 
# #p-value from linear model
# get_regr_pval <- function(mod) {
#   stopifnot(class(mod) == "lm")
#   fstat <- summary(mod)$fstatistic
#   pval <- 1 - pf(fstat[1], fstat[2], fstat[3])
#   return(pval)
# }
# 
# #create boxplots of PCA contributing factors based on metadata
# plot_pc_k3_normcounts_box <- function(df, group_var, pc) {
#   group_data <- df[[group_var]]
#   n_groups <- length(unique(group_data))
#   
#   if (n_groups > 1) {
#     model <- lm(df[[pc]] ~ group_data)
#     pval <- get_regr_pval(model)
#     pval_label <- paste0("p-value: ", signif(pval, 3))
#   } else {
#     pval_label <- "p-value: NA"
#   }
#   
#   ggplot(df, aes(x = .data[[group_var]], y = .data[[pc]], fill = .data[[group_var]])) +
#     geom_boxplot(color = "black") +
#     theme_bw(base_size = 11) +
#     ylab(pc) + xlab(group_var) +
#     ggtitle(NULL, subtitle = pval_label) +
#     theme(
#       legend.position = "none",
#       plot.subtitle = element_text(size = 10),
#       panel.border = element_rect(color = "black", fill = NA)
#     )
# }
# 
# #Generate 12 plots: PC1–3 × Ind, Drug, Time, Sex (these are )
# pcs <- c("PC1", "PC2", "PC3")
# group_vars <- c("Ind", "Drug", "Time", "Sex")
# plots <- list()
# 
# for (pc in pcs) {
#   for (group in group_vars) {
#     key <- paste(pc, group, sep = "_")
#     
#     base_plot <- plot_pc_k3_normcounts_box(pca_df_3_RUV_normcounts, group, pc)
#     
#     if (pc == "PC1") {
#       upper_limit <- max(pca_df_3_RUV_normcounts[[pc]], na.rm = TRUE) * 1.1
#       plots[[key]] <- base_plot +
#         scale_y_continuous(limits = c(-60, upper_limit),
#                            breaks = c(-60, -30, 0, 30, 60, 90, 120))
#     } else {
#       plots[[key]] <- base_plot
#     }
#   }
# }
# 
# # 📌 Remove main titles (retain subtitles for p-values)
# plots <- lapply(plots, function(p) {
#   p + theme(plot.title = element_blank())
# })
# 
# # 📌 Create column headers
# header_ind  <- ggplot() + theme_void() + ggtitle("Ind")   + theme(plot.title = element_text(hjust = 0.5, size = 14, face = "bold"))
# header_drug <- ggplot() + theme_void() + ggtitle("Drug")  + theme(plot.title = element_text(hjust = 0.5, size = 14, face = "bold"))
# header_conc <- ggplot() + theme_void() + ggtitle("Conc")  + theme(plot.title = element_text(hjust = 0.5, size = 14, face = "bold"))
# header_time <- ggplot() + theme_void() + ggtitle("Time")  + theme(plot.title = element_text(hjust = 0.5, size = 14, face = "bold"))
# header_sex  <- ggplot() + theme_void() + ggtitle("Sex")   + theme(plot.title = element_text(hjust = 0.5, size = 14, face = "bold"))  # ✅ New header
# 
# # 📌 Assemble 5-column layout with 3 PC rows
# final_plot <- (
#   (header_ind | header_drug | header_conc | header_time | header_sex) /
#     (plots[["PC1_Ind"]] | plots[["PC1_Drug"]] | plots[["PC1_Conc"]] | plots[["PC1_Time"]] | plots[["PC1_Sex"]]) /
#     (plots[["PC2_Ind"]] | plots[["PC2_Drug"]] | plots[["PC2_Conc"]] | plots[["PC2_Time"]] | plots[["PC2_Sex"]]) /
#     (plots[["PC3_Ind"]] | plots[["PC3_Drug"]] | plots[["PC3_Conc"]] | plots[["PC3_Time"]] | plots[["PC3_Sex"]])
# ) + plot_layout(heights = c(0.07, 1, 1, 1))  # Title row height
# 
# # 📌 Display the plot
# print(final_plot)


```

#Plot Spearman Heatmaps for RUVs Normalized Counts Data
```{r RUVs HM Spearman, fig.height=10, fig.width=12}
#Now that I've put together the PCA plots for both normalized counts and log2cpm
#I want to make these into heatmaps

####RUVs k=1-3
#check to make sure that the column names are correct
dim(RUV_filt_counts)
dim(set1$normalizedCounts)
dim(set2$normalizedCounts)
dim(set3$normalizedCounts)

#take the normalized counts from k=1 and put together a dataframe with the correct columns
normcounts_k0 <- RUV_filt_counts
normcounts_k1 <- set1$normalizedCounts %>% as.data.frame()
#do the same with k=2 and k=3
normcounts_k2 <- set2$normalizedCounts %>% as.data.frame()
normcounts_k3 <- set3$normalizedCounts %>% as.data.frame()

#do the same with the log2cpm conversion
cpm_k0 <- cpm(normcounts_k0, log = TRUE) %>% as.data.frame()
cpm_k1 <- cpm(set1$normalizedCounts, log = TRUE) %>% as.data.frame()
cpm_k2 <- cpm(set2$normalizedCounts, log = TRUE) %>% as.data.frame()
cpm_k3 <- cpm(set3$normalizedCounts, log = TRUE) %>% as.data.frame()

#compute the correlation matrices for RUVs 1-3 with normalized counts
#k=0
cor_matrix_spmn_k0 <- cor(normcounts_k0,
                          y = NULL,
                          use = "everything", 
                          method = "spearman")
#k=1
cor_matrix_spmn_k1 <- cor(normcounts_k1,
                           y = NULL,
                           use = "everything",
                           method = "spearman")

#k=2
cor_matrix_spmn_k2 <- cor(normcounts_k2,
                          y = NULL,
                          use = "everything",
                          method = "spearman")

#k=3
cor_matrix_spmn_k3 <- cor(normcounts_k3,
                          y = NULL,
                          use = "everything",
                          method = "spearman")

#Do the same with the log2cpm converted versions
#k=0
cor_matrix_spmn_k0_cpm <- cor(cpm_k0,
                           y = NULL,
                           use = "everything",
                           method = "spearman")

#k=1
cor_matrix_spmn_k1_cpm <- cor(cpm_k1,
                           y = NULL,
                           use = "everything",
                           method = "spearman")

#k=2
cor_matrix_spmn_k2_cpm <- cor(cpm_k2,
                          y = NULL,
                          use = "everything",
                          method = "spearman")

#k=3
cor_matrix_spmn_k3_cpm <- cor(cpm_k3,
                          y = NULL,
                          use = "everything",
                          method = "spearman")

#extract metadata columns
Individual <- as.character(Metadata$Ind)
Time <- as.character(Metadata$Time)
Treatment <- as.character(Metadata$Drug)

# Define color palettes for annotations
annot_col_cor = list(Treatment = c("DOX" = "#499FBD", 
                               "DMSO" = "#BBBBBC"),
                     Individuals = c("1" = "#003F5C", 
                                     "2" = "#45AE91", 
                                     "3" = "#58209D", 
                                     "4" = "#8B3E9B", 
                                     "5" = "#FF6361", 
                                     "6" = "#BC4169", 
                                     "6R" = "#FF2362"),
                     Timepoints = c("24T" = "#238B45",
                                    "24R" = "#74C476", 
                                    "144R" = "#C7E9C0"))

tx_colors <- c("DOX" = "#499FBD", 
                 "DMSO" = "#BBBBBC")
ind_colors <- c("1" = "red",
                "2" = "orange",
                "3" = "yellow",
                "4" = "green",
                "5" = "blue",
                "6" = "violet",
                "6R" = "purple")
time_colors <- c("24T" = "#238B45",
                 "24R" = "#74C476",
                 "144R" = "#C7E9C0")

# Create annotations
top_annotation <- HeatmapAnnotation(
  Individual = Individual, 
  Time = Time,
  Treatment = Treatment,
  col = list(
    Individual = ind_colors, 
    Time = time_colors,
    Treatment = tx_colors
  )
)

####ANNOTATED HEATMAPS####
###Spearman Heatmap k=0 ####
heatmap_spmn_k0 <- Heatmap(cor_matrix_spmn_k0,
                           name = "Spearman",
                           top_annotation = top_annotation,
                           show_row_names = TRUE,
                           show_column_names = TRUE,
                           cluster_rows = TRUE,
                           cluster_columns = TRUE,
                           border = TRUE, 
                           column_title = "Filtered Counts no RUVs")

# Draw the heatmap k=0
draw(heatmap_spmn_k0)

####Spearman Heatmap k=1 ####
heatmap_spmn_k1 <- Heatmap(cor_matrix_spmn_k1,
                           name = "Spearman",
                           top_annotation = top_annotation,
                           show_row_names = TRUE,
                           show_column_names = TRUE,
                           cluster_rows = TRUE,
                           cluster_columns = TRUE,
                           border = TRUE, 
                           column_title = "Normalized Counts k=1")

# Draw the heatmap k=1
draw(heatmap_spmn_k1)

####Spearman Heatmap k=2####
heatmap_spmn_k2 <- Heatmap(cor_matrix_spmn_k2,
                           name = "Spearman",
                           top_annotation = top_annotation,
                           show_row_names = TRUE,
                           show_column_names = TRUE,
                           cluster_rows = TRUE,
                           cluster_columns = TRUE,
                           border = TRUE, 
                           column_title = "Normalized Counts k=2")

# Draw the heatmap k=2
draw(heatmap_spmn_k2)

####Spearman Heatmap k=3####
heatmap_spmn_k3 <- Heatmap(cor_matrix_spmn_k3,
                           name = "Spearman",
                           top_annotation = top_annotation,
                           show_row_names = TRUE,
                           show_column_names = TRUE,
                           cluster_rows = TRUE,
                           cluster_columns = TRUE,
                           border = TRUE, 
                           column_title = "Normalized Counts k=3")

# Draw the heatmap k=3
draw(heatmap_spmn_k3)


####Spearman Heatmap k=0 log2cpm####
heatmap_spmn_k0_cpm <- Heatmap(cor_matrix_spmn_k0_cpm,
                           name = "Spearman",
                           top_annotation = top_annotation,
                           show_row_names = TRUE,
                           show_column_names = TRUE,
                           cluster_rows = TRUE,
                           cluster_columns = TRUE,
                           border = TRUE, 
                           column_title = "log2cpm of Filtered Counts no RUVs")

# Draw the heatmap k=0 log2cpm
draw(heatmap_spmn_k0_cpm)

####Spearman Heatmap k=1 log2cpm####
heatmap_spmn_k1_cpm <- Heatmap(cor_matrix_spmn_k1_cpm,
                           name = "Spearman",
                           top_annotation = top_annotation,
                           show_row_names = TRUE,
                           show_column_names = TRUE,
                           cluster_rows = TRUE,
                           cluster_columns = TRUE,
                           border = TRUE, 
                           column_title = "log2cpm of Normalized Counts k=1")

# Draw the heatmap k=1 log2cpm
draw(heatmap_spmn_k1_cpm)

####Spearman Heatmap k=2 log2cpm####
heatmap_spmn_k2_cpm <- Heatmap(cor_matrix_spmn_k2_cpm,
                           name = "Spearman",
                           top_annotation = top_annotation,
                           show_row_names = TRUE,
                           show_column_names = TRUE,
                           cluster_rows = TRUE,
                           cluster_columns = TRUE,
                           border = TRUE, 
                           column_title = "log2cpm of Normalized Counts k=2")

# Draw the heatmap k=2 log2cpm
draw(heatmap_spmn_k2_cpm)

####Spearman Heatmap k=3 log2cpm####
heatmap_spmn_k3_cpm <- Heatmap(cor_matrix_spmn_k3_cpm,
                           name = "Spearman",
                           top_annotation = top_annotation,
                           show_row_names = TRUE,
                           show_column_names = TRUE,
                           cluster_rows = TRUE,
                           cluster_columns = TRUE,
                           border = TRUE, 
                           column_title = "log2cpm of Normalized Counts k=3")

# Draw the heatmap k=3 log2cpm
draw(heatmap_spmn_k3_cpm)


```
#Perform Differential Expression Analysis with k = 1 RUVs Correction
```{r DE RUVs k1}
#same DGEList object as before
dge <- readRDS("data/new/dge_matrix.RDS")

#check normalization factors from TMM normalization of LIBRARIES
dge$samples

#read in my covariate information RUV_1 dataframe + remove 6R
RUV_df_rm1 <- readRDS("data/new/RUV_df_rm1.RDS")

#filter out 6R for DE analysis
RUV_1_df_filt <- RUV_df_rm1[!grepl("6R$", rownames(RUV_df_rm1)), , drop = FALSE]

Metadata_2$W_1 <- RUV_1_df_filt$W_1

#now ensure that RUV_1 has the right number of cols after removing rep
length(RUV_1_df_filt$W_1)
#36 

#now make this into a list
RUV_1_DE <-  RUV_1_df_filt$W_1

#saveRDS(RUV_1_DE, "data/new/RUV_1_DE.RDS")

#create my design matrix for DE + RUVs covariate k=1
design1 <- model.matrix(~0 + RUV_1_DE + Metadata_2$Condition)
colnames(design1) <- gsub("Metadata_2\\$Condition", "", colnames(design1))

#take care that the matrix automatically sorts cols alphabetically
##currently DMSO144R, DMSO24R, DMSO24T, DOX144R, DOX24R, DOX24T

#run duplicate correlation for individual effect
corfit1 <- duplicateCorrelation(object = dge$counts, design = design1, block = Metadata_2$Ind)

#voom transformation and plot
v1 <- voom(dge, design1, block = Metadata_2$Ind, correlation = corfit1$consensus.correlation, plot = TRUE)

#fit my linear model
fit1 <- lmFit(v1, design1, block = Metadata_2$Ind, correlation = corfit1$consensus.correlation)

#make my contrast matrix to compare across tx and veh
contrast_matrix_RUV <- makeContrasts(
  V.D24T = DOX_24T - DMSO_24T,
  V.D24R = DOX_24R - DMSO_24R, 
  V.D144R = DOX_144R - DMSO_144R,
  RUV_1_24T = RUV_1_DE - DMSO_24T,
  RUV_1_24R = RUV_1_DE - DMSO_24R,
  RUV_1_144R = RUV_1_DE - DMSO_144R,  
  levels = design1
)

#apply these contrasts to compare DOX to DMSO VEH
fit_RUV <- contrasts.fit(fit1, contrast_matrix_RUV)
fit_RUV <- eBayes(fit_RUV)

#plot the mean-variance trend
plotSA(fit_RUV, main = "Mean-Variance Trend, RUVs k=1")

#look at the summary of your results
##this tells you the number of DEGs in each condition
results_summary1 <- decideTests(fit_RUV, adjust.method = "BH", p.value = 0.05)

summary(results_summary1)
#        V.D24T V.D24R V.D144R RUV_1_24T RUV_1_24R RUV_1_144R
# Down     4866   3727     466     13212     13224      13168
# NotSig   4899   7107   13659      1014      1002       1058
# Up       4554   3485     194        93        93         93

#compare this to my previous DEGs I found
summary(results_summary)
#        V.D24T V.D24R V.D144R
# Down     4723   3593     359
# NotSig   5076   7151   13810
# Up       4520   3575     150


#overall, there are more DEGs found after RUVs k=1 correction 
#this was an expected result as it increases tx effect w/ correction

```
##Generate Toptables RUVs
```{r TopTables DE RUV}
# Generate Top Table for Specific Comparisons

Toptable_V.D24T_k1 <- topTable(fit = fit_RUV, coef = "V.D24T", number = nrow(x), adjust.method = "BH", p.value = 1, sort.by = "none")
#write.csv(Toptable_V.D24T_k1, "data/new/DEGs/Toptable_V.D24T_k1.csv")

Toptable_V.D24R_k1 <- topTable(fit = fit_RUV, coef = "V.D24R", number = nrow(x), adjust.method = "BH", p.value = 1, sort.by = "none")
#write.csv(Toptable_V.D24R_k1, "data/new/DEGs/Toptable_V.D24R_k1.csv")

Toptable_V.D144R_k1 <- topTable(fit = fit_RUV, coef = "V.D144R", number = nrow(x), adjust.method = "BH", p.value = 1, sort.by = "none")
#write.csv(Toptable_V.D144R_k1, "data/new/DEGs/Toptable_V.D144R_k1.csv")

# save all of these toptables as R objects
# saveRDS(list(
#   V.D24T_k1 = Toptable_V.D24T_k1,
#   V.D24R_k1 = Toptable_V.D24R_k1,
#   V.D144R_k1 = Toptable_V.D144R_k1
# ), file = "data/new/Toptable_list_RUVk1.RDS")

Toptable_list_RUVk1 <- readRDS("data/new/Toptable_list_RUVk1.RDS")

#################################################################
#this section is commented out since it only needs to run once
#kept the code for posterity

# #I want to add the hgnc symbols to my toptables as well
# ####D24T####
# #load in data
# sample_toptab_24T <- read_csv("data/new/DEGs/Toptable_V.D24T_k1.csv", show_col_types = FALSE)
# # ----------------- Ensure Entrez_ID is Present and in Character Format -----------------
# # Check column names
# print(colnames(sample_toptab_24T))
# # Rename if needed (adjust if the column name is not exactly 'Entrez_ID')
# colnames(sample_toptab_24T)[1] <- "Entrez_ID"
# # Convert Entrez_ID to character
# sample_toptab_24T <- sample_toptab_24T %>%
#   mutate(Entrez_ID = as.character(Entrez_ID))
# # ----------------- Map Entrez_ID to Gene Symbol -----------------
# gene_symbols1 <- AnnotationDbi::select(
#   org.Hs.eg.db,
#   keys = sample_toptab_24T$Entrez_ID,
#   columns = c("SYMBOL"),
#   keytype = "ENTREZID"
# )
# # ----------------- Join Back to Main Data -----------------
# Toptable_RUV_24T <- left_join(sample_toptab_24T, gene_symbols1, by = c("Entrez_ID" = "ENTREZID"))
# Toptable_RUV_24T %>% column_to_rownames(., var = "Entrez_ID")
# # ----------------- Save Annotated Output -----------------
# #write_csv(Toptable_RUV_24T, "data/new/DEGs/Toptable_RUV_24T.csv")
# 
# #now do this again for my other two toptables
# 
# ####24R####
# #load in data
# sample_toptab_24R <- read_csv("data/new/DEGs/Toptable_V.D24R_k1.csv", show_col_types = FALSE)
# # ----------------- Ensure Entrez_ID is Present and in Character Format -----------------
# # Check column names
# print(colnames(sample_toptab_24R))
# # Rename if needed (adjust if the column name is not exactly 'Entrez_ID')
# colnames(sample_toptab_24R)[1] <- "Entrez_ID"
# # Convert Entrez_ID to character
# sample_toptab_24R <- sample_toptab_24R %>%
#   mutate(Entrez_ID = as.character(Entrez_ID))
# # ----------------- Map Entrez_ID to Gene Symbol -----------------
# gene_symbols2 <- AnnotationDbi::select(
#   org.Hs.eg.db,
#   keys = sample_toptab_24R$Entrez_ID,
#   columns = c("SYMBOL"),
#   keytype = "ENTREZID"
# )
# # ----------------- Join Back to Main Data -----------------
# Toptable_RUV_24R <- left_join(sample_toptab_24R, gene_symbols2, by = c("Entrez_ID" = "ENTREZID"))
# Toptable_RUV_24R %>% column_to_rownames(., var = "Entrez_ID")
# # ----------------- Save Annotated Output -----------------
# #I'll make these symbols into rownames later for my volcano plots
# #write_csv(Toptable_RUV_24R, "data/new/DEGs/Toptable_RUV_24R.csv")
# 
# 
# ####D144R####
# #load in data
# sample_toptab_144R <- read_csv("data/new/DEGs/Toptable_V.D144R_k1.csv", show_col_types = FALSE)
# # ----------------- Ensure Entrez_ID is Present and in Character Format -----------------
# # Check column names
# print(colnames(sample_toptab_144R))
# # Rename if needed (adjust if the column name is not exactly 'Entrez_ID')
# colnames(sample_toptab_144R)[1] <- "Entrez_ID"
# # Convert Entrez_ID to character
# sample_toptab_144R <- sample_toptab_144R %>%
#   mutate(Entrez_ID = as.character(Entrez_ID))
# # ----------------- Map Entrez_ID to Gene Symbol -----------------
# gene_symbols3 <- AnnotationDbi::select(
#   org.Hs.eg.db,
#   keys = sample_toptab_144R$Entrez_ID,
#   columns = c("SYMBOL"),
#   keytype = "ENTREZID"
# )
# # ----------------- Join Back to Main Data -----------------
# Toptable_RUV_144R <- left_join(sample_toptab_144R, gene_symbols3, by = c("Entrez_ID" = "ENTREZID"))
# Toptable_RUV_144R %>% column_to_rownames(., var = "Entrez_ID")
# # ----------------- Save Annotated Output -----------------
# #I'll make these symbols into rownames later for my volcano plots
# #write_csv(Toptable_RUV_144R, "data/new/DEGs/Toptable_RUV_144R.csv")

# write.csv(Toptable_RUV_24T, "data/new/DEGs/Toptable_RUV_24T_final.csv")
# write.csv(Toptable_RUV_24R, "data/new/DEGs/Toptable_RUV_24R_final.csv")
# write.csv(Toptable_RUV_144R, "data/new/DEGs/Toptable_RUV_144R_final.csv")

Toptable_RUV_24T <- read.csv("data/new/DEGs/Toptable_RUV_24T_final.csv")
Toptable_RUV_24R <- read.csv("data/new/DEGs/Toptable_RUV_24R_final.csv")
Toptable_RUV_144R <- read.csv("data/new/DEGs/Toptable_RUV_144R_final.csv")



# save all of these toptables as R objects
# saveRDS(list(
#   V.D24T_RUV = Toptable_RUV_24T,
#   V.D24R_RUV = Toptable_RUV_24R,
#   V.D144R_RUV = Toptable_RUV_144R
# ), file = "data/new/Toptable_list_RUVk1_Symbols.RDS")

Toptable_list_RUVk1_symbols <- readRDS("data/new/Toptable_list_RUVk1_Symbols.RDS")

```

##Volcano Plots of Original DEGs
```{r Volcano Plots of DEGs Original}
#make a function to generate volcano plots + add gene numbers
generate_volcano_plot <- function(toptable, title) {
  
  #make significance labels
  toptable$Significance <- "Not Significant"
  toptable$Significance[toptable$logFC > 0 & toptable$adj.P.Val < 0.05] <- "Upregulated"
  toptable$Significance[toptable$logFC < 0 & toptable$adj.P.Val < 0.05] <- "Downregulated"
  
  #add number of genes for each significance label
  upgenes <- toptable %>% filter(Significance == "Upregulated") %>% nrow()
  nsgenes <- toptable %>% filter(Significance == "Not Significant") %>% nrow()
  downgenes <- toptable %>% filter(Significance == "Downregulated") %>% nrow()

  #make legend labels for no of genes
  legend_lab <- c(
    str_c("Upregulated: ", upgenes),
    str_c("Not Significant: ", nsgenes),
    str_c("Downregulated: ", downgenes)
  )
  
  #specify the colors for the legend
  legend_col <- c(
    str_c("Upregulated: " = "blue"),
    str_c("Not Significant: " = "gray"),
    str_c("Downregulated: " = "red")
  )

  #generate volcano plot w/ legend
  ggplot(toptable, aes(x = logFC, 
                       y = -log10(P.Value), 
                       color = Significance)) +
    geom_point(alpha = 0.4, size = 2) + 
    scale_color_manual(values = c("Upregulated" = "blue",
                                  "Not Significant" = "gray",
                                  "Downregulated" = "red"), 
                       labels = legend_lab) +
    xlim(-10, 10) +
    labs(title = title, 
         x = expression(x = "log"[2]*"FC"), 
         y = expression(y = "-log"[10]*"P-value")) +
    theme_bw()+
    guides(color = guide_legend(override.aes = list(color = legend_col)))+
    theme(legend.position = "right", 
          plot.title = element_text(size = rel(1.5), hjust = 0.5),
          axis.title = element_text(size = rel(1.25)))
}

#generate volcano plots across each comparison
volcano_plots <- list(
  "V.D24T" = generate_volcano_plot(Toptable_V.D24T, "Volcano Plot DOX 24hr (adj P-val<0.05)"),
  "V.D24R" = generate_volcano_plot(Toptable_V.D24R, "Volcano Plot DOX 24hr Recovery (adj P-val<0.05)"),
  "V.D144R" = generate_volcano_plot(Toptable_V.D144R, "Volcano Plot DOX 144hr Recovery (adj P-val<0.05)")
)

# Display each volcano plot
for (plot_name in names(volcano_plots)) {
  print(volcano_plots[[plot_name]])
}


```
##Top 5 DEGs after RUVs k=1 Correction
```{r RUV Top5 DEGs}
#use your three toptables so I can pull out top 5 genes from each based on adj. p val

top5_D24T_1 <- Toptable_RUV_24T[order(Toptable_RUV_24T$adj.P.Val), ][1:5,] 
top5_D24R_1 <- Toptable_RUV_24R[order(Toptable_RUV_24R$adj.P.Val), ][1:5,] 
top5_D144R_1 <- Toptable_RUV_144R[order(Toptable_RUV_144R$adj.P.Val), ][1:5,]

#now that I've pulled the top 5 DEGs from each, make a list to pull them from my log2cpm data

boxplot1 <- read.csv("data/new/filcpm_final_matrix.csv") %>% 
  as.data.frame()

#Define gene list
#these are the top 5 genes pulled from my toptables
top5_D24T_geneslist_1 <- c(top5_D24T_1$Entrez_ID)
top5_D24R_geneslist_1 <- c(top5_D24R_1$Entrez_ID)
top5_D144R_geneslist_1 <- c(top5_D144R_1$Entrez_ID)
#Add more gene symbols as needed or add more categories

#now pull these from my log2cpm matrix
top5_D24T_genes_1 <- boxplot1[boxplot1$Entrez_ID %in% top5_D24T_geneslist_1,]
dim(top5_D24T_genes_1)
#5 genes in 44 cols
top5_D24R_genes_1 <- boxplot1[boxplot1$Entrez_ID %in% top5_D24R_geneslist_1,]
dim(top5_D24R_genes_1)
#5 genes in 44 cols
top5_D144R_genes_1 <- boxplot1[boxplot1$Entrez_ID %in% top5_D144R_geneslist_1,]
dim(top5_D144R_genes_1)
#5 genes in 44 cols

#Now put in the function I want to use to generate boxplots of genes
#####D24T#####
process_top5_D24T_1 <- function(gene) {
  gene_data <- top5_D24T_genes_1 %>% filter(Entrez_ID == gene)
  long_data <- gene_data %>%
    pivot_longer(cols = -c(Entrez_ID, SYMBOL), names_to = "Sample", values_to = "log2cpm") %>%
    mutate(
      Drug = case_when(
        grepl("DOX", Sample) ~ "DOX",
        grepl("DMSO", Sample) ~ "DMSO",
        TRUE ~ NA_character_
      ),
      Timepoint = case_when(
        grepl("_24T_", Sample) ~ "24T",
        grepl("_24R_", Sample) ~ "24R",
        grepl("_144R_", Sample) ~ "144R",
        TRUE ~ NA_character_
      ),
      Indv = case_when(
        grepl("Ind1$", Sample) ~ "1",
        grepl("Ind2$", Sample) ~ "2",
        grepl("Ind3$", Sample) ~ "3",
        grepl("Ind4$", Sample) ~ "4",
        grepl("Ind5$", Sample) ~ "5",
        grepl("Ind6$", Sample) ~ "6",
        grepl("Ind6R$", Sample) ~ "6R",
        TRUE ~ NA_character_
      ),
      Condition = paste(Drug, Timepoint, sep = "_")
    )
  long_data$Condition <- factor(
    long_data$Condition,
    levels = c(
      "DOX_24T", 
      "DMSO_24T", 
      "DOX_24R", 
      "DMSO_24R", 
      "DOX_144R", 
      "DMSO_144R"
    )
  )
  return(long_data)
}


#Generate Boxplots from the above function using our gene list above
for (gene in top5_D24T_geneslist_1) {
  gene_data <- process_top5_D24T_1(gene)
  p <- ggplot(gene_data, aes(x = Condition, y = log2cpm, fill = Drug)) +
    geom_boxplot(outlier.shape = NA) +
    geom_point(aes(color = Indv), size = 2, alpha = 0.5, position = position_jitter(width = -1, height = 0)) +
    scale_fill_manual(values = c("DOX" = "#499FBD", "DMSO" = "#BBBBBC")) +
    ggtitle(paste("Log2cpm", gene, "top5DEGs D24T RUVs")) +
    labs(x = "Treatment", y = "log2cpm") +
    theme_bw() +
    theme(
      plot.title = element_text(size = rel(2), hjust = 0.5),
      axis.title = element_text(size = 15, color = "black"),
      axis.text.x = element_text(size = 10, color = "black", angle = 90, hjust = 1)
    )
  print(p)
}

#####D24R#####
process_top5_D24R_1 <- function(gene) {
  gene_data <- top5_D24R_genes_1 %>% filter(Entrez_ID == gene)
  long_data <- gene_data %>%
    pivot_longer(cols = -c(Entrez_ID, SYMBOL), names_to = "Sample", values_to = "log2cpm") %>%
    mutate(
      Drug = case_when(
        grepl("DOX", Sample) ~ "DOX",
        grepl("DMSO", Sample) ~ "DMSO",
        TRUE ~ NA_character_
      ),
      Timepoint = case_when(
        grepl("_24T_", Sample) ~ "24T",
        grepl("_24R_", Sample) ~ "24R",
        grepl("_144R_", Sample) ~ "144R",
        TRUE ~ NA_character_
      ),
      Indv = case_when(
        grepl("Ind1$", Sample) ~ "1",
        grepl("Ind2$", Sample) ~ "2",
        grepl("Ind3$", Sample) ~ "3",
        grepl("Ind4$", Sample) ~ "4",
        grepl("Ind5$", Sample) ~ "5",
        grepl("Ind6$", Sample) ~ "6",
        grepl("Ind6R$", Sample) ~ "6R",
        TRUE ~ NA_character_
      ),
      Condition = paste(Drug, Timepoint, sep = "_")
    )
  long_data$Condition <- factor(
    long_data$Condition,
    levels = c(
      "DOX_24T", 
      "DMSO_24T", 
      "DOX_24R", 
      "DMSO_24R", 
      "DOX_144R", 
      "DMSO_144R"
    )
  )
  return(long_data)
}


#Generate Boxplots from the above function using our gene list above
for (gene in top5_D24R_geneslist_1) {
  gene_data <- process_top5_D24R_1(gene)
  p <- ggplot(gene_data, aes(x = Condition, y = log2cpm, fill = Drug)) +
    geom_boxplot(outlier.shape = NA) +
    geom_point(aes(color = Indv), size = 2, alpha = 0.5, position = position_jitter(width = -1, height = 0)) +
    scale_fill_manual(values = c("DOX" = "#499FBD", "DMSO" = "#BBBBBC")) +
    ggtitle(paste("Log2cpm", gene, "top5DEGs D24R RUVs")) +
    labs(x = "Treatment", y = "log2cpm") +
    theme_bw() +
    theme(
      plot.title = element_text(size = rel(2), hjust = 0.5),
      axis.title = element_text(size = 15, color = "black"),
      axis.text.x = element_text(size = 10, color = "black", angle = 90, hjust = 1)
    )
  print(p)
}

#####D144R#####
process_top5_D144R_1 <- function(gene) {
  gene_data <- top5_D144R_genes_1 %>% filter(Entrez_ID == gene)
  long_data <- gene_data %>%
    pivot_longer(cols = -c(Entrez_ID, SYMBOL), names_to = "Sample", values_to = "log2cpm") %>%
    mutate(
      Drug = case_when(
        grepl("DOX", Sample) ~ "DOX",
        grepl("DMSO", Sample) ~ "DMSO",
        TRUE ~ NA_character_
      ),
      Timepoint = case_when(
        grepl("_24T_", Sample) ~ "24T",
        grepl("_24R_", Sample) ~ "24R",
        grepl("_144R_", Sample) ~ "144R",
        TRUE ~ NA_character_
      ),
      Indv = case_when(
        grepl("Ind1$", Sample) ~ "1",
        grepl("Ind2$", Sample) ~ "2",
        grepl("Ind3$", Sample) ~ "3",
        grepl("Ind4$", Sample) ~ "4",
        grepl("Ind5$", Sample) ~ "5",
        grepl("Ind6$", Sample) ~ "6",
        grepl("Ind6R$", Sample) ~ "6R",
        TRUE ~ NA_character_
      ),
      Condition = paste(Drug, Timepoint, sep = "_")
    )
  long_data$Condition <- factor(
    long_data$Condition,
    levels = c(
      "DOX_24T", 
      "DMSO_24T", 
      "DOX_24R", 
      "DMSO_24R", 
      "DOX_144R", 
      "DMSO_144R"
    )
  )
  return(long_data)
}


#Generate Boxplots from the above function using our gene list above
for (gene in top5_D144R_geneslist_1) {
  gene_data <- process_top5_D144R_1(gene)
  p <- ggplot(gene_data, aes(x = Condition, y = log2cpm, fill = Drug)) +
    geom_boxplot(outlier.shape = NA) +
    geom_point(aes(color = Indv), size = 2, alpha = 0.5, position = position_jitter(width = -1, height = 0)) +
    scale_fill_manual(values = c("DOX" = "#499FBD", "DMSO" = "#BBBBBC")) +
    ggtitle(paste("Log2cpm", gene, "top5DEGs D144R RUVs")) +
    labs(x = "Treatment", y = "log2cpm") +
    theme_bw() +
    theme(
      plot.title = element_text(size = rel(2), hjust = 0.5),
      axis.title = element_text(size = 15, color = "black"),
      axis.text.x = element_text(size = 10, color = "black", angle = 90, hjust = 1)
    )
  print(p)
}


```
```{r Top DEGs all timepoints list}
#find the top 10 DEGs for the entire dataset with my combined toptables
#Combine the toptables I have from pairwise analysis into a single dataframe
d24_toptable_dxr_RUV <- Toptable_RUV_24T %>% 
  rownames_to_column(var = "Entrez_ID") %>% 
  mutate(Time = "24")

d24r_toptable_dxr_RUV <- Toptable_RUV_24R %>% 
  rownames_to_column(var = "Entrez_ID") %>% 
  mutate(Time = "24R")

d144r_toptable_dxr_RUV <- Toptable_RUV_144R %>% 
  rownames_to_column(var = "Entrez_ID") %>% 
  mutate(Time = "144R")

combined_toptables_dxr_RUV <- bind_rows(
  d24_toptable_dxr_RUV,
  d24r_toptable_dxr_RUV,
  d144r_toptable_dxr_RUV)

combined_toptables_dxr_RUV
  
top10_DEGs_RUV <- combined_toptables_dxr_RUV[order(combined_toptables_dxr_RUV$adj.P.Val), ][1:10,]

print(top10_DEGs_RUV$SYMBOL)
print(top10_DEGs_RUV$Entrez_ID)

```


##LogFC DEGs RUVs k=1 All Conditions
```{r RUV logFC DEGs all Conditions}
# Toptable_RUV_24T
# Toptable_RUV_24R
# Toptable_RUV_144R

# Load DEGs Data
DOX_24T_1 <- read.csv("data/new/DEGs/Toptable_RUV_24T_final.csv")
DOX_24R_1 <- read.csv("data/new/DEGs/Toptable_RUV_24R_final.csv")
DOX_144R_1 <- read.csv("data/new/DEGs/Toptable_RUV_144R_final.csv")

#make a list of all of the genes in this set so I can plot the logFC in other sets
D24T_DEGs_1 <- DOX_24T_1$Entrez_ID[DOX_24T_1$adj.P.Val < 0.05]
length(D24T_DEGs_1)
#9243 genes

D24R_DEGs_1 <- DOX_24R_1$Entrez_ID[DOX_24R_1$adj.P.Val < 0.05]
length(D24R_DEGs_1)
#7168 genes

D144R_DEGs_1 <- DOX_144R_1$Entrez_ID[DOX_144R_1$adj.P.Val < 0.05]
length(D144R_DEGs_1)
#509 genes

#plot those full gene sets in logFC
D24T_DEGs_1 <- DOX_24T$Entrez_ID[DOX_24T$adj.P.Val < 0.05]
length(D24T_DEGs)

D24R_DEGs_1 <- DOX_24R$Entrez_ID[DOX_24R$adj.P.Val < 0.05]
length(D24R_DEGs)

D144R_DEGs_1 <- DOX_144R$Entrez_ID[DOX_144R$adj.P.Val < 0.05]
length(D144R_DEGs)
#now that I have the full list of genes, I want to plot the logFC across conditions


#Combine the toptables I have from pairwise analysis into a single dataframe
d24_toptable_dxr_1 <- Toptable_RUV_24T %>% 
  mutate(Time = "24")

d24r_toptable_dxr_1 <- Toptable_RUV_24R %>% 
  mutate(Time = "24R")

d144r_toptable_dxr_1 <- Toptable_RUV_144R %>% 
  mutate(Time = "144R")

combined_toptables_dxr_RUV <- bind_rows(
  d24_toptable_dxr_1,
  d24r_toptable_dxr_1,
  d144r_toptable_dxr_1)

#Filter the data based on each motif
filt_toptable_dxr_RUV <- combined_toptables_dxr_RUV %>% 
  dplyr::filter(Entrez_ID  %in% D24T_DEGs_1) %>% 
  mutate(absFC = abs(logFC)) %>% 
  mutate(time = factor(Time, levels = c("24", "24R", "144R"), labels = c("24hr", "24hr Recovery", "144hr Recovery"))) %>% 
  ggplot(., aes(x = time, y = logFC))+
  geom_boxplot(aes(fill = time))+
  scale_fill_manual(values = time_col)+
  guides(fill = guide_legend(title = "Time"))+
  theme_bw()+
  xlab(" ")+
  ylab("logFC")+
  theme_bw()+
  ggtitle("LogFC D24T DEGs Across Conditions RUVs")+
  theme(plot.title = element_text(size = rel(1.5), hjust = 0.5),
        axis.title = element_text(size = 15, colour = "black"),
        strip.background = element_rect(fill = "#CAD899"),
        axis.text.x = element_text(size = 8, colour = "white", angle = 15),
        strip.text.x = element_text(size = 12, colour = "black", face = "bold"))

#now do the same with the other conditions

filt_toptable_dxr_24r_RUV <- combined_toptables_dxr_RUV %>% 
  dplyr::filter(Entrez_ID  %in% D24R_DEGs_1) %>% 
  mutate(absFC = abs(logFC)) %>% 
  mutate(time = factor(Time, levels = c("24", "24R", "144R"), labels = c("24hr", "24hr Recovery", "144hr Recovery"))) %>% 
  ggplot(., aes(x = time, y = logFC))+
  geom_boxplot(aes(fill = time))+
  scale_fill_manual(values = time_col)+
  guides(fill = guide_legend(title = "Time"))+
  theme_bw()+
  xlab(" ")+
  ylab("logFC")+
  theme_bw()+
  ggtitle("LogFC D24R DEGs Across Conditions RUVs")+
  theme(plot.title = element_text(size = rel(1.5), hjust = 0.5),
        axis.title = element_text(size = 15, colour = "black"),
        strip.background = element_rect(fill = "#CAD899"),
        axis.text.x = element_text(size = 8, colour = "white", angle = 15),
        strip.text.x = element_text(size = 12, colour = "black", face = "bold"))

#D144R

filt_toptable_dxr_144r_RUV <- combined_toptables_dxr_RUV %>% 
  dplyr::filter(Entrez_ID  %in% D144R_DEGs_1) %>% 
  mutate(absFC = abs(logFC)) %>% 
  mutate(time = factor(Time, levels = c("24", "24R", "144R"), labels = c("24hr", "24hr Recovery", "144hr Recovery"))) %>% 
  ggplot(., aes(x = time, y = logFC))+
  geom_boxplot(aes(fill = time))+
  scale_fill_manual(values = time_col)+
  guides(fill = guide_legend(title = "Time"))+
  theme_bw()+
  xlab(" ")+
  ylab("logFC")+
  theme_bw()+
  ggtitle("LogFC D144R DEGs Across Conditions RUVs")+
  theme(plot.title = element_text(size = rel(1.5), hjust = 0.5),
        axis.title = element_text(size = 15, colour = "black"),
        strip.background = element_rect(fill = "#CAD899"),
        axis.text.x = element_text(size = 8, colour = "white", angle = 15),
        strip.text.x = element_text(size = 12, colour = "black", face = "bold"))

#now put the names of these graphs to print them
filt_toptable_dxr_RUV
filt_toptable_dxr_24r_RUV
filt_toptable_dxr_144r_RUV


```

##LogFC Heatmap Across Timepoints RUVs
```{r LogFC HM RUVs Timepoint Comparisons}
#format my data so that I have a matrix of my logFC values and genes

logFC_wide_RUV <- combined_toptables_dxr_RUV %>%
  select(Entrez_ID, Time, logFC) %>%
  pivot_wider(names_from = Time, values_from = logFC) %>%
  drop_na() %>% 
  column_to_rownames("Entrez_ID")

#now that I've pivoted my logFC data into a wide format I can compute the Spearman correlation between the timepoints

#convert to matrix + remove gene column
logFC_matrix_RUV <- as.matrix(logFC_wide_RUV)

# Compute Spearman correlation between columns (timepoints)
logFC_cor_RUV <- cor(logFC_matrix_RUV, 
                     y = NULL,
                     use = "everything",
                     method = "spearman")

# Define color palettes for annotations
annot_col_cor = list(timepoints = c("24T" = "#238B45",
                                    "24R" = "#74C476",
                                    "144R" = "#C7E9C0"))

time_colors <- c("24T" = "#238B45",
                 "24R" = "#74C476",
                 "144R" = "#C7E9C0")

timepoints <- c("24T", "24R", "144R")

# Create annotations
top_annotation_RUV_time <- HeatmapAnnotation(
  Timepoint = timepoints,
  col = list(Timepoint = time_colors),
  annotation_name_side = "left"
)

# Draw heatmap
Heatmap(logFC_cor_RUV,
        name = "Spearman",
        col = colorRamp2(c(0, 0.5, 1), c("blue", "white", "red")),
        top_annotation = top_annotation_RUV_time,
        cluster_rows = FALSE,
        cluster_columns = FALSE,
        cell_fun = function(j, i, x, y, width, height, fill) {
          grid.text(sprintf("%.2f", logFC_cor_RUV[i, j]), x, y, 
                    gp = gpar(fontsize = 10))
        },
        column_title = "Spearman Correlation of logFC")

####Spearman Heatmap####
heatmap_spearman_RUV_time <- Heatmap(logFC_cor_RUV,
                           name = "Spearman",
                           top_annotation = top_annotation_RUV_time,
                           show_row_names = TRUE,
                           show_column_names = TRUE,
                           cluster_rows = TRUE,
                           cluster_columns = FALSE,
                           border = TRUE)

# Draw the heatmap
draw(heatmap_spearman_RUV_time)


```


##Volcano Plots of RUVs Corrected Data k=1
```{r Volcano Plots RUVs Corrected k1}
#make a function to generate volcano plots + add gene numbers
#ensure the gene symbols are in a col so I can plot names of top 15
generate_volcano_plot_RUV <- function(toptable, title) {
  
  #make significance labels
  toptable$Significance <- "Not Significant"
  toptable$Significance[toptable$logFC > 0 & toptable$adj.P.Val < 0.05] <- "Upregulated"
  toptable$Significance[toptable$logFC < 0 & toptable$adj.P.Val < 0.05] <- "Downregulated"
  
  #add number of genes for each significance label
  upgenes <- toptable %>% filter(Significance == "Upregulated") %>% nrow()
  nsgenes <- toptable %>% filter(Significance == "Not Significant") %>% nrow()
  downgenes <- toptable %>% filter(Significance == "Downregulated") %>% nrow()

  #make legend labels for no of genes
  legend_lab <- c(
    str_c("Upregulated: ", upgenes),
    str_c("Not Significant: ", nsgenes),
    str_c("Downregulated: ", downgenes)
  )
  
  #specify the colors for the legend
  legend_col <- c(
    str_c("Upregulated: " = "blue"),
    str_c("Not Significant: " = "gray"),
    str_c("Downregulated: " = "red")
  )
  
  #add the top 15 genes by adj. p value
  top_genes <- toptable %>%
    filter(!is.na(SYMBOL)) %>%
    arrange(adj.P.Val) %>%
    slice_head(n = 15)
  
  #generate volcano plot w/ legend
  ggplot(toptable, aes(x = logFC, 
                       y = -log10(P.Value), 
                       color = Significance)) +
    geom_point(alpha = 0.4, size = 2) + 
    scale_color_manual(values = c("Upregulated" = "blue",
                                  "Not Significant" = "gray",
                                  "Downregulated" = "red"), 
                       labels = legend_lab) +
    xlim(-10, 10) +
    labs(title = title, 
         x = expression(x = "log"[2]*"FC"), 
         y = expression(y = "-log"[10]*"P-value")) +
    theme_bw()+
    guides(color = guide_legend(override.aes = list(color = legend_col)))+
    theme(legend.position = "right", 
          plot.title = element_text(size = rel(1.5), hjust = 0.5),
          axis.title = element_text(size = rel(1.25)))
}

#generate volcano plots across each comparison
volcano_plots_RUV <- list(
  "V.D24T_RUV" = generate_volcano_plot(Toptable_RUV_24T, "DOX 24T RUVs k=1 (adj P-val<0.05)"),
  "V.D24R_RUV" = generate_volcano_plot(Toptable_RUV_24R, "DOX 24R RUVs k=1 (adj P-val<0.05)"),
  "V.D144R_RUV" = generate_volcano_plot(Toptable_RUV_144R, "DOX 144R RUVs k=1 (adj P-val<0.05)")
)

# Display each volcano plot
for (plot_name in names(volcano_plots_RUV)) {
  print(volcano_plots_RUV[[plot_name]])
}


```

##Plot DNA Damage Response Genes (DDR) with Original Data
```{r DDR Genes logFC, fig.height=14, fig.width=8}
#DDR Gene Expression Heatmap — DOX Over Recovery Time (68 genes, with categories)

# Load libraries
# library(circlize)
# library(grid)
# library(reshape2)

# Load DEG files
load_deg <- function(path) read.csv(path)

DOX_24T <- load_deg("data/new/DEGs/Toptable_V.D24T.csv")
DOX_24R <- load_deg("data/new/DEGs/Toptable_V.D24R.csv")
DOX_144R <- load_deg("data/new/DEGs/Toptable_V.D144R.csv")

# Final Entrez IDs and categories (68 genes)
entrez_category_DDR <- tribble(
  ~ENTREZID, ~Category,
  317, "Apoptosis", 355, "Apoptosis", 581, "Apoptosis", 637, "Apoptosis",
  836, "Apoptosis", 841, "Apoptosis", 842, "Apoptosis", 27113, "Apoptosis",
  5366, "Apoptosis", 54205, "Apoptosis", 55367, "Apoptosis", 8795, "Apoptosis",
  1026, "Cell Cycle / Checkpoint", 1027, "Cell Cycle / Checkpoint", 595, "Cell Cycle / Checkpoint",
  894, "Cell Cycle / Checkpoint", 896, "Cell Cycle / Checkpoint", 898, "Cell Cycle / Checkpoint",
  9133, "Cell Cycle / Checkpoint", 9134, "Cell Cycle / Checkpoint", 891, "Cell Cycle / Checkpoint",
  983, "Cell Cycle / Checkpoint", 1017, "Cell Cycle / Checkpoint", 1019, "Cell Cycle / Checkpoint",
  1020, "Cell Cycle / Checkpoint", 1021, "Cell Cycle / Checkpoint", 993, "Cell Cycle / Checkpoint",
  995, "Cell Cycle / Checkpoint", 1869, "Cell Cycle / Checkpoint", 4609, "Cell Cycle / Checkpoint",
  5925, "Cell Cycle / Checkpoint", 9874, "Cell Cycle / Checkpoint", 11011, "Cell Cycle / Checkpoint",
  1385, "Cell Cycle / Checkpoint",
  472, "Damage Sensors / Signal Transducers", 545, "Damage Sensors / Signal Transducers",
  5591, "Damage Sensors / Signal Transducers", 5810, "Damage Sensors / Signal Transducers",
  5883, "Damage Sensors / Signal Transducers", 5884, "Damage Sensors / Signal Transducers",
  6118, "Damage Sensors / Signal Transducers", 4361, "Damage Sensors / Signal Transducers",
  10111, "Damage Sensors / Signal Transducers", 4683, "Damage Sensors / Signal Transducers",
  84126, "Damage Sensors / Signal Transducers", 3014, "Damage Sensors / Signal Transducers",
  672, "DNA Repair", 2177, "DNA Repair", 5888, "DNA Repair", 5893, "DNA Repair",
  1647, "DNA Repair", 4616, "DNA Repair", 10912, "DNA Repair", 1111, "DNA Repair",
  11200, "DNA Repair", 1643, "DNA Repair", 8243, "DNA Repair", 5981, "DNA Repair",
  7157, "p53 Regulators / Targets", 4193, "p53 Regulators / Targets", 5371, "p53 Regulators / Targets",
  27244, "p53 Regulators / Targets", 50484, "p53 Regulators / Targets",
  207, "Miscellaneous / Broad", 25, "Miscellaneous / Broad"
)

entrez_ids_DDR <- entrez_category_DDR$ENTREZID

# Extract relevant DEG values
extract_data_DDR <- function(df, name) {
  df %>%
    filter(Entrez_ID %in% entrez_ids_DDR) %>%
    mutate(
      Gene = mapIds(org.Hs.eg.db, as.character(Entrez_ID),
                    column = "SYMBOL", keytype = "ENTREZID", multiVals = "first"),
      Condition = name,
      Signif = ifelse(adj.P.Val < 0.05, "*", "")
    )
}

# DEG list
deg_list <- list("DOX_24T" = DOX_24T, 
                 "DOX_24R" = DOX_24R, 
                 "DOX_144R" = DOX_144R
)

# Combine all DEGs and annotate
all_data_DDR <- bind_rows(mapply(extract_data_DDR, deg_list, names(deg_list), SIMPLIFY = FALSE)) %>%
  left_join(entrez_category_DDR, by = c("Entrez_ID" = "ENTREZID"))

# Create matrices
logFC_matddr <- acast(all_data_DDR, Gene ~ Condition, value.var = "logFC")
signif_matddr <- acast(all_data_DDR, Gene ~ Condition, value.var = "Signif")

# Set desired order
desired_order <- c("DOX_24T",
                   "DOX_24R",
                   "DOX_144R")

logFC_mat_DDR <- logFC_matddr[, desired_order, drop = FALSE]
signif_mat_DDR <- signif_matddr[, desired_order, drop = FALSE]

# Column annotation
meta_DDR <- str_split_fixed(colnames(logFC_mat_DDR), "_", 2)
col_annot <- HeatmapAnnotation(
  Drug = meta_DDR[, 1],
  Time = meta_DDR[, 2],
  col = list(
    Drug = c("DOX" = "#499FBD"),
    Time = c("24T" = "#238B45", 
             "24R" = "#74C476", 
             "144R" = "#C7E9C0")
  ),
  annotation_height = unit(c(1, 1, 1), "cm")
)

# Row annotation
gene_order_df_DDR <- all_data_DDR %>%
  distinct(Gene, Category) %>%
  arrange(factor(Category, levels = sort(unique(entrez_category_DDR$Category))), Gene)

ordered_genes_DDR <- gene_order_df_DDR$Gene
logFC_mat_DDR <- logFC_mat_DDR[ordered_genes_DDR, ]
signif_mat_DDR <- signif_mat_DDR[ordered_genes_DDR, ]

category_levels <- sort(unique(entrez_category_DDR$Category))

category_colors_DDR <- setNames(
  c("darkorange", "steelblue", "darkgreen", "firebrick", "gold", "mediumpurple"),
  category_levels
  )


ha_left_DDR <- rowAnnotation(
  Category = gene_order_df_DDR$Category,
  col = list(Category = category_colors_DDR),
  annotation_name_side = "top"
)

# Final Heatmap
Heatmap(logFC_mat_DDR,
        name = "logFC",
        top_annotation = col_annot,
        left_annotation = ha_left_DDR,
        cluster_columns = FALSE,
        cluster_rows = FALSE,
        show_row_names = TRUE,
        show_column_names = FALSE,
        row_names_gp = gpar(fontsize = 10),
        column_title = "DDR Gene Expression Response (n = 68)\n DOX Recovery",
        column_title_gp = gpar(fontsize = 14, fontface = "bold"),
        cell_fun = function(j, i, x, y, width, height, fill) {
          grid.text(signif_mat_DDR[i, j], x, y, gp = gpar(fontsize = 9))
        }
)
```

##Plot DOX Cardiotox Genes logFC HM Original Data
```{r DIC Genes logFC HM noRUVs}
#plot a list of 29 functionally validated DIC genes
# Load DEG files
load_deg <- function(path) read.csv(path)

DOX_24T <- load_deg("data/new/DEGs/Toptable_V.D24T.csv")
DOX_24R <- load_deg("data/new/DEGs/Toptable_V.D24R.csv")
DOX_144R <- load_deg("data/new/DEGs/Toptable_V.D144R.csv")

#the data I have is in hgnc_symbols, I want to convert this to entrez_id like my df
DIC_genes <- tribble(
  ~SYMBOL, ~Category,
  "CAT", "ROS Generation / Handling",
  "CBR1", "ROS Generation / Handling",
  "CBR3", "ROS Generation / Handling",
  "ERBB2", "ROS Generation / Handling",
  "GPX3", "ROS Generation / Handling",
  "GSTM1", "ROS Generation / Handling",
  "GSTP", "ROS Generation / Handling",
  "HAS3", "ROS Generation / Handling",
  "NOS3", "ROS Generation / Handling",
  "PLCE1", "ROS Generation / Handling",
  "RAC2", "ROS Generation / Handling",
  "SPG7", "ROS Generation / Handling",
  "PRDM2", "DNA Damage", 
  "MLH1", "DNA Damage",
  "RARG", "DNA Damage",
  "HFE", "Iron Uptake & Homeostasis",
  "SLC22A17", "DOX Uptake",
  "SLC28A1", "DOX Uptake",
  "SLC28A3", "DOX Uptake",
  "ABCB4", "DOX Efflux",
  "ABCC2", "DOX Efflux",
  "ABCC5", "DOX Efflux", 
  "ABCC9", "DOX Efflux",
  "ABCC10", "DOX Efflux",
  "CELF4", "Calcium Handling",
  "MYH7", "Calcium Handling",
  "CYP2J2", "Cardiac Electrical Activity",
  "RIN3", "Cardiac Electrical Activity",
  "ZFN521", "Cardiac Electrical Activity")

gene_df_DIC <- tibble(HGNC = DIC_genes)


gene_df_DIC <- gene_df_DIC %>% 
  mutate(Entrez_ID = mapIds(org.Hs.eg.db,
                            keys = DIC_genes$SYMBOL,
                            column = "ENTREZID", 
                            keytype = "SYMBOL", 
                            multiVals = "first")) %>% 
  unnest_wider(HGNC) %>% 
  mutate(Entrez_ID = as.character(Entrez_ID))

#now I've put together a dataframe with the HGNC, Category, and Entrez_ID
#plus I've ensured that Entrez_ID is a character for later joining

entrez_ids_DIC <- gene_df_DIC$Entrez_ID

# saveRDS(entrez_ids_DIC, "data/new/RUV/DIC_genes_entrezid.RDS")

# Extract relevant DEG values
extract_data_DIC <- function(df, name) {
  df %>%
    filter(Entrez_ID %in% entrez_ids_DIC) %>%
    mutate(
      Gene = mapIds(org.Hs.eg.db, as.character(Entrez_ID),
                    column = "SYMBOL", keytype = "ENTREZID", multiVals = "first"),
      Condition = name,
      Signif = ifelse(adj.P.Val < 0.05, "*", "")
    )
}

# DEG list
deg_list <- list("DOX_24T" = DOX_24T, 
                 "DOX_24R" = DOX_24R, 
                 "DOX_144R" = DOX_144R
)

# Combine all DEGs and annotate
all_data_DIC <- bind_rows(mapply(extract_data_DIC, 
                             deg_list, 
                             names(deg_list), 
                             SIMPLIFY = FALSE)) %>%
  mutate(Entrez_ID = as.character(Entrez_ID)) %>% 
  left_join(gene_df_DIC, 
            by = "Entrez_ID")
#I've also made sure here that Entrez_ID is a character and not an integer

# Create matrices
logFC_matdic <- acast(all_data_DIC, Gene ~ Condition, value.var = "logFC")
signif_matdic <- acast(all_data_DIC, Gene ~ Condition, value.var = "Signif")

# Set desired order
desired_order <- c("DOX_24T",
                   "DOX_24R",
                   "DOX_144R")

logFC_mat_DIC <- logFC_matdic[, desired_order, drop = FALSE]
signif_mat_DIC <- signif_matdic[, desired_order, drop = FALSE]

# Column annotation
meta_DIC <- str_split_fixed(colnames(logFC_mat_DIC), "_", 3)
meta_DIC <- str_split_fixed(colnames(logFC_mat_DIC), "_", 2)
col_annot <- HeatmapAnnotation(
  Drug = meta_DIC[, 1],
  Time = meta_DIC[, 2],
  col = list(
    Drug = c("DOX" = "#499FBD"),
    Time = c("24T" = "#238B45", 
             "24R" = "#74C476", 
             "144R" = "#C7E9C0")
  ),
  annotation_height = unit(c(2, 2, 2), "cm")
)
#for this I can leave off the DMSO as it's already from a pairwise comparison

#make an extra object with my category order as well
category_order_DIC <- c(
  "ROS Generation / Handling",
  "DNA Damage",
  "Calcium Handling",
  "DOX Uptake",
  "Iron Uptake & Homeostasis",
  "DOX Efflux",
  "Cardiac Electrical Activity"
)

# Row annotation
gene_order_df_DIC <- all_data_DIC %>%
  distinct(Gene, Category) %>%
  mutate(Category = factor(Category, levels = category_order_DIC)) %>% 
  arrange(Category, Gene)

ordered_genes_DIC <- gene_order_df_DIC$Gene
logFC_mat_DIC <- logFC_mat_DIC[ordered_genes_DIC, ]
signif_mat_DIC <- signif_mat_DIC[ordered_genes_DIC, ]

#add in your colors for each category
 category_colors_DIC <- structure(
  c("darkorange", "steelblue", "darkgreen", "firebrick", "gold", "mediumpurple", "gray60"),
  names = category_order_DIC
)

ha_left_DIC <- rowAnnotation(
  Category = gene_order_df_DIC$Category,
  col = list(Category = category_colors_DIC),
  annotation_name_side = "top"
)

# Draw heatmap
Heatmap(logFC_mat_DIC,
        name = "logFC",
        top_annotation = col_annot,
        left_annotation = ha_left_DIC,
        cluster_columns = FALSE,
        cluster_rows = FALSE,
        show_row_names = TRUE,
        show_column_names = FALSE,
        cell_fun = function(j, i, x, y, width, height, fill) {
          grid.text(signif_mat_DIC[i, j], x, y, gp = gpar(fontsize = 9))
        },
        column_title = "DIC Genes Expression (n=29)\nDOX Recovery",
        column_title_gp = gpar(fontsize = 14, fontface = "bold")
)


```

##Plot p53 Target Genes logFC HM Original Data
```{r p53 Target Genes logFC HM, fig.height=12, fig.width=10}
# Load libraries
library(tidyverse)
library(ComplexHeatmap)
library(circlize)
library(grid)
library(org.Hs.eg.db)
library(reshape2)

# Load DEG files
load_deg <- function(path) read.csv(path)

DOX_24T <- load_deg("data/new/DEGs/Toptable_V.D24T.csv")
DOX_24R <- load_deg("data/new/DEGs/Toptable_V.D24R.csv")
DOX_144R <- load_deg("data/new/DEGs/Toptable_V.D144R.csv")

#P53 target Entrez_ID
entrez_ids_p53 <- c(1026,50484,4193,9766,9518,7832,1643,1647,1263,57103,51065,8795,51499,64393,581,
                5228,5429,8493,55959,7508,64782,282991,355,53836,4814,10769,9050,27244,9540,94241,
                26154,57763,900,26999,55332,26263,23479,23612,29950,9618,10346,8824,134147,55294,
                22824,4254,6560,467,27113,60492,8444,60401,1969,220965,2232,3976,55191,84284,93129,
                5564,7803,83667,7779,132671,7039,51768,137695,93134,7633,10973,340485,307,27350,
                23245,3732,29965,1363,1435,196513,8507,8061,2517,51278,53354,54858,23228,5366,5912,
                6236,51222,26152,59,1907,50650,91012,780,9249,11072,144455,64787,116151,27165,2876,
                57822,55733,57722,121457,375449,85377,4851,5875,127544,29901,84958,8797,8793,441631,
                220001,54541,5889,5054,25816,25987,5111,98,317,598,604,10904,1294,80315,53944,
                1606,2770,3628,3675,3985,4035,4163,84552,29085,55367,5371,5791,54884,5980,8794,
                1462,50808,220,583,694,1056,9076,10978,54677,1612,55040,114907,2274,127707,4000,
                8079,4646,4747,27445,5143,80055,79156,5360,5364,23654,5565,5613,5625,10076,56963,
                6004,390,255488,6326,6330,23513,7869,283130,204962,83959,6548,6774,9263,10228,
                22954,10475,85363,494514,10142,79714,1006,8446,9648,79828,5507,55240,63874,25841,
                9289,84883,154810,51321,421,8553,655,119032,84280,10950,824,839,57828,857,8812,
                8837,94027,113189,22837,132864,10898,3300,81704,1847,1849,1947,9538,24139,5168,
                147965,115548,9873,23768,2632,2817,3280,3265,23308,3490,51477,182,3856,8844,144811,
                9404,4043,9848,2872,23041,740,343263,4638,26509,4792,22861,57523,55214,80025,164091,
                57060,64065,51090,5453,8496,333926,55671,5900,55544,23179,8601,389,6223,55800,6385,
                4088,6643,122809,257397,285343,7011,54790,374618,55362,51754,7157,9537,22906,7205,
                80705,219699,55245,83719,7748,25946,118738)

# p53_genes <- saveRDS(entrez_ids_p53, "data/new/RUV/p53_genelist_entrezid.RDS")

# Function to extract relevant data
extract_data_p53 <- function(df, name) {
  df %>%
    filter(Entrez_ID %in% entrez_ids_p53) %>%
    mutate(Gene = mapIds(org.Hs.eg.db, as.character(Entrez_ID),
                         column = "SYMBOL", keytype = "ENTREZID", multiVals = "first"),
           Condition = name,
           Signif = ifelse(adj.P.Val < 0.05, "*", ""))
}

# Collect all data
# DEG list
deg_list <- list("DOX_24T" = DOX_24T, 
                 "DOX_24R" = DOX_24R, 
                 "DOX_144R" = DOX_144R
)

# Combine all DEGs and annotate
all_data_p53 <- bind_rows(mapply(extract_data_p53, deg_list, names(deg_list), SIMPLIFY = FALSE)) 
#unnecessary to join again as there are not categories on this list of entrezids
# %>%
#   left_join(entrez_ids, by = c("Entrez_ID" = "ENTREZID"))

# Create matrices
logFC_mat53 <- acast(all_data_p53, Gene ~ Condition, value.var = "logFC")
signif_mat53 <- acast(all_data_p53, Gene ~ Condition, value.var = "Signif")

# Desired column order
desired_order <- c("DOX_24T",
                   "DOX_24R",
                   "DOX_144R")

logFC_mat_p53 <- logFC_mat53[, desired_order]
signif_mat_p53 <- signif_mat53[, desired_order]

# Column annotation
meta_p53 <- str_split_fixed(colnames(logFC_mat_p53), "_", 3)
meta_p53 <- str_split_fixed(colnames(logFC_mat_p53), "_", 2)
col_annot <- HeatmapAnnotation(
  Drug = meta_p53[, 1],
  Time = meta_p53[, 2],
  col = list(
    Drug = c("DOX" = "#499FBD"),
    Time = c("24T" = "#238B45", 
             "24R" = "#74C476", 
             "144R" = "#C7E9C0")
  ),
  annotation_height = unit(c(1, 1, 1), "cm")
)

# Draw heatmap
Heatmap(logFC_mat_p53,
        name = "logFC",
        top_annotation = col_annot,
        cluster_columns = FALSE,
        cluster_rows = TRUE,
        show_row_names = TRUE,
        show_column_names = FALSE,
        layer_fun = function(j, i, x, y, width, height, fill) {
          grid.text(signif_mat_p53[cbind(i, j)], x, y, gp = gpar(fontsize = 9))
        },
        column_title = "P53 Target Genes Expression\nDOX Recovery",
        column_title_gp = gpar(fontsize = 14, fontface = "bold")
)

```

##Create a Venn Diagram of DEGs from Original DEA
```{r Overlap of DEGs Original}
#plot a venn diagram with all of your conditions from your toptables

# Load DEGs Data
DOX_24T <- read.csv("data/new/DEGs/Toptable_V.D24T.csv")
DOX_24R <- read.csv("data/new/DEGs/Toptable_V.D24R.csv")
DOX_144R <- read.csv("data/new/DEGs/Toptable_V.D144R.csv")

# Extract Significant DEGs
DEG1 <- DOX_24T$Entrez_ID[DOX_24T$adj.P.Val < 0.05]
DEG2 <- DOX_24R$Entrez_ID[DOX_24R$adj.P.Val < 0.05]
DEG3 <- DOX_144R$Entrez_ID[DOX_144R$adj.P.Val < 0.05]


venntest <- list(DEG1, DEG2, DEG3)
ggVennDiagram(
  venntest,
  category.names = c("DOX_24T", "DOX_24R", "DOX_144R")
) + ggtitle("DXR Specific and Shared DEGs")+
  theme(
    plot.title = element_text(size = 16, face = "bold"),  # Increase title size
    text = element_text(size = 16)  # Increase text size globally
  )

#Now that I've made my venn diagram, I want to compare these DEGs
#set 1 : 4362 DOX24T specific genes
#set2 : 4362 + 4550 + 50 + 272 genes shared across DOX24T (all genes)
#how many of these are downregulated and how many are upregulated?

# Extract Significant DEGs
# Create a list of DEGs for each sample

# Example gene sets

DEG1 <- DOX_24T$Entrez_ID[DOX_24T$adj.P.Val < 0.05]
DEG2 <- DOX_24R$Entrez_ID[DOX_24R$adj.P.Val < 0.05]
DEG3 <- DOX_144R$Entrez_ID[DOX_144R$adj.P.Val < 0.05]

#try and use the VennDetail package to extract the genes from each condition
#Set 1 - DOX_24T only genes
#Set 2 - DOX_24T shared genes
plot.new()
venn_test <- venndetail(venntest)
plot(venn_test)
detail(venn_test)
#now that I have the genes subsetted by condition, I can pull out the genes I want to look at

venn_DOX_24T <- getSet(object = venn_test, subset = c("Group 1"))
dim(venn_DOX_24T)
#4362 genes in DOX_24T only

venn_DOX_shared <- getSet(object = venn_test, subset = c("Shared", "Group 1", "Group 1_Group 2", "Group 1_Group 3"))
dim(venn_DOX_shared)
#total of 9243 genes:
  #4559 DOX_24T only 
  #272 shared all
  #50 DOX_24T + DOX_144R
  #4362 DOX_24T + DOX_24R

venn_DOX144R_shared <- getSet(object = venn_test, subset = c("Shared", "Group 3", "Group 2_Group 3", "Group 1_Group 3"))
dim(venn_DOX144R_shared)
#total of 509 genes:
 #272 shared all
 #32 DOX144R Specific
 #50 DOX24T + DOX144R
 #155 DOX24R + DOX144R

#now I can look at these sets to see which ones are up and down regulated in each
#after that, run GO analysis
venn_shared_DEGs <- venn_DOX_shared %>% 
  as.data.frame() %>% 
  column_to_rownames(., var = "Detail")

venn_sharedD144R_DEGs <- venn_DOX144R_shared %>% 
  as.data.frame() %>% 
  column_to_rownames(., var = "Detail")

venn_DOX24T_DEGs <- venn_DOX_24T %>% 
  as.data.frame() %>% 
  column_to_rownames(., var = "Detail")


#pull these genes out of my DEG matrix with logFC
DOX_24T_DEGs <- Toptable_list$V.D24T[row.names(venn_DOX24T_DEGs),]
DOX_24T_shared_DEGs <- Toptable_list$V.D24T[row.names(venn_shared_DEGs),]
DOX_144R_shared_DEGs <- Toptable_list$V.D144R[row.names(venn_sharedD144R_DEGs),]
#I want to go ahead and do this for every condition so I can see the genes in there
#I also want to filter these by their logFC being up or down for GO/KEGG

DOX24T_DEGs_GO <- DOX_24T_DEGs %>% 
  dplyr::filter(., adj.P.Val < 0.05)

DOX24T_DEGs_GO_up <- DOX24T_DEGs_GO %>% 
  dplyr::filter(., logFC > 0)  %>% 
  rownames_to_column(., var = "entrezgene_ID") %>% 
  dplyr::select("entrezgene_ID")
#has 4029 genes

DOX24T_DEGs_GO_down <- DOX24T_DEGs_GO %>% 
  dplyr::filter(., logFC < 0)  %>% 
  rownames_to_column(., var = "entrezgene_ID") %>% 
  dplyr::select("entrezgene_ID")
#has 4305 genes

#shared genes venn diagram
DOX24Tshare_DEGs_GO <- DOX_24T_shared_DEGs %>% 
  dplyr::filter(., adj.P.Val < 0.05) 

DOX24T_share_DEGs_GO_plot <- DOX24Tshare_DEGs_GO %>% 
  rownames_to_column(., var = "Entrez_ID") %>% 
  dplyr::select("Entrez_ID")

DOX24Tshare_DEGs_GO_up <- DOX24Tshare_DEGs_GO %>% 
  dplyr::filter(., logFC > 0)  %>% 
  rownames_to_column(., var = "entrezgene_ID") %>% 
  dplyr::select("entrezgene_ID")
#has 4731 genes

DOX24Tshare_DEGs_GO_down <- DOX24Tshare_DEGs_GO %>% 
  dplyr::filter(., logFC < 0)  %>% 
  rownames_to_column(., var = "entrezgene_ID") %>% 
  dplyr::select("entrezgene_ID")

DOX144Rshare_DEGs_GO <- DOX_144R_shared_DEGs %>% 
  dplyr::filter(., adj.P.Val < 0.05)

DOX144Rshare_DEGs_GO_plot <- DOX144Rshare_DEGs_GO %>% 
  rownames_to_column(., var = "Entrez_ID") %>% 
  dplyr::select("Entrez_ID")


#now go ahead and do this for each condition as well

#DOX24T
venn_DOX_24T <- getSet(object = venn_test, subset = c("Group 1"))
dim(venn_DOX_24T)
#4362 genes in DOX_24T only

venn_DOX24T_DEGs <- venn_DOX_24T %>% 
  as.data.frame() %>% 
  column_to_rownames(., var = "Detail")

#pull these genes out of my DEG matrix with logFC
DOX_24T_DEGs <- Toptable_list$V.D24T[row.names(venn_DOX24T_DEGs),]

DOX24T_DEGs_GO <- DOX_24T_DEGs %>% 
  rownames_to_column(., var = "Entrez_ID") %>% 
  dplyr::filter(., adj.P.Val < 0.05) %>% 
  dplyr::select("Entrez_ID")

#DOX24R
venn_DOX_24R <- getSet(object = venn_test, subset = c("Group 2"))
dim(venn_DOX_24R)
#2182 genes in DOX_24R only

venn_DOX24R_DEGs <- venn_DOX_24R %>% 
  as.data.frame() %>% 
  column_to_rownames(., var = "Detail")

#pull these genes out of my DEG matrix with logFC
DOX_24R_DEGs <- Toptable_list$V.D24R[row.names(venn_DOX24R_DEGs),]

DOX24R_DEGs_GO <- DOX_24R_DEGs %>% 
  rownames_to_column(., var = "Entrez_ID") %>% 
  dplyr::filter(., adj.P.Val < 0.05) %>% 
  dplyr::select("Entrez_ID")


#DOX144R
venn_DOX_144R <- getSet(object = venn_test, subset = c("Group 3"))
dim(venn_DOX_144R)
#32 genes in DOX_144R only

venn_DOX144R_DEGs <- venn_DOX_144R %>% 
  as.data.frame() %>% 
  column_to_rownames(., var = "Detail")

#pull these genes out of my DEG matrix with logFC
DOX_144R_DEGs <- Toptable_list$V.D144R[row.names(venn_DOX144R_DEGs),]

DOX144R_DEGs_GO <- DOX_144R_DEGs %>% 
  rownames_to_column(., var = "Entrez_ID") %>% 
  dplyr::filter(., adj.P.Val < 0.05) %>% 
  dplyr::select("Entrez_ID")

#this set doesn't yield a GO/KEGG plot as there are too few genes
#instead, I pulled all genes associated with DOX144R

```

##Venn Diagrams of DEG Overlap after RUVs Correction k=1
```{r RUVs Overlap of DEGs}
#plot a venn diagram with all of your conditions from your toptables

# Load DEGs Data
DOX_24T_1 <- read.csv("data/new/DEGs/TTBL_RUV_24T_OLD.csv")
DOX_24R_1 <- read.csv("data/new/DEGs/TTBL_RUV_24R_OLD.csv")
DOX_144R_1 <- read.csv("data/new/DEGs/TTBL_RUV_144R_OLD.csv")

# Extract Significant DEGs
DEG1_RUV <- DOX_24T_1$Entrez_ID[DOX_24T_1$adj.P.Val < 0.05]
DEG2_RUV <- DOX_24R_1$Entrez_ID[DOX_24R_1$adj.P.Val < 0.05]
DEG3_RUV <- DOX_144R_1$Entrez_ID[DOX_144R_1$adj.P.Val < 0.05]

venntest_RUV <- list(DEG1_RUV, DEG2_RUV, DEG3_RUV)
ggVennDiagram(
  venntest_RUV,
  category.names = c("DOX_24T", "DOX_24R", "DOX_144R")
) + ggtitle("DXR Specific and Shared DEGs RUVs")+
  theme(
    plot.title = element_text(size = 16, face = "bold"),  # Increase title size
    text = element_text(size = 16)  # Increase text size globally
  )

####I want to make this proportional
#use the eulerr package to do so

library(eulerr)

venn_prop_RUV <- euler(list(
  `24T` = DEG1_RUV,
  `24R` = DEG2_RUV,
  `144R` = DEG3_RUV
))

plot(venn_prop_RUV,
     fills = list(fill = c("#238B45", "#74C476", "#C7E9C0"), 
                  alpha = 1),
     labels = list(font = 4),
     quantities = list(cex = 0.75),
     main = "")


#try and use the VennDetail package to extract the genes from each condition
#Set 1 - DOX_24T only genes
#Set 2 - DOX_24T shared genes
#Set 3 - DOX_144R shared genes
plot.new()
venn_test_RUV <- venndetail(venntest_RUV)
plot(venn_test_RUV)
detail(venn_test_RUV)
#now that I have the genes subsetted by condition, I can pull out the genes I want to look at

venn_DOX_24T_RUV <- getSet(object = venn_test_RUV, subset = c("Group 1"))
dim(venn_DOX_24T_RUV)
#4411 genes in DOX_24T only

venn_DOX_shared_RUV <- getSet(object = venn_test_RUV, subset = c("Shared", "Group 1_Group 2", "Group 1_Group 3"))
dim(venn_DOX_shared_RUV)
#total of 5009 genes in this set which does not include D24T specific genes

venn_DOX144R_shared_RUV <- getSet(object = venn_test_RUV, subset = c("Shared", "Group 3", "Group 2_Group 3", "Group 1_Group 3"))
dim(venn_DOX144R_shared_RUV)
#total of 660 genes: (original 509)
 #342 shared all
 #32 DOX144R Specific
 #85 DOX24T + DOX144R
 #181 DOX24R + DOX144R

#after that, run GO analysis
venn_shared_DEGs_RUV <- venn_DOX_shared_RUV %>% 
  as.data.frame() %>% 
  column_to_rownames(., var = "Detail")

venn_DOX24T_DEGs_RUV <- venn_DOX_24T_RUV %>% 
  as.data.frame() %>% 
  column_to_rownames(., var = "Detail")

venn_sharedD144R_DEGs_RUV <- venn_DOX144R_shared_RUV %>% 
  as.data.frame() %>% 
  column_to_rownames(., var = "Detail")

#pull these genes out of my DEG matrix with logFC
DOX_24T_DEGs_RUV <-
  Toptable_list_RUVk1_symbols$V.D24T_RUV[row.names(venn_DOX24T_DEGs_RUV),]
DOX_24T_shared_DEGs_RUV <- 
  Toptable_list_RUVk1_symbols$V.D24T_RUV[row.names(venn_shared_DEGs_RUV),]
DOX_144R_shared_DEGs_RUV <- 
  Toptable_list_RUVk1_symbols$V.D144R_RUV[row.names(venn_sharedD144R_DEGs_RUV),]

#next, make the vectors that I need for plotting after cutting off by adj. p value < 0.05
DOX24T_DEGs_GO_RUV <- DOX_24T_DEGs_RUV %>% 
  dplyr::filter(., adj.P.Val < 0.05)

#shared D24T genes venn diagram
DOX24Tshare_DEGs_GO_RUV <- DOX_24T_shared_DEGs_RUV %>% 
  dplyr::filter(., adj.P.Val < 0.05) 

DOX24T_share_DEGs_GO_plot_RUV <- DOX24Tshare_DEGs_GO_RUV %>% 
  dplyr::select("Entrez_ID")

#shared D144R genes venn diagram

DOX144Rshare_DEGs_GO_RUV <- DOX_144R_shared_DEGs_RUV %>% 
  dplyr::filter(., adj.P.Val < 0.05)

DOX144Rshare_DEGs_GO_plot_RUV <- DOX144Rshare_DEGs_GO_RUV %>% 
  dplyr::select("Entrez_ID")

#now go ahead and do this for each condition as well

#DOX24T
venn_DOX_24T_RUV <- getSet(object = venn_test_RUV, subset = c("Group 1"))
dim(venn_DOX_24T_RUV)
#4411 genes in DOX_24T only

venn_DOX24T_DEGs_RUV <- venn_DOX_24T_RUV %>% 
  as.data.frame() %>% 
  column_to_rownames(., var = "Detail")

#pull these genes out of my DEG matrix with logFC
DOX_24T_DEGs_RUV <- Toptable_list_RUVk1_symbols$V.D24T_RUV[row.names(venn_DOX24T_DEGs_RUV),]

DOX24T_DEGs_GO_RUV <- DOX_24T_DEGs_RUV %>% 
  dplyr::filter(., adj.P.Val < 0.05) %>% 
  dplyr::select("Entrez_ID")

#DOX24R
venn_DOX_24R_RUV <- getSet(object = venn_test_RUV, subset = c("Group 2"))
dim(venn_DOX_24R_RUV)
#2107 genes in DOX_24R only

venn_DOX24R_DEGs_RUV <- venn_DOX_24R_RUV %>% 
  as.data.frame() %>% 
  column_to_rownames(., var = "Detail")

#pull these genes out of my DEG matrix with logFC
DOX_24R_DEGs_RUV <- Toptable_list_RUVk1_symbols$V.D24R_RUV[row.names(venn_DOX24R_DEGs_RUV),]

DOX24R_DEGs_GO_RUV <- DOX_24R_DEGs_RUV %>% 
  dplyr::filter(., adj.P.Val < 0.05) %>% 
  dplyr::select("Entrez_ID")


#DOX144R
venn_DOX_144R_RUV <- getSet(object = venn_test_RUV, subset = c("Group 3"))
dim(venn_DOX_144R_RUV)
#52 genes in DOX_144R only

venn_DOX144R_DEGs_RUV <- venn_DOX_144R_RUV %>% 
  as.data.frame() %>% 
  column_to_rownames(., var = "Detail")

#pull these genes out of my DEG matrix with logFC
DOX_144R_DEGs_RUV <- 
  Toptable_list_RUVk1_symbols$V.D144R_RUV[row.names(venn_DOX144R_DEGs_RUV),]

DOX144R_DEGs_GO_RUV <- DOX_144R_DEGs_RUV %>% 
  dplyr::filter(., adj.P.Val < 0.05) %>% 
  dplyr::select("Entrez_ID")
```
###Proportion of DEGs in Gene Set RUVs corrected
```{r Proportion of DEGs}
#check the proportion of my genes in my gene set that are DEGs by timepoint

#make this into a pie chart or a bar graph
#read in my full gene set
all_genes <- readRDS("data/new/RUV/all_genes_set.RDS") 

#convert Entrez_ID to Gene Symbols
all_genes_set <- mapIds(org.Hs.eg.db, 
                        keys = all_genes,
                        column = "SYMBOL",
                        keytype = "ENTREZID",
                        multiVals = "first")

#load in my DEGs
#load in DEGs for all timepoints 
DOX_24T_R <- read.csv("data/new/DEGs/Toptable_RUV_24T_final.csv") %>% 
  dplyr::select(-(X))
DOX_24R_R <- read.csv("data/new/DEGs/Toptable_RUV_24R_final.csv") %>% 
  dplyr::select(-(X))
DOX_144R_R <- read.csv("data/new/DEGs/Toptable_RUV_144R_final.csv") %>% 
  dplyr::select(-(X))

# Extract Significant DEGs from these lists
DEGs_24T_R <- DOX_24T_R$Entrez_ID[DOX_24T_R$adj.P.Val < 0.05]
# saveRDS(DEGs_24T_R, "data/new/RUV/DEGs_sig_list_24T_RUVs_set.RDS")

DEGs_24R_R <- DOX_24R_R$Entrez_ID[DOX_24R_R$adj.P.Val < 0.05]
# saveRDS(DEGs_24R_R, "data/new/RUV/DEGs_sig_list_24R_RUVs_set.RDS")

DEGs_144R_R <- DOX_144R_R$Entrez_ID[DOX_144R_R$adj.P.Val < 0.05]
# saveRDS(DEGs_144R_R, "data/new/RUV/DEGs_sig_list_144R_RUVs_set.RDS")

#make a list of all of my DEGs
timepoint_DEGs_RUV <- list(
  "24T" = DEGs_24T_R,
  "24R" = DEGs_24R_R,
  "144R" = DEGs_144R_R
)

# Function to compute proportions
get_proportions_degs <- function(degs, total_genes) {
  deg_count <- length(degs)
  non_deg_count <- total_genes - deg_count
  data.frame(
    Category = c("DEGs", "Non-DEGs"),
    Count = c(deg_count, non_deg_count),
    Proportion = c(deg_count / total_genes, non_deg_count / total_genes)
  )
}

# Compute proportions for each timepoint
prop_24T <- get_proportions_degs(DEGs_24T_R, length(all_genes_set))
prop_24R <- get_proportions_degs(DEGs_24R_R, length(all_genes_set))
prop_144R <- get_proportions_degs(DEGs_144R_R, length(all_genes_set))

# Combine for bar plot
prop_bar <- rbind(
  cbind(Timepoint = "24T", prop_24T),
  cbind(Timepoint = "24R", prop_24R),
  cbind(Timepoint = "144R", prop_144R)
)

#pie chart for 24T
ggplot(prop_24T, aes(x = "", y = Count, fill = Category)) +
  geom_bar(stat = "identity", width = 1) +
  coord_polar("y") +
  labs(title = "DEGs vs Non-DEGs (24T)") +
  theme_void()

#pie chart for 24R
ggplot(prop_24R, aes(x = "", y = Count, fill = Category)) +
  geom_bar(stat = "identity", width = 1) +
  coord_polar("y") +
  labs(title = "DEGs vs Non-DEGs (24R)") +
  theme_void()

#pie chart for 144R
ggplot(prop_144R, aes(x = "", y = Count, fill = Category)) +
  geom_bar(stat = "identity", width = 1) +
  coord_polar("y") +
  labs(title = "DEGs vs Non-DEGs (144R)") +
  theme_void()

library(patchwork)

#put the desired colors here for your pie charts
degs_prop_colors <- c("DEGs" = "red", "Non-DEGs" = "blue")

#labels for percentage based on proportion
prop_24T$Label <- paste0(round(prop_24T$Proportion * 100, 1), "%")
prop_24R$Label <- paste0(round(prop_24R$Proportion * 100, 1), "%")
prop_144R$Label <- paste0(round(prop_144R$Proportion * 100, 1), "%")

#create each plot and assign to variables
plot_24T <- ggplot(prop_24T, aes(x = "", y = Count, fill = Category)) +
  geom_bar(stat = "identity", width = 1) +
  coord_polar("y") +
  geom_text(aes(label = Label), 
            position = position_stack(vjust = 0.6), 
            color = "white", 
            size = 4) +
  scale_fill_manual(values = degs_prop_colors) +
  labs(title = "24hr Treatment") +
  theme_void()

plot_24R <- ggplot(prop_24R, aes(x = "", y = Count, fill = Category)) +
  geom_bar(stat = "identity", width = 1) +
  coord_polar("y") +
  geom_text(aes(label = Label), 
            position = position_stack(vjust = 0.6), 
            color = "white", 
            size = 4) +
  scale_fill_manual(values = degs_prop_colors) +
  labs(title = "24hr Recovery") +
  theme_void()

plot_144R <- ggplot(prop_144R, aes(x = "", y = Count, fill = Category)) +
  geom_bar(stat = "identity", width = 1) +
  coord_polar("y") +
  geom_text(aes(label = Label), 
            position = position_stack(vjust = 0.6), 
            color = "white", 
            size = 4) +
  scale_fill_manual(values = degs_prop_colors) +
  labs(title = "144hr Recovery") +
  theme_void()

#combine all three pie charts in a row
combined_prop_degs_plots <- 
  plot_24T + 
  plot_24R + 
  plot_144R +
  plot_layout(ncol = 3, nrow = 1, guides = "collect") + 
  plot_annotation(title = "Proportion of DEGs vs Non-DEGs")

#show the combined pie chart plot
combined_prop_degs_plots

#combine all three pie charts in a column
combined_prop_degs_plots_col <- 
  plot_24T + 
  plot_24R + 
  plot_144R +
  plot_layout(ncol = 1, nrow = 3, guides = "collect") + 
  plot_annotation(title = "Proportion of DEGs vs Non-DEGs")

#show the combined pie chart plot in 1 column
combined_prop_degs_plots_col

####proportion bar plots####
#first factor the timepoints so that they are in the right order
prop_bar$Timepoint <- factor(prop_bar$Timepoint, 
                             levels = c("24T", "24R", "144R"))

#percentage labels
prop_bar$Label <- paste0(round(prop_bar$Proportion * 100, 1), "%")

#plot the bar plot
ggplot(prop_bar, aes(x = Timepoint, 
                     y = Proportion, 
                     fill = Category)) +
  geom_bar(stat = "identity", 
           position = "fill") +
  geom_text(aes(label = Label),
            position = position_fill(vjust = 0.5),
            color = "white",
            size = 4) +
  scale_fill_manual(values = degs_prop_colors) +
  labs(title = "Proportion of DEGs vs Non-DEGs by Timepoint",
       y = "Proportion", 
       x = "Timepoint") +
  scale_y_continuous(labels = scales::percent) +
  theme_minimal()


```


###GO KEGG Overlap of DEGs From Original Data
```{r GO KEGG Overlap DEGs Original}
#####DOX24 Genes#####
library(gprofiler2)

#define your background gene set (all expressed genes for me)
all_genes <- rownames(filcpm_matrix)

D24_DEGs_mat <- as.matrix(DOX24T_DEGs_GO)

DOX_24_dxr_gene <- gost(query = D24_DEGs_mat,
                      organism = "hsapiens",
                      ordered_query = FALSE,
                      measure_underrepresentation = FALSE,
                      evcodes = FALSE,
                      user_threshold = 0.05,
                      custom_bg = all_genes,
                      correction_method = c("fdr"),
                      sources = c("GO:BP", "KEGG"))

DOX_24_gost_genes <- gostplot(DOX_24_dxr_gene, capped = FALSE, interactive = TRUE)
DOX_24_gost_genes

table_DOX24_genes <- DOX_24_dxr_gene$result %>% 
  dplyr::select(c(source, term_id, term_name, intersection_size, term_size, p_value))

table_DOX24_genes %>% 
  mutate_at(.vars = 6, .funs = scales::label_scientific(digits=4)) %>% 
  kableExtra::kable(.,) %>% 
  kableExtra::kable_paper("striped", full_width = FALSE) %>% 
  kableExtra::kable_styling(full_width = FALSE, position = "left", bootstrap_options = c("striped", "hover")) %>% 
  kableExtra::scroll_box(width = "100%", height = "400px")

write.csv(table_DOX24_genes, "output/table_DOX24_genes.csv")

#GO:BP
table_DOX24_genes_GOBP <- table_DOX24_genes %>% 
  dplyr::filter(source=="GO:BP") %>% 
  dplyr::select(p_value, term_name, intersection_size) %>% 
  dplyr::slice_min(., n=10, order_by=p_value) %>% 
  mutate(log_val = -log10(p_value))


table_DOX24_genes_GOBP %>% ggplot(., aes(x = log_val, y = reorder(term_name, p_value), col= intersection_size)) +
  geom_point(aes(size = intersection_size)) +
  ggtitle("DOX24T Specific DEGs Enriched GO:BP Terms")+
  xlab(expression("-log"[10]~"p-value"))+
  guides(col="none", size= guide_legend(title = "# of intersected \n terms"))+
  ylab("GO:BP term")+
  scale_y_discrete(labels = scales::label_wrap(30))+
  theme_bw()+
  theme(plot.title = element_text(size = rel(1.5), hjust = 0.5),
        axis.title = element_text(size = 15, colour = "black"),
        axis.ticks = element_line(linewidth = 1.5),
        axis.line = element_line(linewidth = 1.5),
        axis.text = element_text(size = 10, colour = "black", angle = 0),
        strip.text = element_text(size = 15, colour = "black", face = "bold"))

#KEGG
table_DOX24_genes_KEGG <- table_DOX24_genes %>% 
  dplyr::filter(source=="KEGG") %>% 
  dplyr::select(p_value, term_name, intersection_size) %>% 
  dplyr::slice_min(., n=10, order_by=p_value) %>% 
  mutate(log_val = -log10(p_value))

table_DOX24_genes_KEGG %>% ggplot(., aes(x = log_val, y = reorder(term_name, p_value), col= intersection_size)) +
  geom_point(aes(size = intersection_size)) +
  ggtitle("DOX24T Specific DEGs Enriched KEGG Terms")+
  xlab(expression("-log"[10]~"p-value"))+
  guides(col="none", size= guide_legend(title = "# of intersected \n terms"))+
  ylab("KEGG term")+
  scale_y_discrete(labels = scales::label_wrap(30))+
  theme_bw()+
  theme(plot.title = element_text(size = rel(1.5), hjust = 0.5),
        axis.title = element_text(size = 15, colour = "black"),
        axis.ticks = element_line(linewidth = 1.5),
        axis.line = element_line(linewidth = 1.5),
        axis.text = element_text(size = 10, colour = "black", angle = 0),
        strip.text = element_text(size = 15, colour = "black", face = "bold"))


#####DOX24T shared DEGs GO KEGG#####
D24Tshare_DEGs_mat <- as.matrix(DOX24T_share_DEGs_GO_plot)

DOX_24Tshare_dxr_gene <- gost(query = D24Tshare_DEGs_mat,
                      organism = "hsapiens",
                      ordered_query = FALSE,
                      measure_underrepresentation = FALSE,
                      evcodes = FALSE,
                      user_threshold = 0.05,
                      custom_bg = all_genes,
                      correction_method = c("fdr"),
                      sources = c("GO:BP", "KEGG"))

DOX_24Tshare_gost_genes <- gostplot(DOX_24Tshare_dxr_gene, capped = FALSE, interactive = TRUE)
DOX_24Tshare_gost_genes

table_DOX24Tshare_genes <- DOX_24Tshare_dxr_gene$result %>% 
  dplyr::select(c(source, term_id, term_name, intersection_size, term_size, p_value))

table_DOX24Tshare_genes %>% 
  mutate_at(.vars = 6, .funs = scales::label_scientific(digits=4)) %>% 
  kableExtra::kable(.,) %>% 
  kableExtra::kable_paper("striped", full_width = FALSE) %>% 
  kableExtra::kable_styling(full_width = FALSE, position = "left", bootstrap_options = c("striped", "hover")) %>% 
  kableExtra::scroll_box(width = "100%", height = "400px")

#GO:BP
table_DOX24Tshare_genes_GOBP <- table_DOX24Tshare_genes %>% 
  dplyr::filter(source=="GO:BP") %>% 
  dplyr::select(p_value, term_name, intersection_size) %>% 
  dplyr::slice_min(., n=10, order_by=p_value) %>% 
  mutate(log_val = -log10(p_value))

table_DOX24Tshare_genes_GOBP %>% ggplot(., aes(x = log_val, y = reorder(term_name, p_value), col= intersection_size)) +
  geom_point(aes(size = intersection_size)) +
  ggtitle("DOX24T Shared DEGs Enriched GO:BP Terms")+
  xlab(expression("-log"[10]~"p-value"))+
  guides(col="none", size= guide_legend(title = "# of intersected \n terms"))+
  ylab("GO:BP term")+
  scale_y_discrete(labels = scales::label_wrap(30))+
  theme_bw()+
  theme(plot.title = element_text(size = rel(1.5), hjust = 0.5),
        axis.title = element_text(size = 15, colour = "black"),
        axis.ticks = element_line(linewidth = 1.5),
        axis.line = element_line(linewidth = 1.5),
        axis.text = element_text(size = 10, colour = "black", angle = 0),
        strip.text = element_text(size = 15, colour = "black", face = "bold"))

#KEGG
table_DOX24Tshare_genes_KEGG <- table_DOX24Tshare_genes %>% 
  dplyr::filter(source=="KEGG") %>% 
  dplyr::select(p_value, term_name, intersection_size) %>% 
  dplyr::slice_min(., n=10, order_by=p_value) %>% 
  mutate(log_val = -log10(p_value))

table_DOX24Tshare_genes_KEGG %>% ggplot(., aes(x = log_val, y = reorder(term_name, p_value), col= intersection_size)) +
  geom_point(aes(size = intersection_size)) +
  ggtitle("DOX24T Shared DEGs Enriched KEGG Terms")+
  xlab(expression("-log"[10]~"p-value"))+
  guides(col="none", size= guide_legend(title = "# of intersected \n terms"))+
  ylab("KEGG term")+
  scale_y_discrete(labels = scales::label_wrap(30))+
  theme_bw()+
  theme(plot.title = element_text(size = rel(1.5), hjust = 0.5),
        axis.title = element_text(size = 15, colour = "black"),
        axis.ticks = element_line(linewidth = 1.5),
        axis.line = element_line(linewidth = 1.5),
        axis.text = element_text(size = 10, colour = "black", angle = 0),
        strip.text = element_text(size = 15, colour = "black", face = "bold"))

#####DOX24R DEGs GO KEGG#####
D24R_DEGs_mat <- as.matrix(DOX24R_DEGs_GO)

DOX_24R_dxr_gene <- gost(query = D24R_DEGs_mat,
                      organism = "hsapiens",
                      ordered_query = FALSE,
                      measure_underrepresentation = FALSE,
                      evcodes = FALSE,
                      user_threshold = 0.05,
                      correction_method = c("fdr"),
                      sources = c("GO:BP", "KEGG"))

DOX_24R_gost_genes <- gostplot(DOX_24R_dxr_gene, capped = FALSE, interactive = TRUE)
DOX_24R_gost_genes

table_DOX24R_genes <- DOX_24R_dxr_gene$result %>% 
  dplyr::select(c(source, term_id, term_name, intersection_size, term_size, p_value))

table_DOX24R_genes %>% 
  mutate_at(.vars = 6, .funs = scales::label_scientific(digits=4)) %>% 
  kableExtra::kable(.,) %>% 
  kableExtra::kable_paper("striped", full_width = FALSE) %>% 
  kableExtra::kable_styling(full_width = FALSE, position = "left", bootstrap_options = c("striped", "hover")) %>% 
  kableExtra::scroll_box(width = "100%", height = "400px")

#GO:BP
table_DOX24R_genes_GOBP <- table_DOX24R_genes %>% 
  dplyr::filter(source=="GO:BP") %>% 
  dplyr::select(p_value, term_name, intersection_size) %>% 
  dplyr::slice_min(., n=10, order_by=p_value) %>% 
  mutate(log_val = -log10(p_value))

table_DOX24R_genes_GOBP %>% ggplot(., aes(x = log_val, y = reorder(term_name, p_value), col= intersection_size)) +
  geom_point(aes(size = intersection_size)) +
  ggtitle("DOX24R Specific DEGs Enriched GO:BP Terms")+
  xlab(expression("-log"[10]~"p-value"))+
  guides(col="none", size= guide_legend(title = "# of intersected \n terms"))+
  ylab("GO:BP term")+
  scale_y_discrete(labels = scales::label_wrap(30))+
  theme_bw()+
  theme(plot.title = element_text(size = rel(1.5), hjust = 0.5),
        axis.title = element_text(size = 15, colour = "black"),
        axis.ticks = element_line(linewidth = 1.5),
        axis.line = element_line(linewidth = 1.5),
        axis.text = element_text(size = 10, colour = "black", angle = 0),
        strip.text = element_text(size = 15, colour = "black", face = "bold"))

#KEGG
table_DOX24R_genes_KEGG <- table_DOX24R_genes %>% 
  dplyr::filter(source=="KEGG") %>% 
  dplyr::select(p_value, term_name, intersection_size) %>% 
  dplyr::slice_min(., n=10, order_by=p_value) %>% 
  mutate(log_val = -log10(p_value))

table_DOX24R_genes_KEGG %>% ggplot(., aes(x = log_val, y = reorder(term_name, p_value), col= intersection_size)) +
  geom_point(aes(size = intersection_size)) +
  ggtitle("DOX24R DEGs Enriched KEGG Terms")+
  xlab(expression("-log"[10]~"p-value"))+
  guides(col="none", size= guide_legend(title = "# of intersected \n terms"))+
  ylab("KEGG term")+
  scale_y_discrete(labels = scales::label_wrap(30))+
  theme_bw()+
  theme(plot.title = element_text(size = rel(1.5), hjust = 0.5),
        axis.title = element_text(size = 15, colour = "black"),
        axis.ticks = element_line(linewidth = 1.5),
        axis.line = element_line(linewidth = 1.5),
        axis.text = element_text(size = 10, colour = "black", angle = 0),
        strip.text = element_text(size = 15, colour = "black", face = "bold"))

#####DOX144R DEGs GO KEGG#####
# D144R_DEGs_mat <- as.matrix(DOX144R_DEGs_GO)
# 
# DOX_144R_dxr_gene <- gost(query = D144R_DEGs_mat,
#                       organism = "hsapiens",
#                       ordered_query = FALSE,
#                       measure_underrepresentation = FALSE,
#                       evcodes = FALSE,
#                       user_threshold = 0.05,
#                       correction_method = c("fdr"),
#                       sources = c("GO:BP", "KEGG"))
# 
# DOX_144R_gost_genes <- gostplot(DOX_144R_dxr_gene, capped = FALSE, interactive = TRUE)
# DOX_144R_gost_genes
# 
# table_DOX144R_genes <- DOX_144R_dxr_gene$result %>% 
#   dplyr::select(c(source, term_id, term_name, intersection_size, term_size, p_value))
# 
# table_DOX144R_genes %>% 
#   mutate_at(.vars = 6, .funs = scales::label_scientific(digits=4)) %>% 
#   kableExtra::kable(.,) %>% 
#   kableExtra::kable_paper("striped", full_width = FALSE) %>% 
#   kableExtra::kable_styling(full_width = FALSE, position = "left", bootstrap_options = c("striped", "hover")) %>% 
#   kableExtra::scroll_box(width = "100%", height = "400px")
# 
# #GO:BP
# table_DOX144R_genes_GOBP <- table_DOX144R_genes %>% 
#   dplyr::filter(source=="GO:BP") %>% 
#   dplyr::select(p_value, term_name, intersection_size) %>% 
#   dplyr::slice_min(., n=10, order_by=p_value) %>% 
#   mutate(log_val = -log10(p_value))
# 
# table_DOX144R_genes_GOBP %>% ggplot(., aes(x = log_val, y = reorder(term_name, p_value), col= intersection_size)) +
#   geom_point(aes(size = intersection_size)) +
#   ggtitle("DOX144R Specific DEGs Enriched GO:BP Terms")+
#   xlab(expression("-log"[10]~"p-value"))+
#   guides(col="none", size= guide_legend(title = "# of intersected \n terms"))+
#   ylab("GO:BP term")+
#   scale_y_discrete(labels = scales::label_wrap(30))+
#   theme_bw()+
#   theme(plot.title = element_text(size = rel(1.5), hjust = 0.5),
#         axis.title = element_text(size = 15, colour = "black"),
#         axis.ticks = element_line(linewidth = 1.5),
#         axis.line = element_line(linewidth = 1.5),
#         axis.text = element_text(size = 10, colour = "black", angle = 0),
#         strip.text = element_text(size = 15, colour = "black", face = "bold"))
# 
# #KEGG
# table_DOX144R_genes_KEGG <- table_DOX144R_genes %>% 
#   dplyr::filter(source=="KEGG") %>% 
#   dplyr::select(p_value, term_name, intersection_size) %>% 
#   dplyr::slice_min(., n=10, order_by=p_value) %>% 
#   mutate(log_val = -log10(p_value))
# 
# table_DOX144R_genes_KEGG %>% ggplot(., aes(x = log_val, y = reorder(term_name, p_value), col= intersection_size)) +
#   geom_point(aes(size = intersection_size)) +
#   ggtitle("DOX144R DEGs Enriched KEGG Terms")+
#   xlab(expression("-log"[10]~"p-value"))+
#   guides(col="none", size= guide_legend(title = "# of intersected \n terms"))+
#   ylab("KEGG term")+
#   scale_y_discrete(labels = scales::label_wrap(30))+
#   theme_bw()+
#   theme(plot.title = element_text(size = rel(1.5), hjust = 0.5),
#         axis.title = element_text(size = 15, colour = "black"),
#         axis.ticks = element_line(linewidth = 1.5),
#         axis.line = element_line(linewidth = 1.5),
#         axis.text = element_text(size = 10, colour = "black", angle = 0),
#         strip.text = element_text(size = 15, colour = "black", face = "bold"))

#####DOX144R shared DEGs GO KEGG#####
D144Rshare_DEGs_mat <- as.matrix(DOX144Rshare_DEGs_GO_plot)

DOX_144Rshare_dxr_gene <- gost(query = D144Rshare_DEGs_mat,
                      organism = "hsapiens",
                      ordered_query = FALSE,
                      measure_underrepresentation = FALSE,
                      evcodes = FALSE,
                      user_threshold = 0.05,
                      custom_bg = all_genes,
                      correction_method = c("fdr"),
                      sources = c("GO:BP", "KEGG"))

DOX_144Rshare_gost_genes <- gostplot(DOX_144Rshare_dxr_gene, capped = FALSE, interactive = TRUE)
DOX_144Rshare_gost_genes

table_DOX144Rshare_genes <- DOX_144Rshare_dxr_gene$result %>% 
  dplyr::select(c(source, term_id, term_name, intersection_size, term_size, p_value))

table_DOX144Rshare_genes %>% 
  mutate_at(.vars = 6, .funs = scales::label_scientific(digits=4)) %>% 
  kableExtra::kable(.,) %>% 
  kableExtra::kable_paper("striped", full_width = FALSE) %>% 
  kableExtra::kable_styling(full_width = FALSE, position = "left", bootstrap_options = c("striped", "hover")) %>% 
  kableExtra::scroll_box(width = "100%", height = "400px")

#GO:BP
table_DOX144Rshare_genes_GOBP <- table_DOX144Rshare_genes %>% 
  dplyr::filter(source=="GO:BP") %>% 
  dplyr::select(p_value, term_name, intersection_size) %>% 
  dplyr::slice_min(., n=10, order_by=p_value) %>% 
  mutate(log_val = -log10(p_value))

table_DOX144Rshare_genes_GOBP %>% ggplot(., aes(x = log_val, y = reorder(term_name, p_value), col= intersection_size)) +
  geom_point(aes(size = intersection_size)) +
  ggtitle("DOX144R Shared DEGs Enriched GO:BP Terms")+
  xlab(expression("-log"[10]~"p-value"))+
  guides(col="none", size= guide_legend(title = "# of intersected \n terms"))+
  ylab("GO:BP term")+
  scale_y_discrete(labels = scales::label_wrap(30))+
  theme_bw()+
  theme(plot.title = element_text(size = rel(1.5), hjust = 0.5),
        axis.title = element_text(size = 15, colour = "black"),
        axis.ticks = element_line(linewidth = 1.5),
        axis.line = element_line(linewidth = 1.5),
        axis.text = element_text(size = 10, colour = "black", angle = 0),
        strip.text = element_text(size = 15, colour = "black", face = "bold"))

#KEGG
table_DOX144Rshare_genes_KEGG <- table_DOX144Rshare_genes %>% 
  dplyr::filter(source=="KEGG") %>% 
  dplyr::select(p_value, term_name, intersection_size) %>% 
  dplyr::slice_min(., n=10, order_by=p_value) %>% 
  mutate(log_val = -log10(p_value))

table_DOX144Rshare_genes_KEGG %>% ggplot(., aes(x = log_val, y = reorder(term_name, p_value), col= intersection_size)) +
  geom_point(aes(size = intersection_size)) +
  ggtitle("DOX144R Shared DEGs Enriched KEGG Terms")+
  xlab(expression("-log"[10]~"p-value"))+
  guides(col="none", size= guide_legend(title = "# of intersected \n terms"))+
  ylab("KEGG term")+
  scale_y_discrete(labels = scales::label_wrap(30))+
  theme_bw()+
  theme(plot.title = element_text(size = rel(1.5), hjust = 0.5),
        axis.title = element_text(size = 15, colour = "black"),
        axis.ticks = element_line(linewidth = 1.5),
        axis.line = element_line(linewidth = 1.5),
        axis.text = element_text(size = 10, colour = "black", angle = 0),
        strip.text = element_text(size = 15, colour = "black", face = "bold"))

```

###GO/KEGG Analysis of Upreg and Downreg Genes Original Data
```{r GO KEGG Overlap DEGs Up/Down}
# library(gprofiler2)
#####DOX24 Upregulated Genes#####
D24_DEGs_up_mat <- as.matrix(DOX24T_DEGs_GO_up)

DOX_24_up_dxr_gene <- gost(query = D24_DEGs_up_mat,
                      organism = "hsapiens",
                      ordered_query = FALSE,
                      measure_underrepresentation = FALSE,
                      evcodes = FALSE,
                      user_threshold = 0.05,
                      custom_bg = all_genes,
                      correction_method = c("fdr"),
                      sources = c("GO:BP", "KEGG"))

DOX_24_up_gost_genes <- gostplot(DOX_24_up_dxr_gene, capped = FALSE, interactive = TRUE)
DOX_24_up_gost_genes

table_DOX24_up_genes <- DOX_24_up_dxr_gene$result %>% 
  dplyr::select(c(source, term_id, term_name, intersection_size, term_size, p_value))

table_DOX24_up_genes %>% 
  mutate_at(.vars = 6, .funs = scales::label_scientific(digits=4)) %>% 
  kableExtra::kable(.,) %>% 
  kableExtra::kable_paper("striped", full_width = FALSE) %>% 
  kableExtra::kable_styling(full_width = FALSE, position = "left", bootstrap_options = c("striped", "hover")) %>% 
  kableExtra::scroll_box(width = "100%", height = "400px")

#write.csv(table_DOX24_up_genes, "output/table_DOX24_upreg_genes.csv")

#GO:BP
table_DOX24_up_genes_GOBP <- table_DOX24_up_genes %>% 
  dplyr::filter(source=="GO:BP") %>% 
  dplyr::select(p_value, term_name, intersection_size) %>% 
  dplyr::slice_min(., n=10, order_by=p_value) %>% 
  mutate(log_val = -log10(p_value))

#saveRDS(table_motif1_GOBP_d, "data/table_motif1_GOBP_d.RDS")

table_DOX24_up_genes_GOBP %>% ggplot(., aes(x = log_val, y = reorder(term_name, p_value), col= intersection_size)) +
  geom_point(aes(size = intersection_size)) +
  ggtitle("DOX24T Specific Up DEGs Enriched GO:BP Terms")+
  xlab(expression("-log"[10]~"p-value"))+
  guides(col="none", size= guide_legend(title = "# of intersected \n terms"))+
  ylab("GO:BP term")+
  scale_y_discrete(labels = scales::label_wrap(30))+
  theme_bw()+
  theme(plot.title = element_text(size = rel(1.5), hjust = 0.5),
        axis.title = element_text(size = 15, colour = "black"),
        axis.ticks = element_line(linewidth = 1.5),
        axis.line = element_line(linewidth = 1.5),
        axis.text = element_text(size = 10, colour = "black", angle = 0),
        strip.text = element_text(size = 15, colour = "black", face = "bold"))

#KEGG
table_DOX24_up_genes_KEGG <- table_DOX24_up_genes %>% 
  dplyr::filter(source=="KEGG") %>% 
  dplyr::select(p_value, term_name, intersection_size) %>% 
  dplyr::slice_min(., n=10, order_by=p_value) %>% 
  mutate(log_val = -log10(p_value))

table_DOX24_up_genes_KEGG %>% ggplot(., aes(x = log_val, y = reorder(term_name, p_value), col= intersection_size)) +
  geom_point(aes(size = intersection_size)) +
  ggtitle("DOX24T Specific Up DEGs Enriched KEGG Terms")+
  xlab(expression("-log"[10]~"p-value"))+
  guides(col="none", size= guide_legend(title = "# of intersected \n terms"))+
  ylab("KEGG term")+
  scale_y_discrete(labels = scales::label_wrap(30))+
  theme_bw()+
  theme(plot.title = element_text(size = rel(1.5), hjust = 0.5),
        axis.title = element_text(size = 15, colour = "black"),
        axis.ticks = element_line(linewidth = 1.5),
        axis.line = element_line(linewidth = 1.5),
        axis.text = element_text(size = 10, colour = "black", angle = 0),
        strip.text = element_text(size = 15, colour = "black", face = "bold"))

#####DOX24 Downregulated Genes#####
D24_DEGs_down_mat <- as.matrix(DOX24T_DEGs_GO_down)

DOX_24_down_dxr_gene <- gost(query = D24_DEGs_down_mat,
                      organism = "hsapiens",
                      ordered_query = FALSE,
                      measure_underrepresentation = FALSE,
                      evcodes = FALSE,
                      user_threshold = 0.05,
                      custom_bg = all_genes,
                      correction_method = c("fdr"),
                      sources = c("GO:BP", "KEGG"))

DOX_24_down_gost_genes <- gostplot(DOX_24_down_dxr_gene, capped = FALSE, interactive = TRUE)
DOX_24_down_gost_genes

table_DOX24_down_genes <- DOX_24_down_dxr_gene$result %>% 
  dplyr::select(c(source, term_id, term_name, intersection_size, term_size, p_value))

table_DOX24_down_genes %>% 
  mutate_at(.vars = 6, .funs = scales::label_scientific(digits=4)) %>% 
  kableExtra::kable(.,) %>% 
  kableExtra::kable_paper("striped", full_width = FALSE) %>% 
  kableExtra::kable_styling(full_width = FALSE, position = "left", bootstrap_options = c("striped", "hover")) %>% 
  kableExtra::scroll_box(width = "100%", height = "400px")

#write.csv(table_DOX24_down_genes, "output/table_DOX24_downreg_genes.csv")

#GO:BP
table_DOX24_down_genes_GOBP <- table_DOX24_down_genes %>% 
  dplyr::filter(source=="GO:BP") %>% 
  dplyr::select(p_value, term_name, intersection_size) %>% 
  dplyr::slice_min(., n=10, order_by=p_value) %>% 
  mutate(log_val = -log10(p_value))

#saveRDS(table_motif1_GOBP_d, "data/table_motif1_GOBP_d.RDS")

table_DOX24_down_genes_GOBP %>% ggplot(., aes(x = log_val, y = reorder(term_name, p_value), col= intersection_size)) +
  geom_point(aes(size = intersection_size)) +
  ggtitle("DOX24T Specific Down DEGs Enriched GO:BP Terms")+
  xlab(expression("-log"[10]~"p-value"))+
  guides(col="none", size= guide_legend(title = "# of intersected \n terms"))+
  ylab("GO:BP term")+
  scale_y_discrete(labels = scales::label_wrap(30))+
  theme_bw()+
  theme(plot.title = element_text(size = rel(1.5), hjust = 0.5),
        axis.title = element_text(size = 15, colour = "black"),
        axis.ticks = element_line(linewidth = 1.5),
        axis.line = element_line(linewidth = 1.5),
        axis.text = element_text(size = 10, colour = "black", angle = 0),
        strip.text = element_text(size = 15, colour = "black", face = "bold"))

#KEGG
table_DOX24_down_genes_KEGG <- table_DOX24_down_genes %>% 
  dplyr::filter(source=="KEGG") %>% 
  dplyr::select(p_value, term_name, intersection_size) %>% 
  dplyr::slice_min(., n=10, order_by=p_value) %>% 
  mutate(log_val = -log10(p_value))

table_DOX24_down_genes_KEGG %>% ggplot(., aes(x = log_val, y = reorder(term_name, p_value), col= intersection_size)) +
  geom_point(aes(size = intersection_size)) +
  ggtitle("DOX24T Specific Down DEGs Enriched KEGG Terms")+
  xlab(expression("-log"[10]~"p-value"))+
  guides(col="none", size= guide_legend(title = "# of intersected \n terms"))+
  ylab("KEGG term")+
  scale_y_discrete(labels = scales::label_wrap(30))+
  theme_bw()+
  theme(plot.title = element_text(size = rel(1.5), hjust = 0.5),
        axis.title = element_text(size = 15, colour = "black"),
        axis.ticks = element_line(linewidth = 1.5),
        axis.line = element_line(linewidth = 1.5),
        axis.text = element_text(size = 10, colour = "black", angle = 0),
        strip.text = element_text(size = 15, colour = "black", face = "bold"))


#####DOX24T share Upregulated DEGs GO KEGG#####
D24Tshare_DEGs_up_mat <- as.matrix(DOX24Tshare_DEGs_GO_up)

DOX_24Tshare_up_dxr_gene <- gost(query = D24Tshare_DEGs_up_mat,
                      organism = "hsapiens",
                      ordered_query = FALSE,
                      measure_underrepresentation = FALSE,
                      evcodes = FALSE,
                      user_threshold = 0.05,
                      custom_bg = all_genes,
                      correction_method = c("fdr"),
                      sources = c("GO:BP", "KEGG"))

DOX_24Tshare_up_gost_genes <- gostplot(DOX_24Tshare_up_dxr_gene, capped = FALSE, interactive = TRUE)
DOX_24Tshare_up_gost_genes

table_DOX24Tshare_up_genes <- DOX_24Tshare_up_dxr_gene$result %>% 
  dplyr::select(c(source, term_id, term_name, intersection_size, term_size, p_value))

table_DOX24Tshare_up_genes %>% 
  mutate_at(.vars = 6, .funs = scales::label_scientific(digits=4)) %>% 
  kableExtra::kable(.,) %>% 
  kableExtra::kable_paper("striped", full_width = FALSE) %>% 
  kableExtra::kable_styling(full_width = FALSE, position = "left", bootstrap_options = c("striped", "hover")) %>% 
  kableExtra::scroll_box(width = "100%", height = "400px")

#write.csv(table_DOX24R_up_genes, "output/table_DOX24R_upreg_genes.csv")

#GO:BP
table_DOX24Tshare_up_genes_GOBP <- table_DOX24Tshare_up_genes %>% 
  dplyr::filter(source=="GO:BP") %>% 
  dplyr::select(p_value, term_name, intersection_size) %>% 
  dplyr::slice_min(., n=10, order_by=p_value) %>% 
  mutate(log_val = -log10(p_value))

#saveRDS(table_motif1_GOBP_d, "data/table_motif1_GOBP_d.RDS")

table_DOX24Tshare_up_genes_GOBP %>% ggplot(., aes(x = log_val, y = reorder(term_name, p_value), col= intersection_size)) +
  geom_point(aes(size = intersection_size)) +
  ggtitle("DOX24T Shared Up DEGs Enriched GO:BP Terms")+
  xlab(expression("-log"[10]~"p-value"))+
  guides(col="none", size= guide_legend(title = "# of intersected \n terms"))+
  ylab("GO:BP term")+
  scale_y_discrete(labels = scales::label_wrap(30))+
  theme_bw()+
  theme(plot.title = element_text(size = rel(1.5), hjust = 0.5),
        axis.title = element_text(size = 15, colour = "black"),
        axis.ticks = element_line(linewidth = 1.5),
        axis.line = element_line(linewidth = 1.5),
        axis.text = element_text(size = 10, colour = "black", angle = 0),
        strip.text = element_text(size = 15, colour = "black", face = "bold"))

#KEGG
table_DOX24Tshare_up_genes_KEGG <- table_DOX24Tshare_up_genes %>% 
  dplyr::filter(source=="KEGG") %>% 
  dplyr::select(p_value, term_name, intersection_size) %>% 
  dplyr::slice_min(., n=10, order_by=p_value) %>% 
  mutate(log_val = -log10(p_value))

table_DOX24Tshare_up_genes_KEGG %>% ggplot(., aes(x = log_val, y = reorder(term_name, p_value), col= intersection_size)) +
  geom_point(aes(size = intersection_size)) +
  ggtitle("DOX24T Shared Up DEGs Enriched KEGG Terms")+
  xlab(expression("-log"[10]~"p-value"))+
  guides(col="none", size= guide_legend(title = "# of intersected \n terms"))+
  ylab("KEGG term")+
  scale_y_discrete(labels = scales::label_wrap(30))+
  theme_bw()+
  theme(plot.title = element_text(size = rel(1.5), hjust = 0.5),
        axis.title = element_text(size = 15, colour = "black"),
        axis.ticks = element_line(linewidth = 1.5),
        axis.line = element_line(linewidth = 1.5),
        axis.text = element_text(size = 10, colour = "black", angle = 0),
        strip.text = element_text(size = 15, colour = "black", face = "bold"))

#####DOX24R Downregulated DEGs GO KEGG#####
D24Tshare_DEGs_down_mat <- as.matrix(DOX24Tshare_DEGs_GO_down)

DOX_24Tshare_down_dxr_gene <- gost(query = D24Tshare_DEGs_down_mat,
                      organism = "hsapiens",
                      ordered_query = FALSE,
                      measure_underrepresentation = FALSE,
                      evcodes = FALSE,
                      user_threshold = 0.05,
                      custom_bg = all_genes,
                      correction_method = c("fdr"),
                      sources = c("GO:BP", "KEGG"))

DOX_24Tshare_down_gost_genes <- gostplot(DOX_24Tshare_down_dxr_gene, capped = FALSE, interactive = TRUE)
DOX_24Tshare_down_gost_genes

table_DOX24Tshare_down_genes <- DOX_24Tshare_down_dxr_gene$result %>% 
  dplyr::select(c(source, term_id, term_name, intersection_size, term_size, p_value))

table_DOX24Tshare_down_genes %>% 
  mutate_at(.vars = 6, .funs = scales::label_scientific(digits=4)) %>% 
  kableExtra::kable(.,) %>% 
  kableExtra::kable_paper("striped", full_width = FALSE) %>% 
  kableExtra::kable_styling(full_width = FALSE, position = "left", bootstrap_options = c("striped", "hover")) %>% 
  kableExtra::scroll_box(width = "100%", height = "400px")

#write.csv(table_DOX24R_down_genes, "output/table_DOX24R_downreg_genes.csv")

#GO:BP
table_DOX24Tshare_down_genes_GOBP <- table_DOX24Tshare_down_genes %>% 
  dplyr::filter(source=="GO:BP") %>% 
  dplyr::select(p_value, term_name, intersection_size) %>% 
  dplyr::slice_min(., n=10, order_by=p_value) %>% 
  mutate(log_val = -log10(p_value))

#saveRDS(table_motif1_GOBP_d, "data/table_motif1_GOBP_d.RDS")

table_DOX24Tshare_down_genes_GOBP %>% ggplot(., aes(x = log_val, y = reorder(term_name, p_value), col= intersection_size)) +
  geom_point(aes(size = intersection_size)) +
  ggtitle("DOX24T Shared Down DEGs Enriched GO:BP Terms")+
  xlab(expression("-log"[10]~"p-value"))+
  guides(col="none", size= guide_legend(title = "# of intersected \n terms"))+
  ylab("GO:BP term")+
  scale_y_discrete(labels = scales::label_wrap(30))+
  theme_bw()+
  theme(plot.title = element_text(size = rel(1.5), hjust = 0.5),
        axis.title = element_text(size = 15, colour = "black"),
        axis.ticks = element_line(linewidth = 1.5),
        axis.line = element_line(linewidth = 1.5),
        axis.text = element_text(size = 10, colour = "black", angle = 0),
        strip.text = element_text(size = 15, colour = "black", face = "bold"))

#KEGG
table_DOX24Tshare_down_genes_KEGG <- table_DOX24Tshare_down_genes %>% 
  dplyr::filter(source=="KEGG") %>% 
  dplyr::select(p_value, term_name, intersection_size) %>% 
  dplyr::slice_min(., n=10, order_by=p_value) %>% 
  mutate(log_val = -log10(p_value))

table_DOX24Tshare_down_genes_KEGG %>% ggplot(., aes(x = log_val, y = reorder(term_name, p_value), col= intersection_size)) +
  geom_point(aes(size = intersection_size)) +
  ggtitle("DOX24T Shared Down DEGs Enriched KEGG Terms")+
  xlab(expression("-log"[10]~"p-value"))+
  guides(col="none", size= guide_legend(title = "# of intersected \n terms"))+
  ylab("KEGG term")+
  scale_y_discrete(labels = scales::label_wrap(30))+
  theme_bw()+
  theme(plot.title = element_text(size = rel(1.5), hjust = 0.5),
        axis.title = element_text(size = 15, colour = "black"),
        axis.ticks = element_line(linewidth = 1.5),
        axis.line = element_line(linewidth = 1.5),
        axis.text = element_text(size = 10, colour = "black", angle = 0),
        strip.text = element_text(size = 15, colour = "black", face = "bold"))
```
###RUVs GO/KEGG for All Conditions
```{r RUVs GO KEGG}
#####DOX24 Genes Specific#####
D24_DEGs_mat_RUV <- as.matrix(DOX24T_DEGs_GO_RUV)
D24_DEGs_vec_RUV <- as.character(DOX24T_DEGs_GO_RUV$Entrez_ID)

#saveRDS(D24_DEGs_mat_RUV, "data/new/RUV/D24_DEGs_mat_RUV.RDS")

DOX_24_dxr_gene_RUV <- gost(query = D24_DEGs_vec_RUV,
                      organism = "hsapiens",
                      ordered_query = FALSE,
                      measure_underrepresentation = FALSE,
                      evcodes = FALSE,
                      user_threshold = 0.05,
                      custom_bg = all_genes,
                      correction_method = c("fdr"),
                      sources = c("GO:BP", "KEGG"))

#check if there are any KEGG terms popping up
unique(DOX_24_dxr_gene_RUV$result$source)
#only GO:BP appearing

DOX_24_gost_genes_RUV <- gostplot(DOX_24_dxr_gene_RUV, capped = FALSE, interactive = TRUE)
DOX_24_gost_genes_RUV

table_DOX24_genes_RUV <- DOX_24_dxr_gene_RUV$result %>% 
  dplyr::select(c(source, term_id, term_name, intersection_size, term_size, p_value))

table_DOX24_genes_RUV %>% 
  mutate_at(.vars = 6, .funs = scales::label_scientific(digits=4)) %>% 
  kableExtra::kable(.,) %>% 
  kableExtra::kable_paper("striped", full_width = FALSE) %>% 
  kableExtra::kable_styling(full_width = FALSE, position = "left", bootstrap_options = c("striped", "hover")) %>% 
  kableExtra::scroll_box(width = "100%", height = "400px")


#GO:BP
table_DOX24_genes_GOBP_RUV <- table_DOX24_genes_RUV %>% 
  dplyr::filter(source=="GO:BP") %>% 
  dplyr::select(p_value, term_name, intersection_size) %>% 
  dplyr::slice_min(., n=10, order_by=p_value) %>% 
  mutate(log_val = -log10(p_value))


table_DOX24_genes_GOBP_RUV %>% ggplot(., aes(x = log_val, y = reorder(term_name, p_value), col= intersection_size)) +
  geom_point(aes(size = intersection_size)) +
  ggtitle("DOX24T Specific DEGs Enriched GO:BP Terms RUVs")+
  xlab(expression("-log"[10]~"p-value"))+
  guides(col="none", size= guide_legend(title = "# of intersected \n terms"))+
  ylab("GO:BP term")+
  scale_y_discrete(labels = scales::label_wrap(30))+
  theme_bw()+
  theme(plot.title = element_text(size = rel(1.5), hjust = 0.5),
        axis.title = element_text(size = 15, colour = "black"),
        axis.ticks = element_line(linewidth = 1.5),
        axis.line = element_line(linewidth = 1.5),
        axis.text = element_text(size = 10, colour = "black", angle = 0),
        strip.text = element_text(size = 15, colour = "black", face = "bold"))

# #KEGG - no KEGG terms popped up for this one?
# table_DOX24_genes_KEGG_RUV <- table_DOX24_genes_RUV %>% 
#   dplyr::filter(source=="KEGG") %>% 
#   dplyr::select(p_value, term_name, intersection_size) %>% 
#   dplyr::slice_min(., n=10, order_by=p_value) %>% 
#   mutate(log_val = -log10(p_value))
# 
# table_DOX24_genes_KEGG_RUV %>% ggplot(., aes(x = log_val, y = reorder(term_name, p_value), col= intersection_size)) +
#   geom_point(aes(size = intersection_size)) +
#   ggtitle("DOX24T Specific DEGs Enriched KEGG Terms RUVs")+
#   xlab(expression("-log"[10]~"p-value"))+
#   guides(col="none", size= guide_legend(title = "# of intersected \n terms"))+
#   ylab("KEGG term")+
#   scale_y_discrete(labels = scales::label_wrap(30))+
#   theme_bw()+
#   theme(plot.title = element_text(size = rel(1.5), hjust = 0.5),
#         axis.title = element_text(size = 15, colour = "black"),
#         axis.ticks = element_line(linewidth = 1.5),
#         axis.line = element_line(linewidth = 1.5),
#         axis.text = element_text(size = 10, colour = "black", angle = 0),
#         strip.text = element_text(size = 15, colour = "black", face = "bold"))


#####DOX24T shared DEGs GO KEGG#####
D24Tshare_DEGs_mat_RUV <- as.matrix(DOX24T_share_DEGs_GO_plot_RUV)

DOX_24Tshare_dxr_gene_RUV <- gost(query = D24Tshare_DEGs_mat_RUV,
                      organism = "hsapiens",
                      ordered_query = FALSE,
                      measure_underrepresentation = FALSE,
                      evcodes = FALSE,
                      user_threshold = 0.05,
                      custom_bg = all_genes,
                      correction_method = c("fdr"),
                      sources = c("GO:BP", "KEGG"))

#check if there are any KEGG terms popping up
unique(DOX_24Tshare_dxr_gene_RUV$result$source)
#only GO:BP appearing

DOX_24Tshare_gost_genes_RUV <- 
  gostplot(DOX_24Tshare_dxr_gene_RUV, capped = FALSE, interactive = TRUE)
DOX_24Tshare_gost_genes_RUV

table_DOX24Tshare_genes_RUV <- DOX_24Tshare_dxr_gene_RUV$result %>% 
  dplyr::select(c(source, term_id, term_name, intersection_size, term_size, p_value))

table_DOX24Tshare_genes_RUV %>% 
  mutate_at(.vars = 6, .funs = scales::label_scientific(digits=4)) %>% 
  kableExtra::kable(.,) %>% 
  kableExtra::kable_paper("striped", full_width = FALSE) %>% 
  kableExtra::kable_styling(full_width = FALSE, position = "left", bootstrap_options = c("striped", "hover")) %>% 
  kableExtra::scroll_box(width = "100%", height = "400px")

#GO:BP
table_DOX24Tshare_genes_GOBP_RUV <- table_DOX24Tshare_genes_RUV %>% 
  dplyr::filter(source=="GO:BP") %>% 
  dplyr::select(p_value, term_name, intersection_size) %>% 
  dplyr::slice_min(., n=10, order_by=p_value) %>% 
  mutate(log_val = -log10(p_value))

table_DOX24Tshare_genes_GOBP_RUV %>% ggplot(., aes(x = log_val, y = reorder(term_name, p_value), col= intersection_size)) +
  geom_point(aes(size = intersection_size)) +
  ggtitle("DOX24T Shared DEGs Enriched GO:BP Terms RUVs")+
  xlab(expression("-log"[10]~"p-value"))+
  guides(col="none", size= guide_legend(title = "# of intersected \n terms"))+
  ylab("GO:BP term")+
  scale_y_discrete(labels = scales::label_wrap(30))+
  theme_bw()+
  theme(plot.title = element_text(size = rel(1.5), hjust = 0.5),
        axis.title = element_text(size = 15, colour = "black"),
        axis.ticks = element_line(linewidth = 1.5),
        axis.line = element_line(linewidth = 1.5),
        axis.text = element_text(size = 10, colour = "black", angle = 0),
        strip.text = element_text(size = 15, colour = "black", face = "bold"))

# #KEGG
# table_DOX24Tshare_genes_KEGG_RUV <- table_DOX24Tshare_genes_RUV %>% 
#   dplyr::filter(source=="KEGG") %>% 
#   dplyr::select(p_value, term_name, intersection_size) %>% 
#   dplyr::slice_min(., n=10, order_by=p_value) %>% 
#   mutate(log_val = -log10(p_value))
# 
# table_DOX24Tshare_genes_KEGG_RUV %>% ggplot(., aes(x = log_val, y = reorder(term_name, p_value), col= intersection_size)) +
#   geom_point(aes(size = intersection_size)) +
#   ggtitle("DOX24T Shared DEGs Enriched KEGG Terms RUVs")+
#   xlab(expression("-log"[10]~"p-value"))+
#   guides(col="none", size= guide_legend(title = "# of intersected \n terms"))+
#   ylab("KEGG term")+
#   scale_y_discrete(labels = scales::label_wrap(30))+
#   theme_bw()+
#   theme(plot.title = element_text(size = rel(1.5), hjust = 0.5),
#         axis.title = element_text(size = 15, colour = "black"),
#         axis.ticks = element_line(linewidth = 1.5),
#         axis.line = element_line(linewidth = 1.5),
#         axis.text = element_text(size = 10, colour = "black", angle = 0),
#         strip.text = element_text(size = 15, colour = "black", face = "bold"))

#####DOX24R DEGs GO KEGG#####
D24R_DEGs_mat_RUV <- as.matrix(DOX24R_DEGs_GO_RUV)

DOX_24R_dxr_gene_RUV <- gost(query = D24R_DEGs_mat_RUV,
                      organism = "hsapiens",
                      ordered_query = FALSE,
                      measure_underrepresentation = FALSE,
                      evcodes = FALSE,
                      user_threshold = 0.05,
                      custom_bg = all_genes,
                      correction_method = c("fdr"),
                      sources = c("GO:BP", "KEGG"))

#check if there are any KEGG terms popping up
unique(DOX_24R_dxr_gene_RUV$result$source)
#only GO:BP appearing

DOX_24R_gost_genes_RUV <- 
  gostplot(DOX_24R_dxr_gene_RUV, capped = FALSE, interactive = TRUE)
DOX_24R_gost_genes_RUV

table_DOX24R_genes_RUV <- DOX_24R_dxr_gene_RUV$result %>% 
  dplyr::select(c(source, term_id, term_name, intersection_size, term_size, p_value))

table_DOX24R_genes_RUV %>% 
  mutate_at(.vars = 6, .funs = scales::label_scientific(digits=4)) %>% 
  kableExtra::kable(.,) %>% 
  kableExtra::kable_paper("striped", full_width = FALSE) %>% 
  kableExtra::kable_styling(full_width = FALSE, position = "left", bootstrap_options = c("striped", "hover")) %>% 
  kableExtra::scroll_box(width = "100%", height = "400px")

#GO:BP
table_DOX24R_genes_GOBP_RUV <- table_DOX24R_genes_RUV %>% 
  dplyr::filter(source=="GO:BP") %>% 
  dplyr::select(p_value, term_name, intersection_size) %>% 
  dplyr::slice_min(., n=10, order_by=p_value) %>% 
  mutate(log_val = -log10(p_value))

table_DOX24R_genes_GOBP_RUV %>% ggplot(., aes(x = log_val, y = reorder(term_name, p_value), col= intersection_size)) +
  geom_point(aes(size = intersection_size)) +
  ggtitle("DOX24R Specific DEGs Enriched GO:BP Terms RUVs")+
  xlab(expression("-log"[10]~"p-value"))+
  guides(col="none", size= guide_legend(title = "# of intersected \n terms"))+
  ylab("GO:BP term")+
  scale_y_discrete(labels = scales::label_wrap(30))+
  theme_bw()+
  theme(plot.title = element_text(size = rel(1.5), hjust = 0.5),
        axis.title = element_text(size = 15, colour = "black"),
        axis.ticks = element_line(linewidth = 1.5),
        axis.line = element_line(linewidth = 1.5),
        axis.text = element_text(size = 10, colour = "black", angle = 0),
        strip.text = element_text(size = 15, colour = "black", face = "bold"))

# #KEGG
# table_DOX24R_genes_KEGG_RUV <- table_DOX24R_genes_RUV %>% 
#   dplyr::filter(source=="KEGG") %>% 
#   dplyr::select(p_value, term_name, intersection_size) %>% 
#   dplyr::slice_min(., n=10, order_by=p_value) %>% 
#   mutate(log_val = -log10(p_value))
# 
# table_DOX24R_genes_KEGG_RUV %>% ggplot(., aes(x = log_val, y = reorder(term_name, p_value), col= intersection_size)) +
#   geom_point(aes(size = intersection_size)) +
#   ggtitle("DOX24R DEGs Enriched KEGG Terms RUVs")+
#   xlab(expression("-log"[10]~"p-value"))+
#   guides(col="none", size= guide_legend(title = "# of intersected \n terms"))+
#   ylab("KEGG term")+
#   scale_y_discrete(labels = scales::label_wrap(30))+
#   theme_bw()+
#   theme(plot.title = element_text(size = rel(1.5), hjust = 0.5),
#         axis.title = element_text(size = 15, colour = "black"),
#         axis.ticks = element_line(linewidth = 1.5),
#         axis.line = element_line(linewidth = 1.5),
#         axis.text = element_text(size = 10, colour = "black", angle = 0),
#         strip.text = element_text(size = 15, colour = "black", face = "bold"))

####DOX144R DEGs GO KEGG#####
D144R_DEGs_mat_RUV <- as.matrix(DOX144R_DEGs_GO_RUV)

DOX_144R_dxr_gene_RUV <- gost(query = D144R_DEGs_mat_RUV,
                      organism = "hsapiens",
                      ordered_query = FALSE,
                      measure_underrepresentation = FALSE,
                      evcodes = FALSE,
                      user_threshold = 0.05,
                      custom_bg = all_genes,
                      correction_method = c("fdr"),
                      sources = c("GO:BP", "KEGG"))

#check if there are any KEGG terms popping up
unique(DOX_144R_dxr_gene_RUV$result$source)
#GO:BP and KEGG appearing here

DOX_144R_gost_genes_RUV <- 
  gostplot(DOX_144R_dxr_gene_RUV, capped = FALSE, interactive = TRUE)
DOX_144R_gost_genes_RUV

table_DOX144R_genes_RUV <- DOX_144R_dxr_gene_RUV$result %>%
  dplyr::select(c(source, term_id, term_name, intersection_size, term_size, p_value))

table_DOX144R_genes_RUV %>%
  mutate_at(.vars = 6, .funs = scales::label_scientific(digits=4)) %>%
  kableExtra::kable(.,) %>%
  kableExtra::kable_paper("striped", full_width = FALSE) %>%
  kableExtra::kable_styling(full_width = FALSE, position = "left", bootstrap_options = c("striped", "hover")) %>%
  kableExtra::scroll_box(width = "100%", height = "400px")

#GO:BP
table_DOX144R_genes_GOBP_RUV <- table_DOX144R_genes_RUV %>%
  dplyr::filter(source=="GO:BP") %>%
  dplyr::select(p_value, term_name, intersection_size) %>%
  dplyr::slice_min(., n=10, order_by=p_value) %>%
  mutate(log_val = -log10(p_value))

table_DOX144R_genes_GOBP_RUV %>% ggplot(., aes(x = log_val, y = reorder(term_name, p_value), col= intersection_size)) +
  geom_point(aes(size = intersection_size)) +
  ggtitle("DOX144R Specific DEGs Enriched GO:BP Terms RUVs")+
  xlab(expression("-log"[10]~"p-value"))+
  guides(col="none", size= guide_legend(title = "# of intersected \n terms"))+
  ylab("GO:BP term")+
  scale_y_discrete(labels = scales::label_wrap(30))+
  theme_bw()+
  theme(plot.title = element_text(size = rel(1.5), hjust = 0.5),
        axis.title = element_text(size = 15, colour = "black"),
        axis.ticks = element_line(linewidth = 1.5),
        axis.line = element_line(linewidth = 1.5),
        axis.text = element_text(size = 10, colour = "black", angle = 0),
        strip.text = element_text(size = 15, colour = "black", face = "bold"))

#KEGG
table_DOX144R_genes_KEGG_RUV <- table_DOX144R_genes_RUV %>%
  dplyr::filter(source=="KEGG") %>%
  dplyr::select(p_value, term_name, intersection_size) %>%
  dplyr::slice_min(., n=10, order_by=p_value) %>%
  mutate(log_val = -log10(p_value))

table_DOX144R_genes_KEGG_RUV %>% ggplot(., aes(x = log_val, y = reorder(term_name, p_value), col= intersection_size)) +
  geom_point(aes(size = intersection_size)) +
  ggtitle("DOX144R DEGs Enriched KEGG Terms RUVs")+
  xlab(expression("-log"[10]~"p-value"))+
  guides(col="none", size= guide_legend(title = "# of intersected \n terms"))+
  ylab("KEGG term")+
  scale_y_discrete(labels = scales::label_wrap(30))+
  theme_bw()+
  theme(plot.title = element_text(size = rel(1.5), hjust = 0.5),
        axis.title = element_text(size = 15, colour = "black"),
        axis.ticks = element_line(linewidth = 1.5),
        axis.line = element_line(linewidth = 1.5),
        axis.text = element_text(size = 10, colour = "black", angle = 0),
        strip.text = element_text(size = 15, colour = "black", face = "bold"))

#####DOX144R shared DEGs GO KEGG#####
D144Rshare_DEGs_mat_RUV <- as.matrix(DOX144Rshare_DEGs_GO_plot_RUV)

DOX_144Rshare_dxr_gene_RUV <- gost(query = D144Rshare_DEGs_mat_RUV,
                      organism = "hsapiens",
                      ordered_query = FALSE,
                      measure_underrepresentation = FALSE,
                      evcodes = FALSE,
                      user_threshold = 0.05,
                      custom_bg = all_genes,
                      correction_method = c("fdr"),
                      sources = c("GO:BP", "KEGG"))

#check if any KEGG terms are appearing
unique(DOX_144Rshare_dxr_gene_RUV$result$source)
#only GO:BP appearing here

DOX_144Rshare_gost_genes_RUV <- 
  gostplot(DOX_144Rshare_dxr_gene_RUV, capped = FALSE, interactive = TRUE)
DOX_144Rshare_gost_genes_RUV

table_DOX144Rshare_genes_RUV <- DOX_144Rshare_dxr_gene_RUV$result %>% 
  dplyr::select(c(source, term_id, term_name, intersection_size, term_size, p_value))

table_DOX144Rshare_genes_RUV %>% 
  mutate_at(.vars = 6, .funs = scales::label_scientific(digits=4)) %>% 
  kableExtra::kable(.,) %>% 
  kableExtra::kable_paper("striped", full_width = FALSE) %>% 
  kableExtra::kable_styling(full_width = FALSE, position = "left", bootstrap_options = c("striped", "hover")) %>% 
  kableExtra::scroll_box(width = "100%", height = "400px")

#GO:BP
table_DOX144Rshare_genes_GOBP_RUV <- table_DOX144Rshare_genes_RUV %>% 
  dplyr::filter(source=="GO:BP") %>% 
  dplyr::select(p_value, term_name, intersection_size) %>% 
  dplyr::slice_min(., n=10, order_by=p_value) %>% 
  mutate(log_val = -log10(p_value))

table_DOX144Rshare_genes_GOBP_RUV %>% ggplot(., aes(x = log_val, y = reorder(term_name, p_value), col= intersection_size)) +
  geom_point(aes(size = intersection_size)) +
  ggtitle("DOX144R Shared DEGs Enriched GO:BP Terms RUVs")+
  xlab(expression("-log"[10]~"p-value"))+
  guides(col="none", size= guide_legend(title = "# of intersected \n terms"))+
  ylab("GO:BP term")+
  scale_y_discrete(labels = scales::label_wrap(30))+
  theme_bw()+
  theme(plot.title = element_text(size = rel(1.5), hjust = 0.5),
        axis.title = element_text(size = 15, colour = "black"),
        axis.ticks = element_line(linewidth = 1.5),
        axis.line = element_line(linewidth = 1.5),
        axis.text = element_text(size = 10, colour = "black", angle = 0),
        strip.text = element_text(size = 15, colour = "black", face = "bold"))

# #KEGG
# table_DOX144Rshare_genes_KEGG_RUV <- table_DOX144Rshare_genes_RUV %>% 
#   dplyr::filter(source=="KEGG") %>% 
#   dplyr::select(p_value, term_name, intersection_size) %>% 
#   dplyr::slice_min(., n=10, order_by=p_value) %>% 
#   mutate(log_val = -log10(p_value))
# 
# table_DOX144Rshare_genes_KEGG_RUV %>% ggplot(., aes(x = log_val, y = reorder(term_name, p_value), col= intersection_size)) +
#   geom_point(aes(size = intersection_size)) +
#   ggtitle("DOX144R Shared DEGs Enriched KEGG Terms RUVs")+
#   xlab(expression("-log"[10]~"p-value"))+
#   guides(col="none", size= guide_legend(title = "# of intersected \n terms"))+
#   ylab("KEGG term")+
#   scale_y_discrete(labels = scales::label_wrap(30))+
#   theme_bw()+
#   theme(plot.title = element_text(size = rel(1.5), hjust = 0.5),
#         axis.title = element_text(size = 15, colour = "black"),
#         axis.ticks = element_line(linewidth = 1.5),
#         axis.line = element_line(linewidth = 1.5),
#         axis.text = element_text(size = 10, colour = "black", angle = 0),
#         strip.text = element_text(size = 15, colour = "black", face = "bold"))
```
#Plot DDR Genes logFC Heatmap RUVs k=1 
```{r RUVs DDR Genes logFC, fig.height=14, fig.width=8}
#DDR Gene Expression Heatmap — DOX Over Recovery Time (68 genes, with categories)
#now add in the RUV corrected data and see if this makes a difference at all!

# Load libraries
# library(circlize)
# library(grid)
# library(reshape2)

# Load DEG files
load_deg <- function(path) read.csv(path)

DOX_24T_R <- load_deg("data/new/DEGs/Toptable_RUV_24T_final.csv")
DOX_24R_R <- load_deg("data/new/DEGs/Toptable_RUV_24R_final.csv")
DOX_144R_R <- load_deg("data/new/DEGs/Toptable_RUV_144R_final.csv")

# Final Entrez IDs and categories (68 genes)
#no need to change the name of this as it's the same
entrez_category_DDR <- tribble(
  ~ENTREZID, ~Category,
  317, "Apoptosis", 355, "Apoptosis", 581, "Apoptosis", 637, "Apoptosis",
  836, "Apoptosis", 841, "Apoptosis", 842, "Apoptosis", 27113, "Apoptosis",
  5366, "Apoptosis", 54205, "Apoptosis", 55367, "Apoptosis", 8795, "Apoptosis",
  1026, "Cell Cycle / Checkpoint", 1027, "Cell Cycle / Checkpoint", 595, "Cell Cycle / Checkpoint",
  894, "Cell Cycle / Checkpoint", 896, "Cell Cycle / Checkpoint", 898, "Cell Cycle / Checkpoint",
  9133, "Cell Cycle / Checkpoint", 9134, "Cell Cycle / Checkpoint", 891, "Cell Cycle / Checkpoint",
  983, "Cell Cycle / Checkpoint", 1017, "Cell Cycle / Checkpoint", 1019, "Cell Cycle / Checkpoint",
  1020, "Cell Cycle / Checkpoint", 1021, "Cell Cycle / Checkpoint", 993, "Cell Cycle / Checkpoint",
  995, "Cell Cycle / Checkpoint", 1869, "Cell Cycle / Checkpoint", 4609, "Cell Cycle / Checkpoint",
  5925, "Cell Cycle / Checkpoint", 9874, "Cell Cycle / Checkpoint", 11011, "Cell Cycle / Checkpoint",
  1385, "Cell Cycle / Checkpoint",
  472, "Damage Sensors / Signal Transducers", 545, "Damage Sensors / Signal Transducers",
  5591, "Damage Sensors / Signal Transducers", 5810, "Damage Sensors / Signal Transducers",
  5883, "Damage Sensors / Signal Transducers", 5884, "Damage Sensors / Signal Transducers",
  6118, "Damage Sensors / Signal Transducers", 4361, "Damage Sensors / Signal Transducers",
  10111, "Damage Sensors / Signal Transducers", 4683, "Damage Sensors / Signal Transducers",
  84126, "Damage Sensors / Signal Transducers", 3014, "Damage Sensors / Signal Transducers",
  672, "DNA Repair", 2177, "DNA Repair", 5888, "DNA Repair", 5893, "DNA Repair",
  1647, "DNA Repair", 4616, "DNA Repair", 10912, "DNA Repair", 1111, "DNA Repair",
  11200, "DNA Repair", 1643, "DNA Repair", 8243, "DNA Repair", 5981, "DNA Repair",
  7157, "p53 Regulators / Targets", 4193, "p53 Regulators / Targets", 5371, "p53 Regulators / Targets",
  27244, "p53 Regulators / Targets", 50484, "p53 Regulators / Targets",
  207, "Miscellaneous / Broad", 25, "Miscellaneous / Broad"
)

entrez_ids_DDR_R <- entrez_category_DDR$ENTREZID

# saveRDS(entrez_ids_DDR_R, "data/new/RUV/DDR_genes_entrezid.RDS")

# Extract relevant DEG values
extract_data_DDR_R <- function(df, name) {
  df %>%
    filter(Entrez_ID %in% entrez_ids_DDR_R) %>%
    mutate(
      Gene = mapIds(org.Hs.eg.db, as.character(Entrez_ID),
                    column = "SYMBOL", keytype = "ENTREZID", multiVals = "first"),
      Condition = name,
      Signif = ifelse(adj.P.Val < 0.05, "*", "")
    )
}

# DEG list
deg_list_RUV <- list("DOX_24T" = DOX_24T_R, 
                 "DOX_24R" = DOX_24R_R, 
                 "DOX_144R" = DOX_144R_R
)

# Combine all DEGs and annotate
all_data_DDR_RUV <- bind_rows(mapply(extract_data_DDR_R, deg_list_RUV, names(deg_list_RUV), SIMPLIFY = FALSE)) %>%
  left_join(entrez_category_DDR, by = c("Entrez_ID" = "ENTREZID"))

# DDR_genesymbols_list_RUV <- all_data_DDR_RUV$Gene
# write.csv(DDR_genesymbols_list_RUV, "data/new/RUV/DDR_Genes_list_RUV.csv")
# saveRDS(DDR_genesymbols_list_RUV, "data/new/RUV/DDR_Genes_list_RUV.RDS")

# Create matrices
logFC_matddr_R <- acast(all_data_DDR_RUV, Gene ~ Condition, value.var = "logFC")
signif_matddr_R <- acast(all_data_DDR_RUV, Gene ~ Condition, value.var = "Signif")

# Set desired order
desired_order <- c("DOX_24T",
                   "DOX_24R",
                   "DOX_144R")

logFC_mat_DDR_RUV <- logFC_matddr_R[, desired_order, drop = FALSE]
signif_mat_DDR_RUV <- signif_matddr_R[, desired_order, drop = FALSE]

# Column annotation
meta_DDR_R <- str_split_fixed(colnames(logFC_mat_DDR_RUV), "_", 2)
col_annot <- HeatmapAnnotation(
  Drug = meta_DDR_R[, 1],
  Time = meta_DDR_R[, 2],
  col = list(
    Drug = c("DOX" = "#499FBD"),
    Time = c("24T" = "#238B45", 
             "24R" = "#74C476", 
             "144R" = "#C7E9C0")
  ),
  annotation_height = unit(c(1, 1, 1), "cm")
)

# Row annotation
gene_order_df_DDR_RUV <- all_data_DDR_RUV %>%
  distinct(Gene, Category) %>%
  arrange(factor(Category, levels = sort(unique(entrez_category_DDR$Category))), Gene)

ordered_genes_DDR_RUV <- gene_order_df_DDR_RUV$Gene
logFC_mat_DDR_RUV <- logFC_mat_DDR_RUV[ordered_genes_DDR_RUV, ]
signif_mat_DDR_RUV <- signif_mat_DDR_RUV[ordered_genes_DDR_RUV, ]

category_levels <- sort(unique(entrez_category_DDR$Category))

category_colors_DDR <- setNames(
  c("darkorange", "steelblue", "darkgreen", "firebrick", "gold", "mediumpurple"),
  category_levels
)

ha_left_DDR_RUV <- rowAnnotation(
  Category = gene_order_df_DDR_RUV$Category,
  col = list(Category = category_colors_DDR),
  annotation_name_side = "top"
)

# Final Heatmap
Heatmap(logFC_mat_DDR_RUV,
        name = "logFC",
        top_annotation = col_annot,
        left_annotation = ha_left_DDR_RUV,
        cluster_columns = FALSE,
        cluster_rows = FALSE,
        show_row_names = TRUE,
        show_column_names = FALSE,
        row_names_gp = gpar(fontsize = 10),
        column_title = "DDR Gene Expression Response (n = 68)\n DOX Recovery (RUVs Corrected)",
        column_title_gp = gpar(fontsize = 14, fontface = "bold"),
        cell_fun = function(j, i, x, y, width, height, fill) {
          grid.text(signif_mat_DDR[i, j], x, y, gp = gpar(fontsize = 9))
        }
)
```

##LogFC of DDR Gene Set after RUVs Correction
```{r logFC DDR Boxplots RUVs Genes}
library(car)

#get an overall idea of the response occurring in all genes with logFC across time
#start with the logFC and then do the abs logFC

####data setup####
#Read DNA Damage Response Gene List

#this had an extra column that was unncessesary
# DNA_damage <- read.csv("data/new/RUV/DDR_Genes_list_RUV.csv", stringsAsFactors = FALSE) %>% 
#   dplyr::select(-(X))
#   
# names(DNA_damage)[names(DNA_damage) == "x"] <- "Symbol"
#   
#saveRDS(DNA_damage, "data/new/RUV/DNA_damage_genesymbols.RDS")

#this is the final processed version with a single list of symbols with col name
DNA_damage <- readRDS("data/new/RUV/DNA_damage_genesymbols.RDS")

#Convert gene symbols to Entrez IDs
DNA_damage <- DNA_damage %>%
  mutate(Entrez_ID = mapIds(org.Hs.eg.db,
                            keys = Symbol,
                            column = "ENTREZID",
                            keytype = "SYMBOL",
                            multiVals = "first"))

DNA_damage_genes <- na.omit(DNA_damage$Entrez_ID)

time_colors <- c("24T" = "#238B45",
                 "24R" = "#74C476",
                 "144R" = "#C7E9C0")

#load in my DEGs which I'll use to create a combined toptable
load_deg <- function(path) read.csv(path)

DOX_24T_R <- load_deg("data/new/DEGs/Toptable_RUV_24T_final.csv")
DOX_24R_R <- load_deg("data/new/DEGs/Toptable_RUV_24R_final.csv")
DOX_144R_R <- load_deg("data/new/DEGs/Toptable_RUV_144R_final.csv")

all_toptables_RUV <- bind_rows(
  DOX_24T_R %>% mutate(Drug = "DOX", Timepoint = "24T"),
  DOX_24R_R %>% mutate(Drug = "DOX", Timepoint = "24R"),
  DOX_144R_R %>% mutate(Drug = "DOX", Timepoint = "144R"),
)


filtered_toptables_RUV <- all_toptables_RUV %>%
  filter(Entrez_ID %in% DNA_damage_genes)

filtered_toptables_RUV <- filtered_toptables_RUV %>%
  mutate(
    Drug = factor(Drug, levels = c("DOX")),
    Timepoint = factor(Timepoint, levels = c("24T", "24R", "144R"), 
                       labels = c("Timepoint: 24T", "Timepoint: 24R", "Timepoint: 144R"))
  )

levene_results_RUV <- filtered_toptables_RUV %>%
  group_by(Timepoint) %>%
  summarise(p_value = leveneTest(logFC ~ Timepoint, data = .)$`Pr(>F)`[1], .groups = "drop") %>%
  mutate(significance = ifelse(p_value < 0.05, "*", ""))  # Use p < 0.05 threshold for stars

# **🔹 Determine Y-axis position for Stars**
star_positions <- filtered_toptables_RUV %>%
  group_by(Timepoint,Drug) %>%
  summarise(y_pos = max(logFC, na.rm = TRUE) + 0.5, .groups = "drop") %>%
  group_by(Timepoint) %>%
  summarise(y_pos = max(y_pos), .groups = "drop")

# **🔹 Merge Levene test results with Y positions**
levene_results_plot_RUV <- levene_results_RUV %>%
  left_join(star_positions, by = c("Timepoint")) %>%
  mutate(x_position = 1.5)

ggplot(filtered_toptables_RUV, aes(x = Drug, y = logFC, fill = Timepoint)) +
  geom_violin(trim = FALSE, alpha = 0.5) +  # Violin plot for logFC
  geom_boxplot(width = 0.1, outlier.shape = NA, color = "black", alpha = 0.5) +  # Add boxplot inside violin
  scale_fill_manual(values = c(
    "Timepoint: 24T" = "#238B45",
    "Timepoint: 24R" = "#74C476",
    "Timepoint: 144R" = "#C7E9C0")) +  
  facet_grid(Drug ~ Timepoint) +  
  geom_text(
    data = levene_results_plot_RUV %>% filter(significance == "*"),  # Only plot significant comparisons
    aes(x = x_position, y = y_pos, label = significance), 
    size = 6, fontface = "bold", color = "black", inherit.aes = FALSE
  ) +
  theme_bw() +
  xlab("") +
  ylab("Log Fold Change") +  
  ggtitle("LogFC Distribution for DDR Genes") +
  theme(
    plot.title = element_text(size = rel(1.5), hjust = 0.5),
    axis.title = element_text(size = 15, color = "black"),
    axis.line = element_line(linewidth = 1.5),
    strip.background = element_rect(fill = "gray"),  
    strip.text = element_text(size = 12, color = "black", face = "bold"),  
    axis.text.x = element_text(size = 8, color = "black", angle = 0)
  )

```
```{r DDR RUVs Genes Proportion}
# Read DNA Damage Genes List
# DNA_damage
# 
# # Convert gene symbols to Entrez IDs
# DNA_damage <- DNA_damage %>%
#   mutate(Entrez_ID = mapIds(org.Hs.eg.db,
#                             keys = Symbol,
#                             column = "ENTREZID",
#                             keytype = "SYMBOL",
#                             multiVals = "first"))
# 
# # Extract DNA damage gene Entrez IDs
# DNA_damage_genes <- na.omit(DNA_damage$Entrez_ID)
# total_DNA_damage_genes <- length(DNA_damage_genes)  # Total number of DNA damage genes
# 
# # Define DEG lists (with significant ones only)
# DOX_DEGs <- list(
#   "DOX_24T" = DEG1_RUV, "DOX_24R" = DEG2_RUV, "DOX_144R" = DEG3_RUV
# )
# 
# # Function to calculate the presence of DNA damage genes in DEGs 
# calculate_proportion_DDR <- function(deg_list, drug_name) {
#   data.frame(
#     Sample = names(deg_list),
#     Drug = drug_name,
#     DNA_Damage_DEGs = sapply(deg_list, function(ids) sum(ids %in% DNA_damage_genes)),  # DEGs present in DNA damage set
#     Non_DNA_Damage_DEGs = sapply(deg_list, function(ids) total_DNA_damage_genes - sum(ids %in% DNA_damage_genes))  # Remaining DNA damage genes
#   ) %>%
#     mutate(
#       Yes_Proportion = (DNA_Damage_DEGs / total_DNA_damage_genes) * 100,  # Percentage of DEGs in DNA damage genes
#       No_Proportion = (Non_DNA_Damage_DEGs / total_DNA_damage_genes) * 100  # Remaining DNA damage genes as No
#     )
# }
# 
# # Calculate proportions for CX-5461 and DOX
# DOX_proportion <- calculate_proportion_DDR(DOX_DEGs, "DOX")
# 
# # Convert to long format for stacked bar plot
# proportion_long <- DOX_proportion %>%
#   dplyr::select(Sample, Drug, Yes_Proportion, No_Proportion) %>%
#   pivot_longer(cols = c(Yes_Proportion, No_Proportion), names_to = "Category", values_to = "Percentage") %>%
#   mutate(Category = ifelse(Category == "Yes_Proportion", "Yes", "No"))
# 
# # **Ensure correct order of samples on X-axis**
# sample_order <- c(
#   "DOX_24T", "DOX_24R", "DOX_144R"
# )
# proportion_long$Sample <- factor(proportion_long$Sample, levels = sample_order, ordered = TRUE)
# 
# # **Fix: Ensure "Yes" is on top and "No" is at the bottom in stacked bars**
# proportion_long$Category <- factor(proportion_long$Category, levels = c("Yes", "No"))  # Ensures "Yes" on top, "No" at bottom
# 
# # **Perform Chi-Square Test for DOX across timepoints**
# chi_square_results <- data.frame(Sample = character(), P_Value = numeric())
# 
# for (i in seq(1, 6)) {  #comparing across timepoints
#   tx24_sample <- sample_order[i] #DOX24T
#   rec24_sample <- sample_order[i + 6]   #DOX24R
#   rec144_sample <- sample_order[i + 12] #DOX144R
#   
#   tx24_data <- filter(DOX_proportion, Sample == tx24_sample)
#   rec24_data <- filter(DOX_proportion, Sample == rec24_sample)
#   rec144_data <- filter(DOX_proportion, Sample == rec144_sample)
#   
#   # Construct contingency table for Chi-Square test
#   contingency_table <- matrix(
#     c(tx24_data$DNA_Damage_DEGs, tx24_data$Non_DNA_Damage_DEGs,
#       rec24_data$DNA_Damage_DEGs, rec24_data$Non_DNA_Damage_DEGs,
#       rec144_data$DNA_Damage_DEGs, rec144_data$Non_DNA_Damage_DEGs),
#     nrow = 3, byrow = TRUE
#   )
#   
#   # Run Chi-Square Test
#   test_result <- chisq.test(contingency_table)
#   p_value <- test_result$p.value
#   
#   # Store results
#   chi_square_results <- rbind(chi_square_results, data.frame(Sample = tx24_sample, P_Value = p_value))
# }
# 
# # Add significance stars
# chi_square_results$Significant <- ifelse(chi_square_results$P_Value < 0.05, "*", "")
# 
# # Merge Chi-Square results
# proportion_long <- left_join(proportion_long, chi_square_results, by = "Sample")
# 
# # **Save output**
# write.csv(proportion_long, "C:/Work/Postdoc_UTMB/CX-5461 Project/Transcriptome literatures/lit2/Proportion_Stacked_DNA_Damage_DEGs_with_ChiSquare.csv", row.names = FALSE)
# 
# 
# # Define correct factor orders for samples
# sample_order <- c(
#   "CX_0.1_3", "CX_0.1_24", "CX_0.1_48", "CX_0.5_3", "CX_0.5_24", "CX_0.5_48",
#   "DOX_0.1_3", "DOX_0.1_24", "DOX_0.1_48", "DOX_0.5_3", "DOX_0.5_24", "DOX_0.5_48"
# )
# 
# # Reapply factor levels for correct order in both proportion_data and proportion_long
# proportion_data$Sample <- factor(proportion_data$Sample, levels = sample_order, ordered = TRUE)
# proportion_long$Sample <- factor(proportion_long$Sample, levels = sample_order, ordered = TRUE)
# 
# # **Fix: Ensure "Yes" is on top and "No" is at the bottom in stacked bars**
# proportion_long$Category <- factor(proportion_long$Category, levels = c("Yes", "No")
```

##LogFC of DDR Genes Across Timepoints RUVs
```{r logFC DDR Genes RUVs Across Timepoints}
library(rstatix)
# Read DNA Damage Response Gene List
# DNA_damage as above

# Convert gene symbols to Entrez IDs
# DNA_damage <- DNA_damage %>%
#   mutate(Entrez_ID = mapIds(org.Hs.eg.db,
#                             keys = Symbol,
#                             column = "ENTREZID",
#                             keytype = "SYMBOL",
#                             multiVals = "first"))

# DNA_damage_genes <- na.omit(DNA_damage$Entrez_ID)

# saveRDS(DNA_damage_genes, "data/new/RUV/DNA_damage_genes_symbolentrez.RDS")

DNA_damage_genes <- readRDS("data/new/RUV/DNA_damage_genes_symbolentrez.RDS")

all_toptables_RUV <- bind_rows(
  DOX_24T_R %>% mutate(Drug = "DOX", Timepoint = "24T"),
  DOX_24R_R %>% mutate(Drug = "DOX", Timepoint = "24R"),
  DOX_144R_R %>% mutate(Drug = "DOX", Timepoint = "144R"),
)

filtered_toptables_RUV <- all_toptables_RUV %>%
  filter(Entrez_ID %in% DNA_damage_genes) %>%
  mutate(abs_logFC = abs(logFC))

filtered_toptables_RUV <- filtered_toptables_RUV %>%
  mutate(
    Drug = factor(Drug, levels = c("DOX")),
    Timepoint = factor(Timepoint, levels = c("24T", "24R", "144R"), 
                       labels = c("Timepoint: 24T", "Timepoint: 24R", "Timepoint: 144R"))
  )

wilcox_results <- filtered_toptables_RUV %>%
  wilcox_test(abs_logFC ~ Timepoint) %>%
  adjust_pvalue(method = "bonferroni") %>%
  mutate(significance = ifelse(p < 0.05, "*", ""))

#make a little thing of your timepoint comparisons
pairs <- wilcox_results %>% 
  dplyr::select(group1, group2) %>% 
  distinct()

max_per_timepoint <- filtered_toptables_RUV %>% 
  group_by(Timepoint) %>% 
  summarise(max_logFC = max(abs_logFC, na.rm = TRUE), .groups = "drop")
  
#Join max values for group1
star_positions <- pairs %>%
  left_join(max_per_timepoint, by = c("group1" = "Timepoint"))
names(star_positions)[names(star_positions) == "max_logFC"] <- "max1"

#Join max values for group2, with suffixes to avoid name conflict
star_positions <- star_positions %>%
  left_join(max_per_timepoint, by = c("group2" = "Timepoint"), suffix = c(".group1", ".group2"))
names(star_positions)[names(star_positions) == "max_logFC"] <- "max2"

star_positions <- star_positions %>% 
  mutate(y_pos = pmax(max1, max2, na.rm = TRUE) + 0.2)

#now star positions has the same group1 and group2 as wilcoxon

wilcox_results_plot <- wilcox_results %>%
  left_join(star_positions, by = c("group1", "group2")) %>%
  mutate(x_position = 1.5)  

wilcox_results_plot <- wilcox_results_plot %>% 
  mutate(group1 = gsub("Timepoint: ", "", group1),
         group2 = gsub("Timepoint: ", "", group2))

wilcox_results_plot <- wilcox_results_plot %>%
  mutate(x_position = case_when(
    group1 == "24T" & group2 == "24R" ~ 1.5,
    group1 == "24T" & group2 == "144R" ~ 2,
    group1 == "24R" & group2 == "144R" ~ 2.5
  ))

####logFC####
ggplot(filtered_toptables_RUV, aes(x = Timepoint, y = logFC, fill = Timepoint)) +
  geom_boxplot() +
  scale_fill_manual(values = c(
    "Timepoint: 24T" = "#238B45",
    "Timepoint: 24R" = "#74C476",
    "Timepoint: 144R" = "#C7E9C0")) +  
  facet_wrap(~ Drug) +  
  geom_text(
    data = wilcox_results_plot, 
    aes(x = x_position, y = y_pos, label = significance), 
    size = 6, fontface = "bold", color = "black", inherit.aes = FALSE
  ) +
  theme_bw() +
  xlab("") +
  ylab("Log Fold Change") +  
  ggtitle("Log Fold Change for DDR Genes") +
  theme(
    plot.title = element_text(size = rel(1.5), hjust = 0.5),
    axis.title = element_text(size = 15, color = "black"),
    axis.line = element_line(linewidth = 1.5),
    strip.background = element_rect(fill = "gray"),  
    strip.text = element_text(size = 12, color = "black", face = "bold"),  
    axis.text.x = element_text(size = 8, color = "black", angle = 0)
  )

####abs logFC####
ggplot(filtered_toptables_RUV, aes(x = Timepoint, y = abs_logFC, fill = Timepoint)) +
  geom_boxplot() +
  scale_fill_manual(values = c(
    "Timepoint: 24T" = "#238B45",
    "Timepoint: 24R" = "#74C476",
    "Timepoint: 144R" = "#C7E9C0")) +  
  facet_wrap(~ Drug) +  
  geom_text(
    data = wilcox_results_plot, 
    aes(x = x_position, y = y_pos, label = significance), 
    size = 6, fontface = "bold", color = "black", inherit.aes = FALSE
  ) +
  theme_bw() +
  xlab("") +
  ylab("|Log Fold Change|") +  
  ggtitle("|Log Fold Change| for DDR Genes") +
  theme(
    plot.title = element_text(size = rel(1.5), hjust = 0.5),
    axis.title = element_text(size = 15, color = "black"),
    axis.line = element_line(linewidth = 1.5),
    strip.background = element_rect(fill = "gray"),  
    strip.text = element_text(size = 12, color = "black", face = "bold"),  
    axis.text.x = element_text(size = 8, color = "black", angle = 0)
  )
```


#DIC Genes RUVs Corrected
```{r RUVs DIC Genes logFC HM}
#plot a list of 29 functionally validated DIC genes
# Load DEG files
load_deg <- function(path) read.csv(path)

DOX_24T_R <- load_deg("data/new/DEGs/Toptable_RUV_24T_final.csv")
DOX_24R_R <- load_deg("data/new/DEGs/Toptable_RUV_24R_final.csv")
DOX_144R_R <- load_deg("data/new/DEGs/Toptable_RUV_144R_final.csv")

#the data I have is in hgnc_symbols, I want to convert this to entrez_id like my df
DIC_genes <- tribble(
  ~SYMBOL, ~Category,
  "CAT", "ROS Generation / Handling",
  "CBR1", "ROS Generation / Handling",
  "CBR3", "ROS Generation / Handling",
  "ERBB2", "ROS Generation / Handling",
  "GPX3", "ROS Generation / Handling",
  "GSTM1", "ROS Generation / Handling",
  "GSTP", "ROS Generation / Handling",
  "HAS3", "ROS Generation / Handling",
  "NOS3", "ROS Generation / Handling",
  "PLCE1", "ROS Generation / Handling",
  "RAC2", "ROS Generation / Handling",
  "SPG7", "ROS Generation / Handling",
  "PRDM2", "DNA Damage", 
  "MLH1", "DNA Damage",
  "RARG", "DNA Damage",
  "HFE", "Iron Uptake & Homeostasis",
  "SLC22A17", "DOX Uptake",
  "SLC28A1", "DOX Uptake",
  "SLC28A3", "DOX Uptake",
  "ABCB4", "DOX Efflux",
  "ABCC2", "DOX Efflux",
  "ABCC5", "DOX Efflux", 
  "ABCC9", "DOX Efflux",
  "ABCC10", "DOX Efflux",
  "CELF4", "Calcium Handling",
  "MYH7", "Calcium Handling",
  "CYP2J2", "Cardiac Electrical Activity",
  "RIN3", "Cardiac Electrical Activity",
  "ZFN521", "Cardiac Electrical Activity")

gene_df_DIC_RUV <- tibble(HGNC = DIC_genes)

gene_df_DIC_RUV <- gene_df_DIC_RUV %>% 
  mutate(Entrez_ID = mapIds(org.Hs.eg.db,
                            keys = DIC_genes$SYMBOL,
                            column = "ENTREZID", 
                            keytype = "SYMBOL", 
                            multiVals = "first")) %>% 
  unnest_wider(HGNC) %>% 
  mutate(Entrez_ID = as.character(Entrez_ID))

# DIC_genes_symb <- gene_df_DIC_RUV %>% 
#   dplyr::select("SYMBOL", "Entrez_ID")
# saveRDS(DIC_genes_symb, "data/new/RUV/DIC_genelist_symbolentrez_RUV.RDS")

#now I've put together a dataframe with the HGNC, Category, and Entrez_ID
#plus I've ensured that Entrez_ID is a character for later joining

entrez_ids_DIC_RUV <- gene_df_DIC_RUV$Entrez_ID

# Extract relevant DEG values
extract_data_DIC_RUV <- function(df, name) {
  df %>%
    filter(Entrez_ID %in% entrez_ids_DIC_RUV) %>%
    mutate(
      Gene = mapIds(org.Hs.eg.db, as.character(Entrez_ID),
                    column = "SYMBOL", keytype = "ENTREZID", multiVals = "first"),
      Condition = name,
      Signif = ifelse(adj.P.Val < 0.05, "*", "")
    )
}

# DEG list
deg_list_RUV <- list("DOX_24T" = DOX_24T_R, 
                 "DOX_24R" = DOX_24R_R, 
                 "DOX_144R" = DOX_144R_R
)

# Combine all DEGs and annotate
all_data_DIC_RUV <- bind_rows(mapply(extract_data_DIC_RUV, 
                             deg_list_RUV, 
                             names(deg_list_RUV), 
                             SIMPLIFY = FALSE)) %>%
  mutate(Entrez_ID = as.character(Entrez_ID)) %>% 
  left_join(gene_df_DIC_RUV, 
            by = "Entrez_ID")
#I've also made sure here that Entrez_ID is a character and not an integer

# Create matrices
logFC_matdic_RUV <- acast(all_data_DIC_RUV, Gene ~ Condition, value.var = "logFC")
signif_matdic_RUV <- acast(all_data_DIC_RUV, Gene ~ Condition, value.var = "Signif")

# Set desired order
desired_order <- c("DOX_24T",
                   "DOX_24R",
                   "DOX_144R")

logFC_mat_DIC_RUV <- logFC_matdic_RUV[, desired_order, drop = FALSE]
signif_mat_DIC_RUV <- signif_matdic_RUV[, desired_order, drop = FALSE]

# Column annotation
meta_DIC_R <- str_split_fixed(colnames(logFC_mat_DIC_RUV), "_", 3)
meta_DIC_R <- str_split_fixed(colnames(logFC_mat_DIC_RUV), "_", 2)
col_annot_RUV <- HeatmapAnnotation(
  Drug = meta_DIC_R[, 1],
  Time = meta_DIC_R[, 2],
  col = list(
    Drug = c("DOX" = "#499FBD"),
    Time = c("24T" = "#238B45", 
             "24R" = "#74C476", 
             "144R" = "#C7E9C0")
  ),
  annotation_height = unit(c(2, 2, 2), "cm")
)
#for this I can leave off the DMSO as it's already from a pairwise comparison

#make an extra object with my category order as well
category_order_DIC <- c(
  "ROS Generation / Handling",
  "DNA Damage",
  "Calcium Handling",
  "DOX Uptake",
  "Iron Uptake & Homeostasis",
  "DOX Efflux",
  "Cardiac Electrical Activity"
)

# Row annotation
gene_order_df_DIC_RUV <- all_data_DIC_RUV %>%
  distinct(Gene, Category) %>%
  mutate(Category = factor(Category, levels = category_order_DIC)) %>% 
  arrange(Category, Gene)

ordered_genes_DIC_RUV <- gene_order_df_DIC_RUV$Gene
logFC_mat_DIC_RUV <- logFC_mat_DIC_RUV[ordered_genes_DIC_RUV, ]
signif_mat_DIC_RUV <- signif_mat_DIC_RUV[ordered_genes_DIC_RUV, ]

#add in your colors for each category
 category_colors_DIC <- structure(
  c("darkorange", "steelblue", "darkgreen", "firebrick", "gold", "mediumpurple", "gray60"),
  names = category_order_DIC
)

ha_left_DIC_RUV <- rowAnnotation(
  Category = gene_order_df_DIC_RUV$Category,
  col = list(Category = category_colors_DIC),
  annotation_name_side = "top"
)

# Draw heatmap
Heatmap(logFC_mat_DIC_RUV,
        name = "logFC",
        top_annotation = col_annot_RUV,
        left_annotation = ha_left_DIC_RUV,
        cluster_columns = FALSE,
        cluster_rows = FALSE,
        show_row_names = TRUE,
        show_column_names = FALSE,
        cell_fun = function(j, i, x, y, width, height, fill) {
          grid.text(signif_mat_DIC_RUV[i, j], x, y, gp = gpar(fontsize = 9))
        },
        column_title = "DIC Genes Expression (n=29)\nDOX Recovery (RUVs Corrected)",
        column_title_gp = gpar(fontsize = 14, fontface = "bold")
)
```

```{r logFC Boxplots DIC RUVs Genes}
#get an overall idea of the logFC of these genes over timepoints
library(rstatix)
# Read DIC gene list - named DOX_cardiotox

# DOX_cardiotox <- readRDS("data/new/RUV/DIC_genelist_symbolentrez_RUV.RDS")
# 
# # Convert gene symbols to Entrez IDs
# DOX_cardiotox <- DOX_cardiotox %>%
#   mutate(Entrez_ID = mapIds(org.Hs.eg.db,
#                             keys = SYMBOL,
#                             column = "ENTREZID",
#                             keytype = "SYMBOL",
#                             multiVals = "first"))
# 
# DOX_cardiotox_genes <- na.omit(DOX_cardiotox$Entrez_ID)

# saveRDS(DOX_cardiotox_genes, "data/new/RUV/DIC_genes_symbolentrez.RDS")
#this already has both SYMBOL and Entrez_ID

DOX_cardiotox_genes <- readRDS("data/new/RUV/DIC_genes_symbolentrez.RDS")

all_toptables_RUV <- bind_rows(
  DOX_24T_R %>% mutate(Drug = "DOX", Timepoint = "24T"),
  DOX_24R_R %>% mutate(Drug = "DOX", Timepoint = "24R"),
  DOX_144R_R %>% mutate(Drug = "DOX", Timepoint = "144R"),
)

filtered_toptables_RUV_DIC <- all_toptables_RUV %>%
  filter(Entrez_ID %in% DOX_cardiotox_genes) %>%
  mutate(abs_logFC = abs(logFC))

filtered_toptables_RUV_DIC <- filtered_toptables_RUV_DIC %>%
  mutate(
    Drug = factor(Drug, levels = c("DOX")),
    Timepoint = factor(Timepoint, levels = c("24T", "24R", "144R"), 
                       labels = c("Timepoint: 24T", "Timepoint: 24R", "Timepoint: 144R"))
  )

wilcox_results_DIC <- filtered_toptables_RUV_DIC %>%
  wilcox_test(abs_logFC ~ Timepoint) %>%
  adjust_pvalue(method = "bonferroni") %>%
  mutate(significance = ifelse(p < 0.05, "*", ""))

#make a little thing of your timepoint comparisons
pairs_DIC <- wilcox_results_DIC %>% 
  dplyr::select(group1, group2) %>% 
  distinct()

max_per_timepoint_DIC <- filtered_toptables_RUV_DIC %>% 
  group_by(Timepoint) %>% 
  summarise(max_logFC = max(abs_logFC, na.rm = TRUE), .groups = "drop")
  
#Join max values for group1
star_positions_DIC <- pairs_DIC %>%
  left_join(max_per_timepoint_DIC, by = c("group1" = "Timepoint"))
names(star_positions_DIC)[names(star_positions_DIC) == "max_logFC"] <- "max1"

#Join max values for group2, with suffixes to avoid name conflict
star_positions_DIC <- star_positions_DIC %>%
  left_join(max_per_timepoint_DIC, by = c("group2" = "Timepoint"), suffix = c(".group1", ".group2"))
names(star_positions_DIC)[names(star_positions_DIC) == "max_logFC"] <- "max2"

star_positions_DIC <- star_positions_DIC %>% 
  mutate(y_pos = pmax(max1, max2, na.rm = TRUE) + 0.2)

#now star positions has the same group1 and group2 as wilcoxon

wilcox_results_plot_DIC <- wilcox_results_DIC %>%
  left_join(star_positions_DIC, by = c("group1", "group2")) %>%
  mutate(x_position = 1.5)  

wilcox_results_plot_DIC <- wilcox_results_plot_DIC %>% 
  mutate(group1 = gsub("Timepoint: ", "", group1),
         group2 = gsub("Timepoint: ", "", group2))

wilcox_results_plot_DIC <- wilcox_results_plot_DIC %>%
  mutate(x_position = case_when(
    group1 == "24T" & group2 == "24R" ~ 1.5,
    group1 == "24T" & group2 == "144R" ~ 2,
    group1 == "24R" & group2 == "144R" ~ 2.5
  ))

####logFC####
ggplot(filtered_toptables_RUV_DIC, aes(x = Timepoint, y = logFC, fill = Timepoint)) +
  geom_boxplot() +
  scale_fill_manual(values = c(
    "Timepoint: 24T" = "#238B45",
    "Timepoint: 24R" = "#74C476",
    "Timepoint: 144R" = "#C7E9C0")) +  
  facet_wrap(~ Drug) +  
  geom_text(
    data = wilcox_results_plot_DIC, 
    aes(x = x_position, y = y_pos, label = significance), 
    size = 6, fontface = "bold", color = "black", inherit.aes = FALSE
  ) +
  theme_bw() +
  xlab("") +
  ylab("Log Fold Change") +  
  ggtitle("Log Fold Change for DIC Genes") +
  theme(
    plot.title = element_text(size = rel(1.5), hjust = 0.5),
    axis.title = element_text(size = 15, color = "black"),
    axis.line = element_line(linewidth = 1.5),
    strip.background = element_rect(fill = "gray"),  
    strip.text = element_text(size = 12, color = "black", face = "bold"),  
    axis.text.x = element_text(size = 8, color = "black", angle = 0)
  )

####abs logFC####
ggplot(filtered_toptables_RUV_DIC, aes(x = Timepoint, y = abs_logFC, fill = Timepoint)) +
  geom_boxplot() +
  scale_fill_manual(values = c(
    "Timepoint: 24T" = "#238B45",
    "Timepoint: 24R" = "#74C476",
    "Timepoint: 144R" = "#C7E9C0")) +  
  facet_wrap(~ Drug) +  
  geom_text(
    data = wilcox_results_plot_DIC, 
    aes(x = x_position, y = y_pos, label = significance), 
    size = 6, fontface = "bold", color = "black", inherit.aes = FALSE
  ) +
  theme_bw() +
  xlab("") +
  ylab("|Log Fold Change|") +  
  ggtitle("|Log Fold Change| for DIC Genes") +
  theme(
    plot.title = element_text(size = rel(1.5), hjust = 0.5),
    axis.title = element_text(size = 15, color = "black"),
    axis.line = element_line(linewidth = 1.5),
    strip.background = element_rect(fill = "gray"),  
    strip.text = element_text(size = 12, color = "black", face = "bold"),  
    axis.text.x = element_text(size = 8, color = "black", angle = 0)
  )
```

#AIC Genes RUVs Corrected
```{r AIC Genes RUVs logFC HM, fig.height=12, fig.width=8}
#plot a list of 38 AIC genes identified by Renee in her paper
# Load DEG files
load_deg <- function(path) read.csv(path)

DOX_24T_R <- load_deg("data/new/DEGs/Toptable_RUV_24T_final.csv")
DOX_24R_R <- load_deg("data/new/DEGs/Toptable_RUV_24R_final.csv")
DOX_144R_R <- load_deg("data/new/DEGs/Toptable_RUV_144R_final.csv")

#the data I have is in hgnc_symbols, I want to convert this to entrez_id like my df
AIC_genes_set <- tribble(~SYMBOL,
                         "PELI2", "LGALS3", "LRRTM4", "PCCA", "NCOA2",
                         "NDN", "ADCY2", "TUSC3", "PLAAT1", "SORT1",
                         "GPSM2", "CLCC1", "SUCLA2", "LNPK", "NEDD4L",
                         "PLEKHA5", "GRAMD4", "TTC38", "CDPF1", "CELSR1",
                         "CYREN", "POLR3A", "LPL", "DGCR6", "NSUN7",
                         "APBB2", "DUBR", "PAM", "PPIP5K2", "GIN1",
                         "RARG", "TNS2", "ZNF740", "SLC28A3", "RMI1",
                         "EEF1B2", "FRS2", "HDDC2")

gene_df_AIC_RUV <- tibble(HGNC = AIC_genes_set)

gene_df_AIC_RUV <- gene_df_AIC_RUV %>% 
  mutate(Entrez_ID = mapIds(org.Hs.eg.db,
                            keys = AIC_genes_set$SYMBOL,
                            column = "ENTREZID", 
                            keytype = "SYMBOL", 
                            multiVals = "first")) %>% 
  unnest_wider(HGNC) %>% 
  mutate(Entrez_ID = as.character(Entrez_ID))

# AIC_genes_symb <- gene_df_AIC_RUV %>%
#   dplyr::select("SYMBOL", "Entrez_ID")
# saveRDS(AIC_genes_symb, "data/new/RUV/AIC_genelist_symbolentrez_RUV.RDS")

#now I've put together a dataframe with the HGNC, Category, and Entrez_ID
#plus I've ensured that Entrez_ID is a character for later joining

entrez_ids_AIC_RUV <- gene_df_AIC_RUV$Entrez_ID

# Extract relevant DEG values
extract_data_AIC_RUV <- function(df, name) {
  df %>%
    filter(Entrez_ID %in% entrez_ids_AIC_RUV) %>%
    mutate(
      Gene = mapIds(org.Hs.eg.db, as.character(Entrez_ID),
                    column = "SYMBOL", keytype = "ENTREZID", multiVals = "first"),
      Condition = name,
      Signif = ifelse(adj.P.Val < 0.05, "*", "")
    )
}

# DEG list
deg_list_RUV <- list("DOX_24T" = DOX_24T_R, 
                 "DOX_24R" = DOX_24R_R, 
                 "DOX_144R" = DOX_144R_R
)

# Combine all DEGs and annotate
all_data_AIC_RUV <- bind_rows(mapply(extract_data_AIC_RUV, 
                             deg_list_RUV, 
                             names(deg_list_RUV), 
                             SIMPLIFY = FALSE)) %>%
  mutate(Entrez_ID = as.character(Entrez_ID)) %>% 
  left_join(gene_df_AIC_RUV, 
            by = "Entrez_ID")
#I've also made sure here that Entrez_ID is a character and not an integer

# Create matrices
logFC_matAIC_RUV <- acast(all_data_AIC_RUV, Gene ~ Condition, value.var = "logFC")
signif_matAIC_RUV <- acast(all_data_AIC_RUV, Gene ~ Condition, value.var = "Signif")

# Set desired order
desired_order <- c("DOX_24T",
                   "DOX_24R",
                   "DOX_144R")

logFC_mat_AIC_RUV <- logFC_matAIC_RUV[, desired_order, drop = FALSE]
signif_mat_AIC_RUV <- signif_matAIC_RUV[, desired_order, drop = FALSE]

# Column annotation
meta_AIC_R <- str_split_fixed(colnames(logFC_mat_AIC_RUV), "_", 3)
meta_AIC_R <- str_split_fixed(colnames(logFC_mat_AIC_RUV), "_", 2)
col_annot_RUV <- HeatmapAnnotation(
  Drug = meta_AIC_R[, 1],
  Time = meta_AIC_R[, 2],
  col = list(
    Drug = c("DOX" = "#499FBD"),
    Time = c("24T" = "#238B45", 
             "24R" = "#74C476", 
             "144R" = "#C7E9C0")
  ),
  annotation_height = unit(c(2, 2, 2), "cm")
)

# Draw heatmap
Heatmap(logFC_mat_AIC_RUV,
        name = "logFC",
        top_annotation = col_annot_RUV,
        cluster_columns = FALSE,
        cluster_rows = FALSE,
        show_row_names = TRUE,
        show_column_names = FALSE,
        cell_fun = function(j, i, x, y, width, height, fill) {
          grid.text(signif_mat_AIC_RUV[i, j], x, y, gp = gpar(fontsize = 9))
        },
        column_title = "AIC Genes Expression (n=38)\nDOX Recovery (RUVs Corrected)",
        column_title_gp = gpar(fontsize = 14, fontface = "bold")
)
```

##AIC Genes RUVs logFC Boxplots
```{r AIC logFC Boxplots RUVs}
#get an overall idea of the logFC of these genes over timepoints

# Read AIC gene list - named AIC_list

AIC_list <- readRDS("data/new/RUV/AIC_genelist_symbolentrez_RUV.RDS")
###this already has both SYMBOL and Entrez_ID###

all_toptables_RUV <- bind_rows(
  DOX_24T_R %>% mutate(Drug = "DOX", Timepoint = "24T"),
  DOX_24R_R %>% mutate(Drug = "DOX", Timepoint = "24R"),
  DOX_144R_R %>% mutate(Drug = "DOX", Timepoint = "144R"),
)

filtered_toptables_RUV_AIC <- all_toptables_RUV %>%
  filter(Entrez_ID %in% AIC_list$Entrez_ID) %>%
  mutate(abs_logFC = abs(logFC)) %>% 
  dplyr::select(-("X"))

filtered_toptables_RUV_AIC <- filtered_toptables_RUV_AIC %>%
  mutate(
    Drug = factor(Drug, levels = c("DOX")),
    Timepoint = factor(Timepoint, levels = c("24T", "24R", "144R"), 
                       labels = c("Timepoint: 24T", "Timepoint: 24R", "Timepoint: 144R"))
  )

wilcox_results_AIC <- filtered_toptables_RUV_AIC %>%
  wilcox_test(abs_logFC ~ Timepoint) %>%
  adjust_pvalue(method = "bonferroni") %>%
  mutate(significance = ifelse(p < 0.05, "*", ""))

#make a little thing of your timepoint comparisons
pairs_AIC <- wilcox_results_AIC %>% 
  dplyr::select(group1, group2) %>% 
  distinct()

max_per_timepoint_AIC <- filtered_toptables_RUV_AIC %>% 
  group_by(Timepoint) %>% 
  summarise(max_logFC = max(abs_logFC, na.rm = TRUE), .groups = "drop")
  
#Join max values for group1
star_positions_AIC <- pairs_AIC %>%
  left_join(max_per_timepoint_AIC, by = c("group1" = "Timepoint"))
names(star_positions_AIC)[names(star_positions_AIC) == "max_logFC"] <- "max1"

#Join max values for group2, with suffixes to avoid name conflict
star_positions_AIC <- star_positions_AIC %>%
  left_join(max_per_timepoint_AIC, by = c("group2" = "Timepoint"), suffix = c(".group1", ".group2"))
names(star_positions_AIC)[names(star_positions_AIC) == "max_logFC"] <- "max2"

star_positions_AIC <- star_positions_AIC %>% 
  mutate(y_pos = pmax(max1, max2, na.rm = TRUE) + 0.2)

#now star positions has the same group1 and group2 as wilcoxon

#I want to leave off the stars for now as they're confusing

wilcox_results_plot_AIC <- wilcox_results_AIC %>%
  left_join(star_positions_AIC, by = c("group1", "group2")) %>%
  mutate(x_position = 1.5)  

wilcox_results_plot_AIC <- wilcox_results_plot_AIC %>% 
  mutate(group1 = gsub("Timepoint: ", "", group1),
         group2 = gsub("Timepoint: ", "", group2))

wilcox_results_plot_AIC <- wilcox_results_plot_AIC %>%
  mutate(x_position = case_when(
    group1 == "24T" & group2 == "24R" ~ 1.5,
    group1 == "24T" & group2 == "144R" ~ 2,
    group1 == "24R" & group2 == "144R" ~ 2.5
  ))

####logFC####
ggplot(filtered_toptables_RUV_AIC, aes(x = Timepoint, y = logFC, fill = Timepoint)) +
  geom_boxplot() +
  scale_fill_manual(values = c(
    "Timepoint: 24T" = "#238B45",
    "Timepoint: 24R" = "#74C476",
    "Timepoint: 144R" = "#C7E9C0")) +  
  facet_wrap(~ Drug) +  
  # geom_text(
  #   data = wilcox_results_plot_AIC, 
  #   aes(x = x_position, y = y_pos, label = significance), 
  #   size = 6, fontface = "bold", color = "black", inherit.aes = FALSE
  # ) +
  theme_bw() +
  xlab("") +
  ylab("Log Fold Change") +  
  ggtitle("Log Fold Change for AIC Genes") +
  theme(
    plot.title = element_text(size = rel(1.5), hjust = 0.5),
    axis.title = element_text(size = 15, color = "black"),
    axis.line = element_line(linewidth = 1.5),
    strip.background = element_rect(fill = "gray"),  
    strip.text = element_text(size = 12, color = "black", face = "bold"),  
    axis.text.x = element_text(size = 8, color = "black", angle = 0)
  )

####abs logFC####
ggplot(filtered_toptables_RUV_AIC, aes(x = Timepoint, y = abs_logFC, fill = Timepoint)) +
  geom_boxplot() +
  scale_fill_manual(values = c(
    "Timepoint: 24T" = "#238B45",
    "Timepoint: 24R" = "#74C476",
    "Timepoint: 144R" = "#C7E9C0")) +  
  facet_wrap(~ Drug) +  
  # geom_text(
  #   data = wilcox_results_plot_AIC, 
  #   aes(x = x_position, y = y_pos, label = significance), 
  #   size = 6, fontface = "bold", color = "black", inherit.aes = FALSE
  # ) +
  theme_bw() +
  xlab("") +
  ylab("|Log Fold Change|") +  
  ggtitle("|Log Fold Change| for AIC Genes") +
  theme(
    plot.title = element_text(size = rel(1.5), hjust = 0.5),
    axis.title = element_text(size = 15, color = "black"),
    axis.line = element_line(linewidth = 1.5),
    strip.background = element_rect(fill = "gray"),  
    strip.text = element_text(size = 12, color = "black", face = "bold"),  
    axis.text.x = element_text(size = 8, color = "black", angle = 0)
  )


```


#p53 Target Genes logFC Heatmap RUVs Corrected
```{r RUVs p53 Target Genes logFC HM, fig.height=80, fig.width=15}
# Load libraries

# Load DEG files
load_deg <- function(path) read.csv(path)

DOX_24T_R <- load_deg("data/new/DEGs/Toptable_RUV_24T_final.csv")
DOX_24R_R <- load_deg("data/new/DEGs/Toptable_RUV_24R_final.csv")
DOX_144R_R <- load_deg("data/new/DEGs/Toptable_RUV_144R_final.csv")


#P53 target Entrez_ID
entrez_ids_p53 <- c(1026,50484,4193,9766,9518,7832,1643,1647,1263,57103,51065,8795,51499,64393,581,
                5228,5429,8493,55959,7508,64782,282991,355,53836,4814,10769,9050,27244,9540,94241,
                26154,57763,900,26999,55332,26263,23479,23612,29950,9618,10346,8824,134147,55294,
                22824,4254,6560,467,27113,60492,8444,60401,1969,220965,2232,3976,55191,84284,93129,
                5564,7803,83667,7779,132671,7039,51768,137695,93134,7633,10973,340485,307,27350,
                23245,3732,29965,1363,1435,196513,8507,8061,2517,51278,53354,54858,23228,5366,5912,
                6236,51222,26152,59,1907,50650,91012,780,9249,11072,144455,64787,116151,27165,2876,
                57822,55733,57722,121457,375449,85377,4851,5875,127544,29901,84958,8797,8793,441631,
                220001,54541,5889,5054,25816,25987,5111,98,317,598,604,10904,1294,80315,53944,
                1606,2770,3628,3675,3985,4035,4163,84552,29085,55367,5371,5791,54884,5980,8794,
                1462,50808,220,583,694,1056,9076,10978,54677,1612,55040,114907,2274,127707,4000,
                8079,4646,4747,27445,5143,80055,79156,5360,5364,23654,5565,5613,5625,10076,56963,
                6004,390,255488,6326,6330,23513,7869,283130,204962,83959,6548,6774,9263,10228,
                22954,10475,85363,494514,10142,79714,1006,8446,9648,79828,5507,55240,63874,25841,
                9289,84883,154810,51321,421,8553,655,119032,84280,10950,824,839,57828,857,8812,
                8837,94027,113189,22837,132864,10898,3300,81704,1847,1849,1947,9538,24139,5168,
                147965,115548,9873,23768,2632,2817,3280,3265,23308,3490,51477,182,3856,8844,144811,
                9404,4043,9848,2872,23041,740,343263,4638,26509,4792,22861,57523,55214,80025,164091,
                57060,64065,51090,5453,8496,333926,55671,5900,55544,23179,8601,389,6223,55800,6385,
                4088,6643,122809,257397,285343,7011,54790,374618,55362,51754,7157,9537,22906,7205,
                80705,219699,55245,83719,7748,25946,118738)

# saveRDS(entrez_ids_p53, "data/new/RUV/p53_targetgenes_entrezid.RDS")

# Function to extract relevant data
extract_data_p53_RUV <- function(df, name) {
  df %>%
    filter(Entrez_ID %in% entrez_ids_p53) %>%
    mutate(Gene = mapIds(org.Hs.eg.db, 
                         as.character(Entrez_ID),
                         column = "SYMBOL", 
                         keytype = "ENTREZID", 
                         multiVals = "first"),
           Condition = name,
           Signif = ifelse(adj.P.Val < 0.05, "*", ""))
}


# Collect all data
# DEG list
deg_list_RUV <- list("DOX_24T" = DOX_24T_R, 
                 "DOX_24R" = DOX_24R_R, 
                 "DOX_144R" = DOX_144R_R
)

# Combine all DEGs and annotate
all_data_p53_RUV <- bind_rows(mapply(extract_data_p53_RUV, deg_list_RUV, names(deg_list_RUV), SIMPLIFY = FALSE)) 
#unnecessary to join again as there are not categories on this list of entrezids
# %>%
#   left_join(entrez_ids, by = c("Entrez_ID" = "ENTREZID"))

#make a list of these genes for later analysis
# saveRDS(all_data_p53_RUV, "data/new/RUV/p53_targetgenes_RUV.RDS")

# p53_genes <- all_data_p53_RUV %>% 
#   dplyr::select("SYMBOL", "Entrez_ID")

# saveRDS(p53_genes, "data/new/RUV/p53_genes_symbolentrez.RDS")

# Create matrices
logFC_mat53_RUV <- acast(all_data_p53_RUV, Gene ~ Condition, value.var = "logFC")
signif_mat53_RUV <- acast(all_data_p53_RUV, Gene ~ Condition, value.var = "Signif")

# Desired column order
desired_order <- c("DOX_24T",
                   "DOX_24R",
                   "DOX_144R")

logFC_mat_p53_RUV <- logFC_mat53_RUV[, desired_order]
signif_mat_p53_RUV <- signif_mat53_RUV[, desired_order]

# Column annotation
meta_p53_RUV <- str_split_fixed(colnames(logFC_mat_p53_RUV), "_", 3)
meta_p53_RUV <- str_split_fixed(colnames(logFC_mat_p53_RUV), "_", 2)
col_annot_p53_RUV <- HeatmapAnnotation(
  Drug = meta_p53_RUV[, 1],
  Time = meta_p53_RUV[, 2],
  col = list(
    Drug = c("DOX" = "#499FBD"),
    Time = c("24T" = "#238B45", 
             "24R" = "#74C476", 
             "144R" = "#C7E9C0")
  ),
  annotation_height = unit(c(1, 1, 1), "cm")
)

# Draw heatmap
Heatmap(logFC_mat_p53_RUV,
        name = "logFC",
        top_annotation = col_annot,
        cluster_columns = FALSE,
        cluster_rows = TRUE,
        show_row_names = TRUE,
        show_column_names = FALSE,
        layer_fun = function(j, i, x, y, width, height, fill) {
          grid.text(signif_mat_p53_RUV[cbind(i, j)], x, y, gp = gpar(fontsize = 9))
        },
        column_title = "P53 Target Genes Expression\nDOX Recovery (RUVs Corrected)",
        column_title_gp = gpar(fontsize = 14, fontface = "bold")
)

```

##p53 logFC boxplots
```{r logFC Boxplots p53 RUVs}

#get an overall idea of the logFC of these genes over timepoints
# library(rstatix)
# Read p53 gene list - named p53_genes

# p53_genes <- readRDS("data/new/RUV/p53_genes_symbolentrez.RDS")
# 
# # Convert gene symbols to Entrez IDs
# p53_targets <- p53_genes %>%
#   mutate(Entrez_ID = mapIds(org.Hs.eg.db,
#                             keys = SYMBOL,
#                             column = "ENTREZID",
#                             keytype = "SYMBOL",
#                             multiVals = "first"))
# 
#p53_target_genes <- na.omit(p53_targets$Entrez_ID)

# saveRDS(p53_target_genes, "data/new/RUV/p53_target_genes_symbolentrez.RDS")
#this already has both SYMBOL and Entrez_ID

p53_target_genes <- readRDS("data/new/RUV/p53_target_genes_symbolentrez.RDS")

all_toptables_RUV <- bind_rows(
  DOX_24T_R %>% mutate(Drug = "DOX", Timepoint = "24T"),
  DOX_24R_R %>% mutate(Drug = "DOX", Timepoint = "24R"),
  DOX_144R_R %>% mutate(Drug = "DOX", Timepoint = "144R"),
)

filtered_toptables_RUV_p53 <- all_toptables_RUV %>%
  filter(Entrez_ID %in% p53_target_genes) %>%
  mutate(abs_logFC = abs(logFC)) 
  

filtered_toptables_RUV_p53 <- filtered_toptables_RUV_p53 %>%
  mutate(
    Drug = factor(Drug, levels = c("DOX")),
    Timepoint = factor(Timepoint, levels = c("24T", "24R", "144R"), 
                       labels = c("Timepoint: 24T", "Timepoint: 24R", "Timepoint: 144R"))
  )

wilcox_results_p53 <- filtered_toptables_RUV_p53 %>%
  wilcox_test(abs_logFC ~ Timepoint) %>%
  adjust_pvalue(method = "bonferroni") %>%
  mutate(significance = ifelse(p < 0.05, "*", "")) %>% 
  mutate(Conditions = paste(group1, "vs", group2, sep = " "))

#make a little thing of your timepoint comparisons
pairs_p53 <- wilcox_results_p53 %>% 
  dplyr::select(group1, group2) %>% 
  distinct()

max_per_timepoint_p53 <- filtered_toptables_RUV_p53 %>% 
  group_by(Timepoint) %>% 
  summarise(max_logFC = max(abs_logFC, na.rm = TRUE), .groups = "drop")
  
#Join max values for group1
star_positions_p53 <- pairs_p53 %>%
  left_join(max_per_timepoint_p53, by = c("group1" = "Timepoint"))
names(star_positions_p53)[names(star_positions_p53) == "max_logFC"] <- "max1"

#Join max values for group2, with suffixes to avoid name conflict
star_positions_p53 <- star_positions_p53 %>%
  left_join(max_per_timepoint_p53, by = c("group2" = "Timepoint"), suffix = c(".group1", ".group2"))
names(star_positions_p53)[names(star_positions_p53) == "max_logFC"] <- "max2"

star_positions_p53 <- star_positions_p53 %>% 
  mutate(y_pos = pmax(max1, max2, na.rm = TRUE) + 0.2)

#now star positions has the same group1 and group2 as wilcoxon

wilcox_results_plot_p53 <- wilcox_results_p53 %>%
  left_join(star_positions_p53, by = c("group1", "group2")) %>%
  mutate(x_position = 1.5)  

wilcox_results_plot_p53 <- wilcox_results_plot_p53 %>% 
  mutate(group1 = gsub("Timepoint: ", "", group1),
         group2 = gsub("Timepoint: ", "", group2))

wilcox_results_plot_p53 <- wilcox_results_plot_p53 %>%
  mutate(x_position = case_when(
    group1 == "24T" & group2 == "24R" ~ 1.5,
    group1 == "24T" & group2 == "144R" ~ 2,
    group1 == "24R" & group2 == "144R" ~ 2.5
  ))

####logFC####
ggplot(filtered_toptables_RUV_p53, aes(x = Timepoint, y = logFC, fill = Timepoint)) +
  geom_boxplot() +
  scale_fill_manual(values = c(
    "Timepoint: 24T" = "#238B45",
    "Timepoint: 24R" = "#74C476",
    "Timepoint: 144R" = "#C7E9C0")) +  
  facet_wrap(~ Drug) +  
  # geom_text(
  #   data = wilcox_results_plot_p53, 
  #   aes(x = x_position, y = y_pos, label = significance), 
  #   size = 6, fontface = "bold", color = "black", inherit.aes = FALSE
  # ) +
  theme_bw() +
  xlab("") +
  ylab("Log Fold Change") +  
  ggtitle("Log Fold Change for p53 Target Genes") +
  theme(
    plot.title = element_text(size = rel(1.5), hjust = 0.5),
    axis.title = element_text(size = 15, color = "black"),
    axis.line = element_line(linewidth = 1.5),
    strip.background = element_rect(fill = "gray"),  
    strip.text = element_text(size = 12, color = "black", face = "bold"),  
    axis.text.x = element_text(size = 8, color = "black", angle = 0)
  )

####abs logFC####
ggplot(filtered_toptables_RUV_p53, aes(x = Timepoint, y = abs_logFC, fill = Timepoint)) +
  geom_boxplot() +
  scale_fill_manual(values = c(
    "Timepoint: 24T" = "#238B45",
    "Timepoint: 24R" = "#74C476",
    "Timepoint: 144R" = "#C7E9C0")) +  
  facet_wrap(~ Drug) +  
  # geom_text(
  #   data = wilcox_results_plot_p53, 
  #   aes(x = x_position, y = y_pos, label = significance), 
  #   size = 6, fontface = "bold", color = "black", inherit.aes = FALSE
  # ) +
  theme_bw() +
  xlab("") +
  ylab("|Log Fold Change|") +  
  ggtitle("|Log Fold Change| for p53 Target Genes") +
  theme(
    plot.title = element_text(size = rel(1.5), hjust = 0.5),
    axis.title = element_text(size = 15, color = "black"),
    axis.line = element_line(linewidth = 1.5),
    strip.background = element_rect(fill = "gray"),  
    strip.text = element_text(size = 12, color = "black", face = "bold"),  
    axis.text.x = element_text(size = 8, color = "black", angle = 0)
  )
```
###logFC boxplots with all timepoint comparisons wilcoxon
```{r logFC p53 boxplots all comparisons, fig.height = 10, fig.width = 8}
# #try this where each of my timepoints are compared like the wilcoxon test - plot all of these and see which are significant
# 
# Comparisons <- tribble(
#   ~group1, ~group2,
#   "24T",   "24R",
#   "24T",   "144R",
#   "24R",   "144R"
# )
# 
# # Expand your filtered_toptables_RUV_p53 to include comparisons
# filtered_toptables_RUV_p53_comp <- filtered_toptables_RUV_p53 %>%
#   # Create a cross join with the comparisons
#   crossing(Comparisons) %>%
#   # Keep only the rows where the gene's timepoint matches one of the groups in the comparison
#   filter(Timepoint %in% c(group1, group2)) %>%
#   mutate(
#     Conditions = factor(paste(group1, "vs", group2),
#                         levels = c("24T vs 24R", "24T vs 144R", "24R vs 144R"))
#   )
# 
# 
# # filtered_toptables_RUV_p53_comp <- filtered_toptables_RUV_p53_comp %>%
# #   mutate(
# #     Drug = factor(Drug, levels = c("DOX")),
# #     Timepoint_raw = Timepoint,  #save unmod version(24T, 24R, 144R)
# #     Timepoint = factor(Timepoint, levels = c("24T", "24R", "144R"), 
# #                        labels = c("24T", "24R", "144R")),
# #     Conditions = factor(paste(group1, "vs", group2),
# #                         levels = c("24T vs 24R", "24T vs 144R", "24R vs 144R"))
# #   )
# 
# wilcox_results_p53 <- filtered_toptables_RUV_p53_comp %>%
#   wilcox_test(abs_logFC ~ Timepoint) %>%
#   adjust_pvalue(method = "bonferroni") %>%
#   mutate(significance = ifelse(p < 0.05, "*", "")) %>% 
#   mutate(Comparisons = paste(group1, "vs", group2, sep = " "))
# 
# #make a little thing of your timepoint comparisons
# pairs_p53 <- wilcox_results_p53 %>% 
#   dplyr::select(group1, group2) %>% 
#   distinct()
# 
# max_per_timepoint_p53 <- filtered_toptables_RUV_p53_comp %>% 
#   group_by(Timepoint) %>% 
#   summarise(max_logFC = max(abs_logFC, na.rm = TRUE), .groups = "drop")
#   
# #Join max values for group1
# star_positions_p53 <- pairs_p53 %>%
#   left_join(max_per_timepoint_p53, by = c("group1" = "Timepoint"))
# names(star_positions_p53)[names(star_positions_p53) == "max_logFC"] <- "max1"
# 
# #Join max values for group2, with suffixes to avoid name conflict
# star_positions_p53 <- star_positions_p53 %>%
#   left_join(max_per_timepoint_p53, by = c("group2" = "Timepoint"), suffix = c(".group1", ".group2"))
# names(star_positions_p53)[names(star_positions_p53) == "max_logFC"] <- "max2"
# 
# star_positions_p53 <- star_positions_p53 %>% 
#   mutate(y_pos = pmax(max1, max2, na.rm = TRUE) + 0.2)
# 
# #now star positions has the same group1 and group2 as wilcoxon
# 
# wilcox_results_plot_p53 <- wilcox_results_p53 %>%
#   left_join(star_positions_p53, by = c("group1", "group2")) %>%
#   mutate(x_position = 1.5)  
# 
# wilcox_results_plot_p53 <- wilcox_results_plot_p53 %>% 
#   mutate(group1 = gsub("Timepoint: ", "", group1),
#          group2 = gsub("Timepoint: ", "", group2))
# 
# wilcox_results_plot_p53 <- wilcox_results_plot_p53 %>%
#   mutate(
#     group1_raw = str_remove(group1, "^Timepoint: "),
#     group2_raw = str_remove(group2, "^Timepoint: ")
#   )
# 
# wilcox_results_plot_p53 <- wilcox_results_plot_p53 %>%
#   mutate(x_position = case_when(
#     group1 == "24T" & group2 == "24R" ~ 1.5,
#     group1 == "24T" & group2 == "144R" ~ 2,
#     group1 == "24R" & group2 == "144R" ~ 2.5
#   ))
# 
# ####logFC####
# ggplot(filtered_toptables_RUV_p53_comp, aes(x = Timepoint, y = logFC, fill = Timepoint)) +
#   geom_boxplot() +
#   scale_fill_manual(values = c(
#     "24T" = "#238B45",
#     "24R" = "#74C476",
#     "144R" = "#C7E9C0")) +  
#   facet_wrap(~Conditions) +  
#   geom_text(
#     data = wilcox_results_plot_p53, 
#     aes(x = x_position, y = y_pos, label = significance), 
#     size = 6, fontface = "bold", color = "black", inherit.aes = FALSE
#   ) +
#   theme_bw() +
#   xlab("") +
#   ylab("Log Fold Change") +  
#   ggtitle("Log Fold Change for p53 Target Genes") +
#   theme(
#     plot.title = element_text(size = rel(1.5), hjust = 0.5),
#     axis.title = element_text(size = 15, color = "black"),
#     axis.line = element_line(linewidth = 1.5),
#     strip.background = element_rect(fill = "gray"),  
#     strip.text = element_text(size = 12, color = "black", face = "bold"),  
#     axis.text.x = element_text(size = 8, color = "black", angle = 0)
#   )
# 
# ####abs logFC####
# ggplot(filtered_toptables_RUV_p53_comp, aes(x = Conditions, y = abs_logFC, fill = Timepoint)) +
#   geom_boxplot() +
#   scale_fill_manual(values = c(
#     "24T" = "#238B45",
#     "24R" = "#74C476",
#     "144R" = "#C7E9C0")) +  
#   facet_grid(~Conditions) +  
#   geom_text(
#     data = wilcox_results_plot_p53, 
#     aes(x = x_position, y = y_pos, label = significance), 
#     size = 6, fontface = "bold", color = "black", inherit.aes = FALSE
#   ) +
#   theme_bw() +
#   xlab("") +
#   ylab("|Log Fold Change|") +  
#   ggtitle("|Log Fold Change| for p53 Target Genes") +
#   theme(
#     plot.title = element_text(size = rel(1.5), hjust = 0.5),
#     axis.title = element_text(size = 15, color = "black"),
#     axis.line = element_line(linewidth = 1.5),
#     strip.background = element_rect(fill = "gray"),  
#     strip.text = element_text(size = 12, color = "black", face = "bold"),  
#     axis.text.x = element_text(size = 8, color = "black", angle = 0)
#   )
```
```{r test (come back to me later), include = FALSE}
# Comparisons <- tribble(
#   ~group1, ~group2,
#   "24T",   "24R",
#   "24T",   "144R",
#   "24R",   "144R"
# )
# 
# wilcox_results_p53 <- filtered_toptables_RUV_p53_comp %>%
#   wilcox_test(abs_logFC ~ Timepoint) %>%
#   adjust_pvalue(method = "bonferroni") %>%
#   mutate(significance = ifelse(p < 0.05, "*", "")) %>%
#   mutate(Comparisons = paste(group1, "vs", group2, sep = " "))
# 
# #make a little thing of your timepoint comparisons
# pairs_p53 <- wilcox_results_p53 %>% 
#   dplyr::select(group1, group2) %>% 
#   distinct()
# 
# max_per_timepoint_p53 <- filtered_toptables_RUV_p53_comp %>% 
#   group_by(Timepoint) %>% 
#   summarise(max_logFC = max(abs_logFC, na.rm = TRUE), .groups = "drop")
#   
# #Join max values for group1
# star_positions_p53 <- pairs_p53 %>%
#   left_join(max_per_timepoint_p53, by = c("group1" = "Timepoint"))
# names(star_positions_p53)[names(star_positions_p53) == "max_logFC"] <- "max1"
# 
# #Join max values for group2, with suffixes to avoid name conflict
# star_positions_p53 <- star_positions_p53 %>%
#   left_join(max_per_timepoint_p53, by = c("group2" = "Timepoint"), suffix = c(".group1", ".group2"))
# names(star_positions_p53)[names(star_positions_p53) == "max_logFC"] <- "max2"
# 
# star_positions_p53 <- star_positions_p53 %>% 
#   mutate(y_pos = pmax(max1, max2, na.rm = TRUE) + 0.2)
# 
# #now star positions has the same group1 and group2 as wilcoxon
# 
# wilcox_results_plot_p53 <- wilcox_results_p53 %>%
#   left_join(star_positions_p53, by = c("group1", "group2")) %>%
#   mutate(x_position = 1.5)  
# 
# wilcox_results_plot_p53 <- wilcox_results_plot_p53 %>%
#   mutate(x_position = case_when(
#     group1 == "24T" & group2 == "24R" ~ 1.5,
#     group1 == "24T" & group2 == "144R" ~ 2,
#     group1 == "24R" & group2 == "144R" ~ 2.5
#   ))
# 
# # wilcox_results_plot_p53 <- wilcox_results_plot_p53 %>% 
# #   mutate(Comparisons = factor(paste(group1, "vs", group2),
# #                          levels = c("24T vs 24R", 
# #                                     "24T vs 144R", 
# #                                     "24R vs 144R"))
# #   )
# 
# wilcox_results_plot_p53 <- wilcox_results_plot_p53 %>%
#   mutate(
#     # create ordered pairs so the smaller/lower factor is always first
#     group_ordered = map2_chr(group1, group2, ~ paste(sort(c(.x, .y)), collapse = " vs ")),
#     Comparisons = factor(group_ordered, levels = c("24T vs 24R", "24T vs 144R", "24R vs 144R"))
#   )
# 
# # LogFC plot
# ggplot(filtered_toptables_RUV_p53_comp, aes(x = Timepoint, y = logFC, fill = Timepoint)) +
#   geom_boxplot() +
#   scale_fill_manual(values = c(
#     "24T" = "#238B45",
#     "24R" = "#74C476",
#     "144R" = "#C7E9C0")) +  
#   facet_wrap(~Conditions) +  
#   geom_text(
#     data = wilcox_results_plot_p53, 
#     aes(x = x_position, y = y_pos, label = p.adj.signif),
#     size = 6, fontface = "bold", color = "black", inherit.aes = FALSE
#   ) +
#   theme_bw() +
#   xlab("") +
#   ylab("Log Fold Change") +  
#   ggtitle("Log Fold Change for p53 Target Genes") +
#   theme(
#     plot.title = element_text(size = rel(1.5), hjust = 0.5),
#     axis.title = element_text(size = 15, color = "black"),
#     axis.line = element_line(linewidth = 1.5),
#     strip.background = element_rect(fill = "gray"),  
#     strip.text = element_text(size = 12, color = "black", face = "bold"),  
#     axis.text.x = element_text(size = 8, color = "black")
#   )
# 
# # Absolute logFC plot
# ggplot(filtered_toptables_RUV_p53_comp, aes(x = Timepoint, y = abs_logFC, fill = Timepoint)) +
#   geom_boxplot() +
#   scale_fill_manual(values = c(
#     "24T" = "#238B45",
#     "24R" = "#74C476",
#     "144R" = "#C7E9C0")) +  
#   facet_wrap(~Conditions) +  
#   geom_text(
#     data = wilcox_results_plot_p53, 
#     aes(x = x_position, y = y_pos, label = significance),
#     size = 6, fontface = "bold", color = "black", inherit.aes = FALSE
#   ) +
#   theme_bw() +
#   xlab("") +
#   ylab("|Log Fold Change|") +  
#   ggtitle("|Log Fold Change| for p53 Target Genes") +
#   theme(
#     plot.title = element_text(size = rel(1.5), hjust = 0.5),
#     axis.title = element_text(size = 15, color = "black"),
#     axis.line = element_line(linewidth = 1.5),
#     strip.background = element_rect(fill = "gray"),  
#     strip.text = element_text(size = 12, color = "black", face = "bold"),  
#     axis.text.x = element_text(size = 8, color = "black")
#   )
```


I am going to now identify the proportion of DDR genes within my timepoints and compare against non-DEGs for all timepoints
#Proportion Barplots of Gene Sets
```{r Proportion Barplot DDR RUVs DEGs vs nonDEGs}

#read in my DDR gene set
DNA_damage <- readRDS("data/new/RUV/DDR_Genes_list_RUV.RDS")

#pull out only the unique values that are not NA (there aren't any anyways)
ddr_set <- unique(na.omit(DNA_damage$Entrez_ID))
#pull out the gene symbols
gene_symbols_DDR_R <- names(DNA_damage)
#pull out the entrez ids
entrezids_DDR_R <- unname(DNA_damage)
#calculate the total length of my gene set for proportion analysis
total_ddr_genes <- length(ddr_set)
cat("Total DNA damage genes:", total_ddr_genes, "\n")
#should be 65 total genes

#load in DEGs for all timepoints 
DOX_24T_R <- read.csv("data/new/DEGs/Toptable_RUV_24T_final.csv") %>% 
  dplyr::select(-(X))
DOX_24R_R <- read.csv("data/new/DEGs/Toptable_RUV_24R_final.csv") %>% 
  dplyr::select(-(X))
DOX_144R_R <- read.csv("data/new/DEGs/Toptable_RUV_144R_final.csv") %>% 
  dplyr::select(-(X))

# Extract Significant DEGs from these lists
DEGs_24T_R <- DOX_24T_R$Entrez_ID[DOX_24T_R$adj.P.Val < 0.05]
DEGs_24R_R <- DOX_24R_R$Entrez_ID[DOX_24R_R$adj.P.Val < 0.05]
DEGs_144R_R <- DOX_144R_R$Entrez_ID[DOX_144R_R$adj.P.Val < 0.05]

#make a list of all of my DEGs
timepoint_DEGs_RUV <- list(
  "24T" = DEGs_24T_R,
  "24R" = DEGs_24R_R,
  "144R" = DEGs_144R_R
)

#then pull the background (all genes tested)
all_genes <- rownames(filcpm_matrix)
length(all_genes)
#14319 in length, containing all genes tested (background)

#fisher's exact test framework
fisher_results_ddr <- purrr::map_dfr(names(timepoint_DEGs_RUV), function(tp_ddr) {
  degs_ddr <- unique(timepoint_DEGs_RUV[[tp_ddr]])
  non_degs_ddr <- setdiff(all_genes, degs_ddr)

  in_deg_ddr     <- sum(degs_ddr %in% ddr_set)
  in_deg_nonddr  <- length(degs_ddr) - in_deg_ddr
  out_deg_ddr    <- sum(non_degs_ddr %in% ddr_set)
  out_deg_nonddr <- length(non_degs_ddr) - out_deg_ddr

  contingency_deg_ddr <- matrix(c(in_deg_ddr, in_deg_nonddr,
                          out_deg_ddr, out_deg_nonddr),
                        nrow = 2, byrow = TRUE)

  test_ddr <- fisher.test(contingency_deg_ddr)
  #print these results
  print(test_ddr)

  tibble(
    Timepoint = tp_ddr,
    In_DEG_DDR = in_deg_ddr,
    In_DEG_NonDDR = in_deg_nonddr,
    Out_DEG_DDR = out_deg_ddr,
    Out_DEG_NonDDR = out_deg_nonddr,
    Total_DEGs = length(degs_ddr),
    Proportion_DDR = in_deg_ddr / length(degs_ddr),
    P_Value = test_ddr$p.value,
    Significant = ifelse(test_ddr$p.value < 0.05, "*", "")
  )
})

#configure my results for plotting
motif_long_degs_ddr <- fisher_results_ddr %>%
  select(Timepoint, In_DEG_DDR, In_DEG_NonDDR, P_Value, Significant) %>%
  pivot_longer(cols = c(In_DEG_DDR, In_DEG_NonDDR),
               names_to = "Category", values_to = "Count") %>%
  mutate(
    Category = ifelse(Category == "In_DEG_DDR", "Yes", "No"),
    Fraction = Count / ave(Count, Timepoint, FUN = sum)
  )

#set category order (Yes on top)
motif_long_degs_ddr$Category <- 
  factor(motif_long_degs_ddr$Category, levels = c("Yes", "No"))

#label positions for significance stars
label_positions_degs_ddr <- motif_long_degs_ddr %>%
  filter(Category == "Yes") %>%
  mutate(y_pos = Fraction + 1.01)

#plot results in a barplot
ggplot(motif_long_degs_ddr, aes(x = Timepoint, y = Fraction, fill = Category)) +
  geom_bar(stat = "identity", position = "stack") +
  geom_text(
    data = label_positions_degs_ddr %>% filter(Significant != ""),
    aes(y = y_pos, label = Significant),
    size = 6,
    fontface = "bold"
  ) +
  scale_y_continuous(labels = scales::percent_format(scale = 1), limits = c(0, 1.08)) +
  scale_fill_manual(values = c("Yes" = "#e41a1c", "No" = "#377eb8")) +
  labs(
    title = "Proportion of DNA Damage Genes in DEGs vs NonDEGs (24T, 24R, 144R)",
    x = "Timepoint",
    y = "Percentage",
    fill = "DNA Damage Gene"
  ) +
  theme_minimal() +
  theme(
    axis.title = element_text(size = 14),
    axis.text = element_text(size = 12),
    plot.title = element_text(size = 16, hjust = 0.5)
  )

#--- Optional: Print result table ---#
print(fisher_results_ddr)




###########################################
#DDR genes inside each timepoint
in_24T_DDR <- sum(DEGs_24T_R %in% ddr_set)
in_24R_DDR <- sum(DEGs_24R_R %in% ddr_set)
in_144R_DDR <- sum(DEGs_144R_R %in% ddr_set)

#non-DDR genes inside each motif
in_24T_nonDDR <- length(DEGs_24T_R) - in_24T_DDR
in_24R_nonDDR <- length(DEGs_24R_R) - in_24R_DDR
in_144R_nonDDR <- length(DEGs_144R_R) - in_144R_DDR

#make contingency tables for fishers exact tests
contingency_degs_ddr <- matrix(c(
  in_24T_DDR, in_24T_nonDDR,
  in_24R_DDR, in_24R_nonDDR,
  in_144R_DDR, in_144R_nonDDR),
  nrow = 3, byrow = TRUE
)

#print the contingency tables
print(contingency_degs_ddr)

#perform a fisher's exact test (small sample size)
fisher_test_degs_ddr <- fisher.test(contingency_degs_ddr)
#print fisher's exact test results
print(fisher_test_motifs_DDR)

#make a summary table of all of these data to plot
motif_summary_DDR <- tibble(
  Motif = c("Motif1", "Motif2"),
  DDR = c(in_motif1_DDR, in_motif2_DDR),
  non_DDR = c(in_motif1_nonDDR, in_motif2_nonDDR)
) %>%
  pivot_longer(cols = c(DDR, non_DDR), names_to = "Category", values_to = "Count") %>%
  mutate(
    Category = ifelse(Category == "DDR", "Yes", "No"),
    Fraction = Count / ave(Count, Motif, FUN = sum),
    Significant = ifelse(Category == "Yes" & fisher_test_motifs_DDR$p.value < 0.05, "*", "")
  )

#position significance stars just above bars
label_positions_DDR <- motif_summary_DDR %>%
  filter(Category == "Yes") %>%
  mutate(y_pos = Fraction + 1.01)

#change the ordering so that yes is on the top
motif_summary_DDR$Category <- factor(motif_summary_DDR$Category, levels = c("Yes", "No"))

#plot the proportions in a barplot
ggplot(motif_summary_DDR, aes(x = Motif, y = Fraction, fill = Category)) +
  geom_bar(stat = "identity", position = "stack") +
  geom_text(
    data = label_positions_DDR %>% filter(Significant != ""),
    aes(x = Motif, y = y_pos, label = Significant),
    size = 6,
    color = "black",
    fontface = "bold"
  ) +
  scale_y_continuous(labels = scales::percent_format(scale = 1), limits = c(0, 1.08)) +
  scale_fill_manual(values = c("Yes" = "#e41a1c", "No" = "#377eb8")) +
  labs(
    title = "Proportion of DDR Genes in Motif 1 vs Motif 2 (RUVs clust + p.post)",
    x = "Cormotif Motif",
    y = "Percentage",
    fill = "DDR Gene"
  ) +
  theme_minimal() +
  theme(
    axis.title = element_text(size = 14),
    axis.text = element_text(size = 12),
    plot.title = element_text(size = 16, hjust = 0.5)
  )


#print the proportions and p values
prop_motif1_DDR <- in_motif1_DDR / length(final_genes_1_RUV)
prop_motif2_DDR <- in_motif2_DDR / length(final_genes_2_RUV)
p_val_DDR <- fisher_test_motifs_DDR$p.value

cat(sprintf("Motif1: %.2f%% DDR genes (%d/%d)\n", 100*prop_motif1_DDR, in_motif1_DDR, length(final_genes_1_RUV)))
cat(sprintf("Motif2: %.2f%% DDR genes (%d/%d)\n", 100*prop_motif2_DDR, in_motif2_DDR, length(final_genes_2_RUV)))
cat(sprintf("DDR Fisher's Exact Test p-value: %.5f\n", p_val_DDR))
cat(sprintf("Odds ratio: %.3f\n", fisher_test_motifs_DDR$estimate))

```


```{r Proportion Barplot DEGs vs nonDEGs, fig.height=6, fig.width=10}
# Inputs:
#  - DEGs_24T_R, DEGs_24R_R, DEGs_144R_R: vectors of significant DEG Entrez IDs
#  - all_genes: vector of all tested genes (e.g., from full expression matrix)
#  - ddr_set: vector of DNA damage response gene Entrez IDs

#read in my DDR gene set
DNA_damage <- readRDS("data/new/RUV/DDR_genes_entrezid.RDS")

#pull out only the unique values that are not NA (there aren't any anyways)
ddr_set <- unique(na.omit(DNA_damage))
#pull out the entrez ids
entrezids_DDR_R <- unname(DNA_damage)
#calculate the total length of my gene set for proportion analysis
total_ddr_genes <- length(ddr_set)
cat("Total DNA damage genes:", total_ddr_genes, "\n")
#should be 65 total genes

#DEGs list
timepoint_DEGs_ddr <- list(
  "24T"   = DEGs_24T_R,
  "24R"   = DEGs_24R_R,
  "144R"  = DEGs_144R_R
)

#then pull the background (all genes tested)
all_genes <- rownames(filcpm_matrix)
length(all_genes)
#14319 in length, containing all genes tested (background)


#collect results into a data frame
proportion_data_ddr <- purrr::map_dfr(names(timepoint_DEGs_ddr), function(tp_ddr) {
  degs_ddr <- unique(timepoint_DEGs_ddr[[tp_ddr]])
  nondegs_ddr <- setdiff(all_genes, degs_ddr)
  
  in_deg_ddr <- sum(degs_ddr %in% ddr_set)
  in_deg_nonddr <- length(degs_ddr) - in_deg_ddr
  in_deg_total <- length(degs_ddr)
  
  in_nondeg_ddr <- sum(nondegs_ddr %in% ddr_set)
  in_nondeg_nonddr <- length(nondegs_ddr) - in_nondeg_ddr
  in_nondeg_total <- length(nondegs_ddr)
  
  #fisher's exact test for DEGs vs non-DEGs
  contingency_degs_ddr <- matrix(c(in_deg_ddr, in_deg_nonddr,
                          in_nondeg_ddr, in_nondeg_nonddr),
                        nrow = 2, byrow = TRUE)

  fisher_res_ddr <- fisher.test(contingency_degs_ddr)
  p_val_ddr <- fisher_res_ddr$p.value
  sig_ddr <- ifelse(p_val_ddr < 0.05, "*", "")
  
  #print the fisher's exact test values
  print(fisher_res_ddr)
  
tibble(
  Timepoint = rep(tp_ddr, 4),
  Group = c("DEGs", "DEGs", "nonDEGs", "nonDEGs"),
  Category = c("Yes", "No", "Yes", "No"),
  Count = c(in_deg_ddr, in_deg_nonddr, in_nondeg_ddr, in_nondeg_nonddr),
  Total = c(length(degs_ddr), length(degs_ddr), length(nondegs_ddr), length(nondegs_ddr)),
  P_Value = rep(p_val_ddr, 4),
  Significant = rep(sig_ddr, 4)
)
}) %>%
  mutate(
    Fraction = Count / Total,
    Group_Label = paste(Timepoint, Group, sep = "_"),
    Group_Label = factor(Group_Label, levels = c(
      "24T_DEGs", "24T_nonDEGs",
      "24R_DEGs", "24R_nonDEGs",
      "144R_DEGs", "144R_nonDEGs"
    )),
    Category = factor(Category, levels = c("Yes", "No"))  # Stack "Yes" on top
  )

# Prepare position labels
label_positions_ddr <- proportion_data_ddr %>%
  filter(Category == "Yes") %>%
  mutate(y_pos = Fraction + 1.02)

#make it so that yes is on top
proportion_data_ddr$Category <- factor(proportion_data_ddr$Category, levels = c("Yes", "No"))

#plot
ggplot(proportion_data_ddr, aes(x = Group_Label, y = Fraction, fill = Category)) +
  geom_bar(stat = "identity", position = "stack") +
  geom_text(
    data = label_positions_ddr %>% filter(Significant != ""),
    aes(x = Group_Label, y = y_pos, label = Significant),
    size = 6,
    color = "black",
    fontface = "bold"
  ) +
  scale_y_continuous(labels = scales::percent_format(scale = 1), limits = c(0, 1.08)) +
  scale_fill_manual(values = c("Yes" = "#e41a1c", "No" = "#377eb8")) +
  labs(
    title = "Proportion of DDR Genes in DEGs vs nonDEGs per Timepoint",
    x = "Timepoint and Group",
    y = "Percentage",
    fill = "DDR Gene"
  ) +
  theme_minimal() +
  theme(
    axis.title = element_text(size = 14),
    axis.text = element_text(size = 12),
    plot.title = element_text(size = 16, hjust = 0.5)
  )

```

##Proportion Barplot DIC Genes
```{r DIC Proportion Barplot DEGs vs nonDEGs, fig.height=6, fig.width=10}

# Inputs:
#  - DEGs_24T_R, DEGs_24R_R, DEGs_144R_R: vectors of significant DEG Entrez IDs
#  - all_genes: vector of all tested genes (e.g., from full expression matrix)
#  - ddr_set: vector of DNA damage response gene Entrez IDs

#read in my DIC gene set
DIC_genes <- readRDS("data/new/RUV/DIC_genes_entrezid.RDS")

#pull out only the unique values that are not NA (there aren't any anyways)
dic_set <- unique(na.omit(DIC_genes))
#pull out the entrez ids
entrezids_dic <- unname(DIC_genes)
#calculate the total length of my gene set for proportion analysis
total_dic_genes <- length(dic_set)
cat("Total DIC genes:", total_dic_genes, "\n")
#should be 27 total genes

#DEGs list
timepoint_DEGs_dic <- list(
  "24T"   = DEGs_24T_R,
  "24R"   = DEGs_24R_R,
  "144R"  = DEGs_144R_R
)

#then pull the background (all genes tested)
all_genes <- rownames(filcpm_matrix)
length(all_genes)
#14319 in length, containing all genes tested (background)


#collect results into a data frame
proportion_data_dic <- purrr::map_dfr(names(timepoint_DEGs_dic), function(tp_dic) {
  degs_dic <- unique(timepoint_DEGs_dic[[tp_dic]])
  nondegs_dic <- setdiff(all_genes, degs_dic)
  
  in_deg_dic <- sum(degs_dic %in% dic_set)
  in_deg_nondic <- length(degs_dic) - in_deg_dic
  in_deg_total <- length(degs_dic)
  
  in_nondeg_dic <- sum(nondegs_dic %in% dic_set)
  in_nondeg_nondic <- length(nondegs_dic) - in_nondeg_dic
  in_nondeg_total <- length(nondegs_dic)
  
  #fisher's exact test for DEGs vs non-DEGs
  contingency_degs_dic <- matrix(c(in_deg_dic, in_deg_nondic,
                          in_nondeg_dic, in_nondeg_nondic),
                        nrow = 2, byrow = TRUE)

  fisher_res_dic <- fisher.test(contingency_degs_dic)
  p_val_dic <- fisher_res_dic$p.value
  sig_dic <- ifelse(p_val_dic < 0.05, "*", "")
  
  #print the fisher's exact test values
  print(fisher_res_dic)
  
tibble(
  Timepoint = rep(tp_dic, 4),
  Group = c("DEGs", "DEGs", "nonDEGs", "nonDEGs"),
  Category = c("Yes", "No", "Yes", "No"),
  Count = c(in_deg_dic, in_deg_nondic, in_nondeg_dic, in_nondeg_nondic),
  Total = c(length(degs_dic), length(degs_dic), length(nondegs_dic), length(nondegs_dic)),
  P_Value = rep(p_val_dic, 4),
  Significant = rep(sig_dic, 4)
)
}) %>%
  mutate(
    Fraction = Count / Total,
    Group_Label = paste(Timepoint, Group, sep = "_"),
    Group_Label = factor(Group_Label, levels = c(
      "24T_DEGs", "24T_nonDEGs",
      "24R_DEGs", "24R_nonDEGs",
      "144R_DEGs", "144R_nonDEGs"
    )),
    Category = factor(Category, levels = c("Yes", "No"))  # Stack "Yes" on top
  )

# Prepare position labels
label_positions_dic <- proportion_data_dic %>%
  filter(Category == "Yes") %>%
  mutate(y_pos = Fraction + 1.02)

#make it so that yes is on top
proportion_data_dic$Category <- factor(proportion_data_dic$Category, levels = c("Yes", "No"))

#plot
ggplot(proportion_data_dic, aes(x = Group_Label, y = Fraction, fill = Category)) +
  geom_bar(stat = "identity", position = "stack") +
  geom_text(
    data = label_positions_dic %>% filter(Significant != ""),
    aes(x = Group_Label, y = y_pos, label = Significant),
    size = 6,
    color = "black",
    fontface = "bold"
  ) +
  scale_y_continuous(labels = scales::percent_format(scale = 1), limits = c(0, 1.08)) +
  scale_fill_manual(values = c("Yes" = "#e41a1c", "No" = "#377eb8")) +
  labs(
    title = "Proportion of DIC Genes in DEGs vs nonDEGs per Timepoint",
    x = "Timepoint and Group",
    y = "Percentage",
    fill = "DIC Gene"
  ) +
  theme_minimal() +
  theme(
    axis.title = element_text(size = 14),
    axis.text = element_text(size = 12),
    plot.title = element_text(size = 16, hjust = 0.5)
  )

```

##Proportion Barplots AIC DEGs
```{r AIC Proportion Barplots fig.height=6, fig.width=10}
# Inputs:
#  - DEGs_24T_R, DEGs_24R_R, DEGs_144R_R: vectors of significant DEG Entrez IDs
#  - all_genes: vector of all tested genes (e.g., from full expression matrix)
#  - aic_set: vector of AIC gene Entrez IDs

# AIC_entrez <- AIC_genelist_symbolentrez_RUV$Entrez_ID
# saveRDS(AIC_entrez, "data/new/RUV/AIC_genes_entrezid.RDS")

#read in my AIC gene set
AIC_genes <- readRDS("data/new/RUV/AIC_genes_entrezid.RDS")

#pull out only the unique values that are not NA (there aren't any anyways)
AIC_set <- unique(na.omit(AIC_genes))
#pull out the entrez ids
entrezids_AIC <- unname(AIC_set)
#calculate the total length of my gene set for proportion analysis
total_AIC_genes <- length(AIC_set)
cat("Total AIC Target genes:", total_AIC_genes, "\n")
#should be 38 total genes

#DEGs list
timepoint_DEGs_AIC <- list(
  "24T"   = DEGs_24T_R,
  "24R"   = DEGs_24R_R,
  "144R"  = DEGs_144R_R
)

#then pull the background (all genes tested)
all_genes <- rownames(filcpm_matrix)
length(all_genes)
#14319 in length, containing all genes tested (background)


#collect results into a data frame
proportion_data_AIC <- purrr::map_dfr(names(timepoint_DEGs_AIC), function(tp_AIC) {
  degs_AIC <- unique(timepoint_DEGs_AIC[[tp_AIC]])
  nondegs_AIC <- setdiff(all_genes, degs_AIC)
  
  in_deg_AIC <- sum(degs_AIC %in% AIC_set)
  in_deg_nonAIC <- length(degs_AIC) - in_deg_AIC
  in_deg_total <- length(degs_AIC)
  
  in_nondeg_AIC <- sum(nondegs_AIC %in% AIC_set)
  in_nondeg_nonAIC <- length(nondegs_AIC) - in_nondeg_AIC
  in_nondeg_total <- length(nondegs_AIC)
  
  #fisher's exact test for DEGs vs non-DEGs
  contingency_degs_AIC <- matrix(c(in_deg_AIC, in_deg_nonAIC,
                          in_nondeg_AIC, in_nondeg_nonAIC),
                        nrow = 2, byrow = TRUE)

  fisher_res_AIC <- fisher.test(contingency_degs_AIC)
  p_val_AIC <- fisher_res_AIC$p.value
  sig_AIC <- ifelse(p_val_AIC < 0.05, "*", "")
  
  #print the fisher's exact test values
  print(fisher_res_AIC)
  
tibble(
  Timepoint = rep(tp_AIC, 4),
  Group = c("DEGs", "DEGs", "nonDEGs", "nonDEGs"),
  Category = c("Yes", "No", "Yes", "No"),
  Count = c(in_deg_AIC, in_deg_nonAIC, in_nondeg_AIC, in_nondeg_nonAIC),
  Total = c(length(degs_AIC), length(degs_AIC), length(nondegs_AIC), length(nondegs_AIC)),
  P_Value = rep(p_val_AIC, 4),
  Significant = rep(sig_AIC, 4)
)
}) %>%
  mutate(
    Fraction = Count / Total,
    Group_Label = paste(Timepoint, Group, sep = "_"),
    Group_Label = factor(Group_Label, levels = c(
      "24T_DEGs", "24T_nonDEGs",
      "24R_DEGs", "24R_nonDEGs",
      "144R_DEGs", "144R_nonDEGs"
    )),
    Category = factor(Category, levels = c("Yes", "No"))  # Stack "Yes" on top
  )

# Prepare position labels
label_positions_AIC <- proportion_data_AIC %>%
  filter(Category == "Yes") %>%
  mutate(y_pos = Fraction + 1.02)

#make it so that yes is on top
proportion_data_AIC$Category <- factor(proportion_data_AIC$Category, levels = c("Yes", "No"))

#plot
ggplot(proportion_data_AIC, aes(x = Group_Label, y = Fraction, fill = Category)) +
  geom_bar(stat = "identity", position = "stack") +
  geom_text(
    data = label_positions_AIC %>% filter(Significant != ""),
    aes(x = Group_Label, y = y_pos, label = Significant),
    size = 6,
    color = "black",
    fontface = "bold"
  ) +
  scale_y_continuous(labels = scales::percent_format(scale = 1), limits = c(0, 1.08)) +
  scale_fill_manual(values = c("Yes" = "#e41a1c", "No" = "#377eb8")) +
  labs(
    title = "Proportion of AIC Genes in DEGs vs nonDEGs per Timepoint",
    x = "Timepoint and Group",
    y = "Percentage",
    fill = "AIC Gene"
  ) +
   theme_minimal() +
  theme(
    axis.title = element_text(size = 14),
    axis.text = element_text(size = 12),
    plot.title = element_text(size = 16, hjust = 0.5)
  )
```

##Proportion Barplots p53 DEGs
```{r p53 Proportion Barplots DEGs vs nonDEGs, fig.height=6, fig.width=10}

# Inputs:
#  - DEGs_24T_R, DEGs_24R_R, DEGs_144R_R: vectors of significant DEG Entrez IDs
#  - all_genes: vector of all tested genes (e.g., from full expression matrix)
#  - ddr_set: vector of DNA damage response gene Entrez IDs

#read in my gene set
p53_target_genes <- readRDS("data/new/RUV/p53_targetgenes_entrezid.RDS")

#pull out only the unique values that are not NA (there aren't any anyways)
p53_set <- unique(na.omit(p53_target_genes))
#pull out the entrez ids
entrezids_p53 <- unname(p53_set)
#calculate the total length of my gene set for proportion analysis
total_p53_genes <- length(p53_set)
cat("Total p53 Target genes:", total_p53_genes, "\n")
#should be 300 total genes

#DEGs list
timepoint_DEGs_p53 <- list(
  "24T"   = DEGs_24T_R,
  "24R"   = DEGs_24R_R,
  "144R"  = DEGs_144R_R
)

#then pull the background (all genes tested)
all_genes <- rownames(filcpm_matrix)
length(all_genes)
#14319 in length, containing all genes tested (background)


#collect results into a data frame
proportion_data_p53 <- purrr::map_dfr(names(timepoint_DEGs_p53), function(tp_p53) {
  degs_p53 <- unique(timepoint_DEGs_p53[[tp_p53]])
  nondegs_p53 <- setdiff(all_genes, degs_p53)
  
  in_deg_p53 <- sum(degs_p53 %in% p53_set)
  in_deg_nonp53 <- length(degs_p53) - in_deg_p53
  in_deg_total <- length(degs_p53)
  
  in_nondeg_p53 <- sum(nondegs_p53 %in% p53_set)
  in_nondeg_nonp53 <- length(nondegs_p53) - in_nondeg_p53
  in_nondeg_total <- length(nondegs_p53)
  
  #fisher's exact test for DEGs vs non-DEGs
  contingency_degs_p53 <- matrix(c(in_deg_p53, in_deg_nonp53,
                          in_nondeg_p53, in_nondeg_nonp53),
                        nrow = 2, byrow = TRUE)

  fisher_res_p53 <- fisher.test(contingency_degs_p53)
  p_val_p53 <- fisher_res_p53$p.value
  sig_p53 <- ifelse(p_val_p53 < 0.05, "*", "")
  
  #print the fisher's exact test values
  print(fisher_res_p53)
  
tibble(
  Timepoint = rep(tp_p53, 4),
  Group = c("DEGs", "DEGs", "nonDEGs", "nonDEGs"),
  Category = c("Yes", "No", "Yes", "No"),
  Count = c(in_deg_p53, in_deg_nonp53, in_nondeg_p53, in_nondeg_nonp53),
  Total = c(length(degs_p53), length(degs_p53), length(nondegs_p53), length(nondegs_p53)),
  P_Value = rep(p_val_p53, 4),
  Significant = rep(sig_p53, 4)
)
}) %>%
  mutate(
    Fraction = Count / Total,
    Group_Label = paste(Timepoint, Group, sep = "_"),
    Group_Label = factor(Group_Label, levels = c(
      "24T_DEGs", "24T_nonDEGs",
      "24R_DEGs", "24R_nonDEGs",
      "144R_DEGs", "144R_nonDEGs"
    )),
    Category = factor(Category, levels = c("Yes", "No"))  # Stack "Yes" on top
  )

# Prepare position labels
label_positions_p53 <- proportion_data_p53 %>%
  filter(Category == "Yes") %>%
  mutate(y_pos = Fraction + 1.02)

#make it so that yes is on top
proportion_data_p53$Category <- factor(proportion_data_p53$Category, levels = c("Yes", "No"))

#plot
ggplot(proportion_data_p53, aes(x = Group_Label, y = Fraction, fill = Category)) +
  geom_bar(stat = "identity", position = "stack") +
  geom_text(
    data = label_positions_p53 %>% filter(Significant != ""),
    aes(x = Group_Label, y = y_pos, label = Significant),
    size = 6,
    color = "black",
    fontface = "bold"
  ) +
  scale_y_continuous(labels = scales::percent_format(scale = 1), limits = c(0, 1.08)) +
  scale_fill_manual(values = c("Yes" = "#e41a1c", "No" = "#377eb8")) +
  labs(
    title = "Proportion of p53 Genes in DEGs vs nonDEGs per Timepoint",
    x = "Timepoint and Group",
    y = "Percentage",
    fill = "p53 Gene"
  ) +
  theme_minimal() +
  theme(
    axis.title = element_text(size = 14),
    axis.text = element_text(size = 12),
    plot.title = element_text(size = 16, hjust = 0.5)
  )
```


#Read in my DEGs Data
```{r Read and Process DEGs Data}
#read in boxplot1 for my log2cpm data
boxplot1 <- read.csv("data/new/filcpm_final_matrix.csv") %>% 
  as.data.frame()
#this dataframe is unchanged

# Load Toptables
deg_files_ruv <- list.files("data/new/DEGs", pattern = "Toptable_RUV.*\\.csv", full.names = TRUE)
deg_list_ruv <- lapply(deg_files_ruv, read.csv)
names(deg_list_ruv) <- gsub("data/DEGs/Toptable_|\\.csv", "", deg_files_ruv)  

# Function to check significance based on **Entrez_ID in the correct sample**
is_significant <- function(gene, drug, conc, timepoint) {
  condition <- paste(drug, conc, timepoint, sep = "_")
  if (!condition %in% names(deg_list_ruv)) return(FALSE)
  
  toptable <- deg_list[[condition]]
  gene_entrez <- boxplot1$ENTREZID[boxplot1$SYMBOL == gene]
  
  if (length(gene_entrez) == 0) return(FALSE)
  
  return(any(gene_entrez %in% toptable$Entrez_ID[toptable$adj.P.Val < 0.05]))
}

```

##Process Data for Plotting RUVs logFC Boxplots
```{r Process Data for Plotting RUVs logFC Boxplots}

process_gene_data_DDR_RUVs_boxplots <- function(gene) {
  gene_data_boxplots_RUVs <- boxplot1 %>% filter(SYMBOL == gene)
  # Reshape data
  long_data_RUV_DDR <- gene_data_boxplots_RUVs %>%
    pivot_longer(cols = -c(Entrez_ID, SYMBOL), names_to = "Sample", values_to = "log2CPM") %>%
    mutate(
      Drug = case_when(
        grepl("DOX", Sample) ~ "DOX",
        grepl("DMSO", Sample) ~ "DMSO",
        TRUE ~ NA_character_
      ),
      Timepoint = case_when(
        grepl("_24T_", Sample) ~ "24T",
        grepl("_24R_", Sample) ~ "24R",
        grepl("_144R_", Sample) ~ "144R",
        TRUE ~ NA_character_
      ),
      Indv = case_when(
        grepl("Ind1$", Sample) ~ "1",
        grepl("Ind2$", Sample) ~ "2",
        grepl("Ind3$", Sample) ~ "3",
        grepl("Ind4$", Sample) ~ "4",
        grepl("Ind5$", Sample) ~ "5",
        grepl("Ind6$", Sample) ~ "6",
        grepl("Ind6R$", Sample) ~ "6R",
        TRUE ~ NA_character_
      ),
      Condition = paste(Drug, Timepoint, Indv, sep = "_")
    )
  long_data$Condition <- factor(
    long_data$Condition,
    levels = c(
      "DOX_24T", 
      "DMSO_24T", 
      "DOX_24R", 
      "DMSO_24R", 
      "DOX_144R", 
      "DMSO_144R"
    )
  )
    # Identify significant conditions **per Drug, Conc, and Timepoint**
  significance_labels <- long_data_RUV_DDR %>%
    distinct(Drug, Timepoint, Indv) %>%
    rowwise() %>%
    mutate(
      max_log2CPM = max(long_data_RUV_DDR$log2CPM[long_data_RUV_DDR$Condition == Condition], na.rm = TRUE),
      Significance = ifelse(is_significant(gene, Drug, Timepoint, Indv), "*", "")
    ) %>%
    filter(Significance != "") %>% ungroup()
  
  list(long_data_RUV_DDR = long_data_RUV_DDR, significance_labels = significance_labels)
}

#####now I can go ahead and generate boxplots as requested
#want one for DDR, one for DIC, and one for p53

#genelists:
DDR_genes_ruv <- all_data_DDR_RUV$Gene
DIC_genes_ruv <- all_data_DIC_RUV$Gene
p53_genes_ruv <- all_data_p53_RUV$Gene

# #Generate Boxplots from the above function using our gene lists above
# for (gene in boxplot1) {
#   gene_data_boxplots_RUVs <- process_top5_D24R_1(gene)
#   p <- ggplot(gene_data_boxplots_RUVs, aes(x = Condition, y = log2cpm, fill = Drug)) +
#     geom_boxplot(outlier.shape = NA) +
#     geom_point(aes(color = Indv), size = 2, alpha = 0.5, position = position_jitter(width = -1, height = 0)) +
#     scale_fill_manual(values = c("DOX" = "#499FBD", "DMSO" = "#BBBBBC")) +
#     ggtitle(paste("Log2cpm", gene, "top5DEGs D24R RUVs")) +
#     labs(x = "Treatment", y = "log2cpm") +
#     theme_bw() +
#     theme(
#       plot.title = element_text(size = rel(2), hjust = 0.5),
#       axis.title = element_text(size = 15, color = "black"),
#       axis.text.x = element_text(size = 10, color = "black", angle = 90, hjust = 1)
#     )
#   print(p)
# }

```

#Cormotif Function
```{r Cormotif Function}
## Fit limma model using code as it is found in the original cormotif code. It has
## only been modified to add names to the matrix of t values, as well as the
## limma fits

limmafit.default <- function(exprs,groupid,compid) {
  limmafits  <- list()
  compnum    <- nrow(compid)
  genenum    <- nrow(exprs)
  limmat     <- matrix(0,genenum,compnum)
  limmas2    <- rep(0,compnum)
  limmadf    <- rep(0,compnum)
  limmav0    <- rep(0,compnum)
  limmag1num <- rep(0,compnum)
  limmag2num <- rep(0,compnum)

  rownames(limmat)  <- rownames(exprs)
  colnames(limmat)  <- rownames(compid)
  names(limmas2)    <- rownames(compid)
  names(limmadf)    <- rownames(compid)
  names(limmav0)    <- rownames(compid)
  names(limmag1num) <- rownames(compid)
  names(limmag2num) <- rownames(compid)

  for(i in 1:compnum) {
    selid1 <- which(groupid == compid[i,1])
    selid2 <- which(groupid == compid[i,2])
    eset   <- new("ExpressionSet", exprs=cbind(exprs[,selid1],exprs[,selid2]))
    g1num  <- length(selid1)
    g2num  <- length(selid2)
    designmat <- cbind(base=rep(1,(g1num+g2num)), delta=c(rep(0,g1num),rep(1,g2num)))
    fit <- lmFit(eset,designmat)
    fit <- eBayes(fit)
    limmat[,i] <- fit$t[,2]
    limmas2[i] <- fit$s2.prior
    limmadf[i] <- fit$df.prior
    limmav0[i] <- fit$var.prior[2]
    limmag1num[i] <- g1num
    limmag2num[i] <- g2num
    limmafits[[i]] <- fit

    # log odds
    # w<-sqrt(1+fit$var.prior[2]/(1/g1num+1/g2num))
    # log(0.99)+dt(fit$t[1,2],g1num+g2num-2+fit$df.prior,log=TRUE)-log(0.01)-dt(fit$t[1,2]/w, g1num+g2num-2+fit$df.prior, log=TRUE)+log(w)
  }
  names(limmafits) <- rownames(compid)
  limmacompnum<-nrow(compid)
  result<-list(t       = limmat,
               v0      = limmav0,
               df0     = limmadf,
               s20     = limmas2,
               g1num   = limmag1num,
               g2num   = limmag2num,
               compnum = limmacompnum,
               fits    = limmafits)
}

limmafit.counts <-
  function (exprs, groupid, compid, norm.factor.method = "TMM", voom.normalize.method = "none")
  {
    limmafits  <- list()
    compnum    <- nrow(compid)
    genenum    <- nrow(exprs)
    limmat     <- matrix(NA,genenum,compnum)
    limmas2    <- rep(0,compnum)
    limmadf    <- rep(0,compnum)
    limmav0    <- rep(0,compnum)
    limmag1num <- rep(0,compnum)
    limmag2num <- rep(0,compnum)

    rownames(limmat)  <- rownames(exprs)
    colnames(limmat)  <- rownames(compid)
    names(limmas2)    <- rownames(compid)
    names(limmadf)    <- rownames(compid)
    names(limmav0)    <- rownames(compid)
    names(limmag1num) <- rownames(compid)
    names(limmag2num) <- rownames(compid)

    for (i in 1:compnum) {
      message(paste("Running limma for comparision",i,"/",compnum))
      selid1 <- which(groupid == compid[i, 1])
      selid2 <- which(groupid == compid[i, 2])
      # make a new count data frame
      counts <- cbind(exprs[, selid1], exprs[, selid2])

      # remove NAs
      not.nas <- which(apply(counts, 1, function(x) !any(is.na(x))) == TRUE)

      # runn voom/limma
      d <- DGEList(counts[not.nas,])
      d <- calcNormFactors(d, method = norm.factor.method)
      g1num <- length(selid1)
      g2num <- length(selid2)
      designmat <- cbind(base = rep(1, (g1num + g2num)), delta = c(rep(0,
                                                                       g1num), rep(1, g2num)))

      y <- voom(d, designmat, normalize.method = voom.normalize.method)
      fit <- lmFit(y, designmat)
      fit <- eBayes(fit)

      limmafits[[i]] <- fit
      limmat[not.nas, i] <- fit$t[, 2]
      limmas2[i] <- fit$s2.prior
      limmadf[i] <- fit$df.prior
      limmav0[i] <- fit$var.prior[2]
      limmag1num[i] <- g1num
      limmag2num[i] <- g2num
    }
    limmacompnum <- nrow(compid)
    names(limmafits) <- rownames(compid)
    result <- list(t       = limmat,
                   v0      = limmav0,
                   df0     = limmadf,
                   s20     = limmas2,
                   g1num   = limmag1num,
                   g2num   = limmag2num,
                   compnum = limmacompnum,
                   fits    = limmafits)
  }

limmafit.list <-
  function (fitlist, cmp.idx=2)
  {
    compnum    <- length(fitlist)

    genes <- c()
    for (i in 1:compnum) genes <- unique(c(genes, rownames(fitlist[[i]])))

    genenum    <- length(genes)
    limmat     <- matrix(NA,genenum,compnum)
    limmas2    <- rep(0,compnum)
    limmadf    <- rep(0,compnum)
    limmav0    <- rep(0,compnum)
    limmag1num <- rep(0,compnum)
    limmag2num <- rep(0,compnum)

    rownames(limmat)  <- genes
    colnames(limmat)  <- names(fitlist)
    names(limmas2)    <- names(fitlist)
    names(limmadf)    <- names(fitlist)
    names(limmav0)    <- names(fitlist)
    names(limmag1num) <- names(fitlist)
    names(limmag2num) <- names(fitlist)

    for (i in 1:compnum) {
      this.t <- fitlist[[i]]$t[,cmp.idx]
      limmat[names(this.t),i] <- this.t

      limmas2[i]    <- fitlist[[i]]$s2.prior
      limmadf[i]    <- fitlist[[i]]$df.prior
      limmav0[i]    <- fitlist[[i]]$var.prior[cmp.idx]
      limmag1num[i] <- sum(fitlist[[i]]$design[,cmp.idx]==0)
      limmag2num[i] <- sum(fitlist[[i]]$design[,cmp.idx]==1)
    }

    limmacompnum <- compnum
    result <- list(t       = limmat,
                   v0      = limmav0,
                   df0     = limmadf,
                   s20     = limmas2,
                   g1num   = limmag1num,
                   g2num   = limmag2num,
                   compnum = limmacompnum,
                   fits    = limmafits)

  }

## Rank genes based on statistics
generank<-function(x) {
  xcol<-ncol(x)
  xrow<-nrow(x)
  result<-matrix(0,xrow,xcol)
  z<-(1:1:xrow)
  for(i in 1:xcol) {
    y<-sort(x[,i],decreasing=TRUE,na.last=TRUE)
    result[,i]<-match(x[,i],y)
    result[,i]<-order(result[,i])
  }
  result
}

## Log-likelihood for moderated t under H0
modt.f0.loglike<-function(x,df) {
  a<-dt(x, df, log=TRUE)
  result<-as.vector(a)
  flag<-which(is.na(result)==TRUE)
  result[flag]<-0
  result
}

## Log-likelihood for moderated t under H1
## param=c(df,g1num,g2num,v0)
modt.f1.loglike<-function(x,param) {
  df<-param[1]
  g1num<-param[2]
  g2num<-param[3]
  v0<-param[4]
  w<-sqrt(1+v0/(1/g1num+1/g2num))
  dt(x/w, df, log=TRUE)-log(w)
  a<-dt(x/w, df, log=TRUE)-log(w)
  result<-as.vector(a)
  flag<-which(is.na(result)==TRUE)
  result[flag]<-0
  result
}

## Correlation Motif Fit
cmfit.X<-function(x, type, K=1, tol=1e-3, max.iter=100) {
  ## initialize
  xrow <- nrow(x)
  xcol <- ncol(x)
  loglike0 <- list()
  loglike1 <- list()
  p <- rep(1, K)/K
  q <- matrix(runif(K * xcol), K, xcol)
  q[1, ] <- rep(0.01, xcol)
  for (i in 1:xcol) {
    f0 <- type[[i]][[1]]
    f0param <- type[[i]][[2]]
    f1 <- type[[i]][[3]]
    f1param <- type[[i]][[4]]
    loglike0[[i]] <- f0(x[, i], f0param)
    loglike1[[i]] <- f1(x[, i], f1param)
  }
  condlike <- list()
  for (i in 1:xcol) {
    condlike[[i]] <- matrix(0, xrow, K)
  }
  loglike.old <- -1e+10
  for (i.iter in 1:max.iter) {
    if ((i.iter%%50) == 0) {
      print(paste("We have run the first ", i.iter, " iterations for K=",
                  K, sep = ""))
    }
    err <- tol + 1
    clustlike <- matrix(0, xrow, K)
    #templike <- matrix(0, xrow, 2)
    templike1 <- rep(0, xrow)
    templike2 <- rep(0, xrow)
    for (j in 1:K) {
      for (i in 1:xcol) {
        templike1 <- log(q[j, i]) + loglike1[[i]]
        templike2 <- log(1 - q[j, i]) + loglike0[[i]]
        tempmax <- Rfast::Pmax(templike1, templike2)

        templike1 <- exp(templike1 - tempmax)
        templike2 <- exp(templike2 - tempmax)

        tempsum <- templike1 + templike2
        clustlike[, j] <- clustlike[, j] + tempmax +
          log(tempsum)
        condlike[[i]][, j] <- templike1/tempsum
      }
      clustlike[, j] <- clustlike[, j] + log(p[j])
    }
    #tempmax <- apply(clustlike, 1, max)
    tempmax <- Rfast::rowMaxs(clustlike, value=TRUE)
    for (j in 1:K) {
      clustlike[, j] <- exp(clustlike[, j] - tempmax)
    }
    #tempsum <- apply(clustlike, 1, sum)
    tempsum <- Rfast::rowsums(clustlike)
    for (j in 1:K) {
      clustlike[, j] <- clustlike[, j]/tempsum
    }
    #p.new <- (apply(clustlike, 2, sum) + 1)/(xrow + K)
    p.new <- (Rfast::colsums(clustlike) + 1)/(xrow + K)
    q.new <- matrix(0, K, xcol)
    for (j in 1:K) {
      clustpsum <- sum(clustlike[, j])
      for (i in 1:xcol) {
        q.new[j, i] <- (sum(clustlike[, j] * condlike[[i]][,
                                                           j]) + 1)/(clustpsum + 2)
      }
    }
    err.p <- max(abs(p.new - p)/p)
    err.q <- max(abs(q.new - q)/q)
    err <- max(err.p, err.q)
    loglike.new <- (sum(tempmax + log(tempsum)) + sum(log(p.new)) +
                      sum(log(q.new) + log(1 - q.new)))/xrow
    p <- p.new
    q <- q.new
    loglike.old <- loglike.new
    if (err < tol) {
      break
    }
  }
  clustlike <- matrix(0, xrow, K)
  for (j in 1:K) {
    for (i in 1:xcol) {
      templike1 <- log(q[j, i]) + loglike1[[i]]
      templike2 <- log(1 - q[j, i]) + loglike0[[i]]
      tempmax <- Rfast::Pmax(templike1, templike2)

      templike1 <- exp(templike1 - tempmax)
      templike2 <- exp(templike2 - tempmax)

      tempsum <- templike1 + templike2
      clustlike[, j] <- clustlike[, j] + tempmax + log(tempsum)
      condlike[[i]][, j] <- templike1/tempsum
    }
    clustlike[, j] <- clustlike[, j] + log(p[j])
  }
  #tempmax <- apply(clustlike, 1, max)
  tempmax <- Rfast::rowMaxs(clustlike, value=TRUE)
  for (j in 1:K) {
    clustlike[, j] <- exp(clustlike[, j] - tempmax)
  }
  #tempsum <- apply(clustlike, 1, sum)
  tempsum <- Rfast::rowsums(clustlike)
  for (j in 1:K) {
    clustlike[, j] <- clustlike[, j]/tempsum
  }
  p.post <- matrix(0, xrow, xcol)
  for (j in 1:K) {
    for (i in 1:xcol) {
      p.post[, i] <- p.post[, i] + clustlike[, j] * condlike[[i]][,
                                                                  j]
    }
  }
  loglike.old <- loglike.old - (sum(log(p)) + sum(log(q) +
                                                    log(1 - q)))/xrow
  loglike.old <- loglike.old * xrow
  result <- list(p.post = p.post, motif.prior = p, motif.q = q,
                 loglike = loglike.old, clustlike=clustlike, condlike=condlike)
}

## Fit using (0,0,...,0) and (1,1,...,1)
cmfitall<-function(x, type, tol=1e-3, max.iter=100) {
  ## initialize
  xrow<-nrow(x)
  xcol<-ncol(x)
  loglike0<-list()
  loglike1<-list()
  p<-0.01

  ## compute loglikelihood
  L0<-matrix(0,xrow,1)
  L1<-matrix(0,xrow,1)
  for(i in 1:xcol) {
    f0<-type[[i]][[1]]
    f0param<-type[[i]][[2]]
    f1<-type[[i]][[3]]
    f1param<-type[[i]][[4]]
    loglike0[[i]]<-f0(x[,i],f0param)
    loglike1[[i]]<-f1(x[,i],f1param)
    L0<-L0+loglike0[[i]]
    L1<-L1+loglike1[[i]]
  }


  ## EM algorithm to get MLE of p and q
  loglike.old <- -1e10
  for(i.iter in 1:max.iter) {
    if((i.iter%%50) == 0) {
      print(paste("We have run the first ", i.iter, " iterations",sep=""))
    }
    err<-tol+1

    ## compute posterior cluster membership
    clustlike<-matrix(0,xrow,2)
    clustlike[,1]<-log(1-p)+L0
    clustlike[,2]<-log(p)+L1

    tempmax<-apply(clustlike,1,max)
    for(j in 1:2) {
      clustlike[,j]<-exp(clustlike[,j]-tempmax)
    }
    tempsum<-apply(clustlike,1,sum)

    ## update motif occurrence rate
    for(j in 1:2) {
      clustlike[,j]<-clustlike[,j]/tempsum
    }

    p.new<-(sum(clustlike[,2])+1)/(xrow+2)

    ## evaluate convergence
    err<-abs(p.new-p)/p

    ## evaluate whether the log.likelihood increases
    loglike.new<-(sum(tempmax+log(tempsum))+log(p.new)+log(1-p.new))/xrow

    loglike.old<-loglike.new
    p<-p.new

    if(err<tol) {
      break;
    }
  }

  ## compute posterior p
  clustlike<-matrix(0,xrow,2)
  clustlike[,1]<-log(1-p)+L0
  clustlike[,2]<-log(p)+L1

  tempmax<-apply(clustlike,1,max)
  for(j in 1:2) {
    clustlike[,j]<-exp(clustlike[,j]-tempmax)
  }
  tempsum<-apply(clustlike,1,sum)

  for(j in 1:2) {
    clustlike[,j]<-clustlike[,j]/tempsum
  }

  p.post<-matrix(0,xrow,xcol)
  for(i in 1:xcol) {
    p.post[,i]<-clustlike[,2]
  }

  ## return

  #calculate back loglikelihood
  loglike.old<-loglike.old-(log(p)+log(1-p))/xrow
  loglike.old<-loglike.old*xrow
  result<-list(p.post=p.post, motif.prior=p, loglike=loglike.old)
}

## Fit each dataset separately
cmfitsep<-function(x, type, tol=1e-3, max.iter=100) {
  ## initialize
  xrow<-nrow(x)
  xcol<-ncol(x)
  loglike0<-list()
  loglike1<-list()
  p<-0.01*rep(1,xcol)
  loglike.final<-rep(0,xcol)

  ## compute loglikelihood
  for(i in 1:xcol) {
    f0<-type[[i]][[1]]
    f0param<-type[[i]][[2]]
    f1<-type[[i]][[3]]
    f1param<-type[[i]][[4]]
    loglike0[[i]]<-f0(x[,i],f0param)
    loglike1[[i]]<-f1(x[,i],f1param)
  }

  p.post<-matrix(0,xrow,xcol)

  ## EM algorithm to get MLE of p
  for(coli in 1:xcol) {
    loglike.old <- -1e10
    for(i.iter in 1:max.iter) {
      if((i.iter%%50) == 0) {
        print(paste("We have run the first ", i.iter, " iterations",sep=""))
      }
      err<-tol+1

      ## compute posterior cluster membership
      clustlike<-matrix(0,xrow,2)
      clustlike[,1]<-log(1-p[coli])+loglike0[[coli]]
      clustlike[,2]<-log(p[coli])+loglike1[[coli]]

      tempmax<-apply(clustlike,1,max)
      for(j in 1:2) {
        clustlike[,j]<-exp(clustlike[,j]-tempmax)
      }
      tempsum<-apply(clustlike,1,sum)

      ## evaluate whether the log.likelihood increases
      loglike.new<-sum(tempmax+log(tempsum))/xrow

      ## update motif occurrence rate
      for(j in 1:2) {
        clustlike[,j]<-clustlike[,j]/tempsum
      }

      p.new<-(sum(clustlike[,2]))/(xrow)

      ## evaluate convergence
      err<-abs(p.new-p[coli])/p[coli]
      loglike.old<-loglike.new
      p[coli]<-p.new

      if(err<tol) {
        break;
      }
    }

    ## compute posterior p
    clustlike<-matrix(0,xrow,2)
    clustlike[,1]<-log(1-p[coli])+loglike0[[coli]]
    clustlike[,2]<-log(p[coli])+loglike1[[coli]]

    tempmax<-apply(clustlike,1,max)
    for(j in 1:2) {
      clustlike[,j]<-exp(clustlike[,j]-tempmax)
    }
    tempsum<-apply(clustlike,1,sum)

    for(j in 1:2) {
      clustlike[,j]<-clustlike[,j]/tempsum
    }

    p.post[,coli]<-clustlike[,2]
    loglike.final[coli]<-loglike.old
  }


  ## return
  loglike.final<-loglike.final*xrow
  result<-list(p.post=p.post, motif.prior=p, loglike=loglike.final)
}

## Fit the full model
cmfitfull<-function(x, type, tol=1e-3, max.iter=100) {
  ## initialize
  xrow<-nrow(x)
  xcol<-ncol(x)
  loglike0<-list()
  loglike1<-list()
  K<-2^xcol
  p<-rep(1,K)/K
  pattern<-rep(0,xcol)
  patid<-matrix(0,K,xcol)

  ## compute loglikelihood
  for(i in 1:xcol) {
    f0<-type[[i]][[1]]
    f0param<-type[[i]][[2]]
    f1<-type[[i]][[3]]
    f1param<-type[[i]][[4]]
    loglike0[[i]]<-f0(x[,i],f0param)
    loglike1[[i]]<-f1(x[,i],f1param)
  }
  L<-matrix(0,xrow,K)
  for(i in 1:K)
  {
    patid[i,]<-pattern
    for(j in 1:xcol) {
      if(pattern[j] < 0.5) {
        L[,i]<-L[,i]+loglike0[[j]]
      } else {
        L[,i]<-L[,i]+loglike1[[j]]
      }
    }

    if(i < K) {
      pattern[xcol]<-pattern[xcol]+1
      j<-xcol
      while(pattern[j] > 1) {
        pattern[j]<-0
        j<-j-1
        pattern[j]<-pattern[j]+1
      }
    }
  }

  ## EM algorithm to get MLE of p and q
  loglike.old <- -1e10
  for(i.iter in 1:max.iter) {
    if((i.iter%%50) == 0) {
      print(paste("We have run the first ", i.iter, " iterations",sep=""))
    }
    err<-tol+1

    ## compute posterior cluster membership
    clustlike<-matrix(0,xrow,K)
    for(j in 1:K) {
      clustlike[,j]<-log(p[j])+L[,j]
    }

    tempmax<-apply(clustlike,1,max)
    for(j in 1:K) {
      clustlike[,j]<-exp(clustlike[,j]-tempmax)
    }
    tempsum<-apply(clustlike,1,sum)

    ## update motif occurrence rate
    for(j in 1:K) {
      clustlike[,j]<-clustlike[,j]/tempsum
    }

    p.new<-(apply(clustlike,2,sum)+1)/(xrow+K)

    ## evaluate convergence
    err<-max(abs(p.new-p)/p)

    ## evaluate whether the log.likelihood increases
    loglike.new<-(sum(tempmax+log(tempsum))+sum(log(p.new)))/xrow

    loglike.old<-loglike.new
    p<-p.new

    if(err<tol) {
      break;
    }
  }

  ## compute posterior p
  clustlike<-matrix(0,xrow,K)
  for(j in 1:K) {
    clustlike[,j]<-log(p[j])+L[,j]
  }

  tempmax<-apply(clustlike,1,max)
  for(j in 1:K) {
    clustlike[,j]<-exp(clustlike[,j]-tempmax)
  }
  tempsum<-apply(clustlike,1,sum)

  for(j in 1:K) {
    clustlike[,j]<-clustlike[,j]/tempsum
  }

  p.post<-matrix(0,xrow,xcol)
  for(j in 1:K) {
    for(i in 1:xcol) {
      if(patid[j,i] > 0.5) {
        p.post[,i]<-p.post[,i]+clustlike[,j]
      }
    }
  }

  ## return
  #calculate back loglikelihood
  loglike.old<-loglike.old-sum(log(p))/xrow
  loglike.old<-loglike.old*xrow
  result<-list(p.post=p.post, motif.prior=p, loglike=loglike.old)
}

generatetype<-function(limfitted)
{
  jtype<-list()
  df<-limfitted$g1num+limfitted$g2num-2+limfitted$df0
  for(j in 1:limfitted$compnum)
  {
    jtype[[j]]<-list(f0=modt.f0.loglike, f0.param=df[j], f1=modt.f1.loglike, f1.param=c(df[j],limfitted$g1num[j],limfitted$g2num[j],limfitted$v0[j]))
  }
  jtype
}

cormotiffit <- function(exprs, groupid=NULL, compid=NULL, K=1, tol=1e-3,
                        max.iter=100, BIC=TRUE, norm.factor.method="TMM",
                        voom.normalize.method = "none", runtype=c("logCPM","counts","limmafits"), each=3)
{
  # first I want to do some typechecking. Input can be either a normalized
  # matrix, a count matrix, or a list of limma fits. Dispatch the correct
  # limmafit accordingly.
  # todo: add some typechecking here
  limfitted <- list()
  if (runtype=="counts") {DOX_24T_shared_DEGs
    limfitted <- limmafit.counts(exprs,groupid,compid, norm.factor.method, voom.normalize.method)
  } else if (runtype=="logCPM") {
    limfitted <- limmafit.default(exprs,groupid,compid)
  } else if (runtype=="limmafits") {
    limfitted <- limmafit.list(exprs)
  } else {
    stop("runtype must be one of 'logCPM', 'counts', or 'limmafits'")
  }


  jtype<-generatetype(limfitted)
  fitresult<-list()
  ks <- rep(K, each = each)
  fitresult <- bplapply(1:length(ks), function(i, x, type, ks, tol, max.iter) {
    cmfit.X(x, type, K = ks[i], tol = tol, max.iter = max.iter)
  }, x=limfitted$t, type=jtype, ks=ks, tol=tol, max.iter=max.iter)

  best.fitresults <- list()
  for (i in 1:length(K)) {
    w.k <- which(ks==K[i])
    this.bic <- c()
    for (j in w.k) this.bic[j] <- -2 * fitresult[[j]]$loglike + (K[i] - 1 + K[i] * limfitted$compnum) * log(dim(limfitted$t)[1])
    w.min <- which(this.bic == min(this.bic, na.rm = TRUE))[1]
    best.fitresults[[i]] <- fitresult[[w.min]]
  }
  fitresult <- best.fitresults

  bic <- rep(0, length(K))
  aic <- rep(0, length(K))
  loglike <- rep(0, length(K))
  for (i in 1:length(K)) loglike[i] <- fitresult[[i]]$loglike
  for (i in 1:length(K)) bic[i] <- -2 * fitresult[[i]]$loglike + (K[i] - 1 + K[i] * limfitted$compnum) * log(dim(limfitted$t)[1])
  for (i in 1:length(K)) aic[i] <- -2 * fitresult[[i]]$loglike + 2 * (K[i] - 1 + K[i] * limfitted$compnum)
  if(BIC==TRUE) {
    bestflag=which(bic==min(bic))
  }
  else {
    bestflag=which(aic==min(aic))
  }
  result<-list(bestmotif=fitresult[[bestflag]],bic=cbind(K,bic),
               aic=cbind(K,aic),loglike=cbind(K,loglike), allmotifs=fitresult)

}

cormotiffitall<-function(exprs,groupid,compid, tol=1e-3, max.iter=100)
{
  limfitted<-limmafit(exprs,groupid,compid)
  jtype<-generatetype(limfitted)
  fitresult<-cmfitall(limfitted$t,type=jtype,tol=1e-3,max.iter=max.iter)
}

cormotiffitsep<-function(exprs,groupid,compid, tol=1e-3, max.iter=100)
{
  limfitted<-limmafit(exprs,groupid,compid)
  jtype<-generatetype(limfitted)
  fitresult<-cmfitsep(limfitted$t,type=jtype,tol=1e-3,max.iter=max.iter)
}

cormotiffitfull<-function(exprs,groupid,compid, tol=1e-3, max.iter=100)
{
  limfitted<-limmafit(exprs,groupid,compid)
  jtype<-generatetype(limfitted)
  fitresult<-cmfitfull(limfitted$t,type=jtype,tol=1e-3,max.iter=max.iter)
}

plotIC<-function(fitted_cormotif)
{
  oldpar<-par(mfrow=c(1,2))
  plot(fitted_cormotif$bic[,1], fitted_cormotif$bic[,2], type="b",xlab="Motif Number", ylab="BIC", main="BIC")
  plot(fitted_cormotif$aic[,1], fitted_cormotif$aic[,2], type="b",xlab="Motif Number", ylab="AIC", main="AIC")
}

plotMotif<-function(fitted_cormotif,title="")
{
  layout(matrix(1:2,ncol=2))
  u<-1:dim(fitted_cormotif$bestmotif$motif.q)[2]
  v<-1:dim(fitted_cormotif$bestmotif$motif.q)[1]
  image(u,v,t(fitted_cormotif$bestmotif$motif.q),
        col=gray(seq(from=1,to=0,by=-0.1)),xlab="Study",yaxt = "n",
        ylab="Corr. Motifs",main=paste(title,"pattern",sep=" "))
  axis(2,at=1:length(v))
  for(i in 1:(length(u)+1))
  {
    abline(v=(i-0.5))
  }
  for(i in 1:(length(v)+1))
  {
    abline(h=(i-0.5))
  }
  Ng=10000
  if(is.null(fitted_cormotif$bestmotif$p.post)!=TRUE)
    Ng=nrow(fitted_cormotif$bestmotif$p.post)
  genecount=floor(fitted_cormotif$bestmotif$motif.p*Ng)
  NK=nrow(fitted_cormotif$bestmotif$motif.q)
  plot(0,0.7,pch=".",xlim=c(0,1.2),ylim=c(0.75,NK+0.25),
       frame.plot=FALSE,axes=FALSE,xlab="No. of genes",ylab="", main=paste(title,"frequency",sep=" "))
  segments(0,0.7,fitted_cormotif$bestmotif$motif.p[1],0.7)
  rect(0,1:NK-0.3,fitted_cormotif$bestmotif$motif.p,1:NK+0.3,
       col="dark grey")
  mtext(1:NK,at=1:NK,side=2,cex=0.8)
  text(fitted_cormotif$bestmotif$motif.p+0.15,1:NK,
       labels=floor(fitted_cormotif$bestmotif$motif.p*Ng))
}

```


```{r Cormotif Library}
#Don't load me in if you're using the above function, as it has been modified above
#library(Cormotif)
```

##Input Data for Cormotif Original Matrix
```{r Cormotif Data}

#input the cormotif matrix you're going to use
##this should be tmm normalized log2cpm

#the matrix that I used previously for limma was TMM counts - cpm this
#dge was the name of the DGE list object

cormotif_test <- cpm(dge, log = TRUE)
colnames(cormotif_test) <- (Metadata_2$Final_sample_name)

cormotif_counts <- dge

cormotif_test_df <- cormotif_test %>% 
  as.data.frame() %>% 
  rownames_to_column(., var = "Entrez_ID")

#write.csv(cormotif_test, "data/new/Cormotif_test_matrix.csv")

#reorder my test matrix to match the new groupid I've made
#I want my columns to be in this order:
#DOX24T 1-6, DOX24R 1-6, DOX144R 1-6, DMSO24T 1-6, DMSO24R 1-6, DMSO144R 1-6
Cormotif <- read.csv("data/new/Cormotif_matrix_final.csv")
dim(Cormotif)
#14319 genes across 37 cols (1 is Entrez_ID)
Cormotif_df <- data.frame(Cormotif)

rownames(Cormotif_df) <- Cormotif_df$Entrez_ID
exprs.cormotif <- as.matrix(Cormotif_df[,2:37])
dim(exprs.cormotif)

#put together my group id and comparison id to make the correct comparisons between experimental conditions

#groupid tells which experimental conditions are grouped together
#compid tells which experimental conditions should be compared against one another
##ie DOX24T vs DMSO24T matched control

groupid_csv <- read.csv("data/new/GroupID.csv")
#now I have to make this into a vector (named vector)
groupid <- c(
  DOX_24T_1 = 1, 
  DOX_24T_2 = 1, 
  DOX_24T_3 = 1, 
  DOX_24T_4 = 1, 
  DOX_24T_5 = 1, 
  DOX_24T_6 = 1,
  DOX_24R_1 = 2, 
  DOX_24R_2 = 2, 
  DOX_24R_3 = 2, 
  DOX_24R_4 = 2, 
  DOX_24R_5 = 2, 
  DOX_24R_6 = 2,
  DOX_144R_1 = 3, 
  DOX_144R_2 = 3, 
  DOX_144R_3 = 3, 
  DOX_144R_4 = 3, 
  DOX_144R_5 = 3, 
  DOX_144R_6 = 3,
  DMSO_24T_1 = 4, 
  DMSO_24T_2 = 4, 
  DMSO_24T_3 = 4, 
  DMSO_24T_4 = 4, 
  DMSO_24T_5 = 4, 
  DMSO_24T_6 = 4,
  DMSO_24R_1 = 5, 
  DMSO_24R_2 = 5, 
  DMSO_24R_3 = 5, 
  DMSO_24R_4 = 5, 
  DMSO_24R_5 = 5, 
  DMSO_24R_6 = 5,
  DMSO_144R_1 = 6, 
  DMSO_144R_2 = 6, 
  DMSO_144R_3 = 6, 
  DMSO_144R_4 = 6, 
  DMSO_144R_5 = 6, 
  DMSO_144R_6 = 6
)
#saveRDS(groupid, "data/new/groupidCormotif.RDS")

compid <- data.frame(Cond1 = c(1, 2, 3), Cond2 = c(4, 5, 6))
#saveRDS(compid, "data/new/compidCormotif.RDS")
```

###Run Cormotif Original Data
```{r Run Cormotif}
#fit Cormotif model
# set.seed(19191)
#only set the seed ONCE

# motif.fitted_new <- cormotiffit(
#   exprs = exprs.cormotif,
#   groupid = groupid,
#   compid = compid,
#   K = 1:8,
#   max.iter = 1000,
#   BIC = TRUE,
#   runtype = "logCPM"
# )

# saveRDS(motif.fitted, "data/new/motif.fitted_new_250604.RDS")
motif.fitted <- readRDS("data/new/motif.fitted_final_3motif.RDS")
```

###Plotting Cormotif Original Data
```{r Plot Cormotif}

#plot BIC and AIC to see which number of motifs was best for both models
plotIC(motif.fitted)

motif.fitted$bic

#now plot the motifs themselves
plotMotif(motif.fitted, title = "Fitted Motifs for DXR")

#plot the probability legend
myColors <-  rev(c("#FFFFFF", "#E6E6E6" ,"#CCCCCC", "#B3B3B3", "#999999", "#808080", "#666666","#4C4C4C", "#333333", "#191919","#000000"))

plot.new()
legend('bottomleft',fill=myColors, legend =rev(c("0", "0.1", "0.2", "0.3", "0.4",  "0.5", "0.6", "0.7", "0.8","0.9", "1")), box.col="white",title = "Probability\nlegend", horiz=FALSE,title.cex=.8)

```


###Extract the Gene Probabilities
```{r Extract gene probabilities}
#extract the posterior probability that these DEGs belong to motifs
gene_prob_all <- motif.fitted$bestmotif$p.post
rownames(gene_prob_all) <- rownames(Cormotif_df)

#assign each gene to a motif with max post prob
assigned_motifs <- apply(gene_prob_all, 1, which.max)
max_probs <- apply(gene_prob_all, 1, max)

#combine these into a dataframe - motif assigned genes (p.post)
motif_assignment_df <- gene_prob_all %>%
  as.data.frame() %>%
  rownames_to_column("Gene") %>%
  mutate(
    Assigned_Motif = assigned_motifs[Gene],
    Max_Probability = max_probs[Gene]
  )

#make some histograms of the unfiltered data from Cormotif p.post

gene_prob_all %>% 
  as.data.frame() %>% 
  ggplot(., aes(x = V1))+
  geom_histogram(bins = 50)+
  xlim(0,1)+
  ggtitle("Cormotif Genes p.post Distribution M1")

gene_prob_all %>% 
  as.data.frame() %>% 
  ggplot(., aes(x = V2))+
  geom_histogram(bins = 50)+
  xlim(0,1)+
  ggtitle("Cormotif Genes p.post Distribution M2")

gene_prob_all %>% 
  as.data.frame() %>% 
  ggplot(., aes(x = V3))+
  geom_histogram(bins = 50)+
  xlim(0,1)+
  ggtitle("Cormotif Genes p.post Distribution M3")

#now change the probability cutoffs to get the ideal gene set with no overlaps

# Define gene probability groups
prob_all_1  <- rownames(gene_prob_all[(gene_prob_all[,1] >0.05 & gene_prob_all[,1] <0.3 & gene_prob_all[,2] <0.5 & gene_prob_all[,3] <0.5),])

length(prob_all_1)
#5675

prob_all_2  <- rownames(gene_prob_all[(gene_prob_all[,1] >0.5 & gene_prob_all[,2] <0.5 & gene_prob_all[,3] <0.5),])

length(prob_all_2)
#6353

prob_all_3  <- rownames(gene_prob_all[(gene_prob_all[,1] >0.3 & gene_prob_all[,1] <0.9 & gene_prob_all[,2] >0.5 & gene_prob_all[,3] >0.5),])

length(prob_all_3)
#231 genes with >0.3 <0.9 1

#compare between motif 1 and 2
mf1_genes <- prob_all_1
mf2_genes <- prob_all_2
mf3_genes <- prob_all_3

vennCor <- list(mf1_genes, mf2_genes, mf3_genes)
ggVennDiagram(
  vennCor,
  category.names = c("Motif 1", "Motif 2", "Motif 3")
) + ggtitle("Cormotif Specific and Shared DEGs p.post")+
  theme(
    plot.title = element_text(size = 16, face = "bold"),  # Increase title size
    text = element_text(size = 16)  # Increase text size globally
  )


#extract the cluster likelihood - which DEGs are most likely to be in this cluster
motif_prob <- motif.fitted$bestmotif$clustlike
rownames(motif_prob) <- rownames(gene_prob_all)
#write.csv(motif_prob,"data/new/cormotif_probability_genelist_all.csv")

#make some histograms to look at the distribution of clustlike genes without filtering
motif_prob %>% 
  as.data.frame() %>% 
  ggplot(., aes(x = V1))+
  geom_histogram(bins = 50)+
  xlim(0,1)+
  ggtitle("Cormotif Genes clustlike Distribution M1")

motif_prob %>% 
  as.data.frame() %>% 
  ggplot(., aes(x = V2))+
  geom_histogram(bins = 50)+
  xlim(0,1)+
  ggtitle("Cormotif Genes clustlike Distribution M2")

motif_prob %>% 
  as.data.frame() %>% 
  ggplot(., aes(x = V3))+
  geom_histogram(bins = 50)+
  xlim(0,1)+
  ggtitle("Cormotif Genes clustlike Distribution M3")

####try this Renee's way####
clust1_p <- motif_prob %>%
  as.data.frame() %>%
  filter(V1>0.5 & V2<0.5 & V3<0.5) %>% 
  rownames
clust2_p <- motif_prob %>%
  as.data.frame() %>%
  filter(V2>0.5 & V1<0.5 & V3<0.5) %>% 
  rownames
clust3_p <- motif_prob %>%
  as.data.frame() %>%
  filter(V3>0.5 & V1 <0.5 & V2 <0.5) %>% 
  rownames

length(clust1_p)
#6827 (too many)
length(clust2_p)
#6474
length(clust3_p)
#607

mf1_genes_p <- clust1_p
mf2_genes_p <- clust2_p
mf3_genes_p <- clust3_p

vennCor <- list(mf1_genes_p, mf2_genes_p, mf3_genes_p)
ggVennDiagram(
  vennCor,
  category.names = c("Motif 1", "Motif 2", "Motif 3")
) + ggtitle("Cormotif Specific and Shared DEGs clustlike")+
  theme(
    plot.title = element_text(size = 16, face = "bold"),  # Increase title size
    text = element_text(size = 16)  # Increase text size globally
  )

```

###Use Clustlike and P.post together for Cormotif
```{r Extract Gene Probability clust then p.post}
#begin with the clustlike cutoffs and then overlay the p.post to check if the genes are present in both

#these filters are the combination of the above analysis to get a gene set that fits in both p.post and clustlike

####motif 1####
#filter 1: clustlike
clust1_genes <- motif_prob %>%
  as.data.frame() %>%
  filter(V1>0.5 & V2<0.5 & V3<0.5) %>% 
  rownames
### Filter 2: Gene-level posterior pattern
prob_filtered_genes_1 <- rownames(gene_prob_all[(gene_prob_all[,1] >0.05 & gene_prob_all[,1] <0.3 & gene_prob_all[,2] <0.5 & gene_prob_all[,3] <0.5),])
### Final intersection of both filters
final_genes_1 <- intersect(clust1_genes, prob_filtered_genes_1)
cat("Number of genes passing both filters:", length(final_genes_1), "\n")

#5638 genes pass both filters here

####motif 2####
#filter 1: clustlike
clust2_genes <- motif_prob %>%
  as.data.frame() %>%
  filter(V2>0.5 & V1<0.5 & V3<0.5) %>% 
  rownames
### Filter 2: Gene-level posterior pattern
prob_filtered_genes_2 <- rownames(gene_prob_all[(gene_prob_all[,1] >0.5 & gene_prob_all[,2] <0.5 & gene_prob_all[,3] <0.5),])
### Final intersection of both filters
final_genes_2 <- intersect(clust2_genes, prob_filtered_genes_2)
cat("Number of genes passing both filters:", length(final_genes_2), "\n")

#6218 genes pass both filters here


####motif3####
#filter 1: clustlike
clust3_genes <- motif_prob %>%
  as.data.frame() %>%
  filter(V3 > 0.5 & V1 < 0.5 & V2 < 0.5) %>%
  rownames()
### Filter 2: Gene-level posterior pattern (Motif 2 & 3 high, Motif 1 intermediate)
prob_filtered_genes <- rownames(gene_prob_all[
  gene_prob_all[,1] > 0.3 & gene_prob_all[,1] < 0.9 &
  gene_prob_all[,2] > 0.5 &
  gene_prob_all[,3] > 0.5, ])
### Final intersection of both filters
final_genes_3 <- intersect(clust3_genes, prob_filtered_genes)
cat("Number of genes passing both filters:", length(final_genes_3), "\n")

#231 genes pass both filters here

#what is the proportion of my genes that are included?
5638+6218+231
#12087
(12087/14319)*100
#84.4% of my genes are represented here out of the 14319 original

#want to find out which genes are not assigned to motifs

final_genes_list <- union(final_genes_1, union(final_genes_2, final_genes_3))
length(final_genes_list)
#12087 genes as found above
initial_genes_list <- rownames(filcpm_matrix)
length(initial_genes_list)
#14319 genes as usual
unassigned_genes_list <- setdiff(initial_genes_list, final_genes_list)
length(unassigned_genes_list)
#2232 genes not assigned - correct number

#saveRDS(unassigned_genes_list, "data/new/Cormotif/unassigned_genes_Cormotif.RDS")

#now, ensure that none of these genes are shared amongst categories
vennCor_final <- list(final_genes_1, final_genes_2, final_genes_3)
ggVennDiagram(
  vennCor_final,
  category.names = c("Motif 1", "Motif 2", "Motif 3")
) + ggtitle("Cormotif Specific and Shared DEGs clustlike + p.post")+
  theme(
    plot.title = element_text(size = 16, face = "bold"),  # Increase title size
    text = element_text(size = 16)  # Increase text size globally
  )

#no overlapping genes found in these gene sets

clusterdata_dxr_fin <- data.frame(
  Category = c("Motif 1", "Motif 2", "Motif 3"), 
  Value = c(length(final_genes_1), length(final_genes_2), length(final_genes_3))
)

piecolors_dxr_fin <- c("Motif 1" = "#007896", 
                       "Motif 2" = "#58508D",
                       "Motif 3" = "#BC5090")

#make a piechart of these distributions
clusterdata_dxr_fin %>% ggplot(aes(x = "", y = Value, fill = Category))+
  geom_bar(width = 1, stat = "identity")+
  coord_polar("y", start = 0)+
  geom_text(aes(label = Value),
            position = position_stack(vjust = 0.5),
            size = 4, color = "black")+
  labs(title = "Distribution of Gene Clusters Identified By Cormotif", x = NULL, y = NULL)+
  theme_void()+
  scale_fill_manual(values = piecolors_dxr_fin)

#now, continue by plotting the logFC of all of these gene sets per motif, as well as look at some random genes for log2cpm to see if the patterns are reflected in the example genes


```

###Plot logFC of Clustlike vs P.post Cormotif
```{r logFC of Clustlike vs P.post Cormotif}
####clustlike logFC of initial set####
##motif 1
length(mf1_genes_p)
##motif 2 
length(mf2_genes_p)
##motif 3
length(mf3_genes_p)

#Combine the toptables I have from pairwise analysis into a single dataframe
d24_toptable_dxr <- Toptable_V.D24T %>% 
  rownames_to_column(var = "entrezgene_ID") %>% 
  mutate(Time = "24")

d24r_toptable_dxr <- Toptable_V.D24R %>% 
  rownames_to_column(var = "entrezgene_ID") %>% 
  mutate(Time = "24R")

d144r_toptable_dxr <- Toptable_V.D144R %>% 
  rownames_to_column(var = "entrezgene_ID") %>% 
  mutate(Time = "144R")

combined_toptables_dxr <- bind_rows(
  d24_toptable_dxr,
  d24r_toptable_dxr,
  d144r_toptable_dxr)

#Filter the data based on each motif
filt_toptable_dxr_fin <- combined_toptables_dxr %>% 
  dplyr::filter(entrezgene_ID  %in% mf1_genes_p) %>% 
  mutate(absFC = abs(logFC)) %>% 
  mutate(time = factor(Time, levels = c("24", "24R", "144R"), labels = c("24hr", "24hr Recovery", "144hr Recovery"))) %>% 
  ggplot(., aes(x = time, y = logFC))+
  geom_boxplot(aes(fill = time))+
  scale_fill_manual(values = time_col)+
  guides(fill = guide_legend(title = "Time"))+
  theme_bw()+
  xlab(" ")+
  ylab("logFC")+
  theme_bw()+
  ggtitle("LogFC for all genes in Motif 1 (n=6827)")+
  theme(plot.title = element_text(size = rel(1.5), hjust = 0.5),
        axis.title = element_text(size = 15, colour = "black"),
        strip.background = element_rect(fill = "#CAD899"),
        axis.text.x = element_text(size = 8, colour = "white", angle = 15),
        strip.text.x = element_text(size = 12, colour = "black", face = "bold"))

#motif 2
filt_toptable_2_dxr_fin <- combined_toptables_dxr %>% 
  dplyr::filter(entrezgene_ID  %in% final_genes_2) %>% 
  mutate(absFC = abs(logFC)) %>% 
  mutate(time = factor(Time, levels = c("24", "24R", "144R"), labels = c("24hr", "24hr Recovery", "144hr Recovery"))) %>% 
  ggplot(., aes(x = time, y = logFC))+
  geom_boxplot(aes(fill = time))+
  scale_fill_manual(values = time_col)+
  guides(fill = guide_legend(title = "Time"))+
  theme_bw()+
  xlab(" ")+
  ylab("logFC")+
  theme_bw()+
  ggtitle("LogFC for all genes in Motif 2 (n=6218)")+
  theme(plot.title = element_text(size = rel(1.5), hjust = 0.5),
        axis.title = element_text(size = 15, colour = "black"),
        strip.background = element_rect(fill = "#CAD899"),
        axis.text.x = element_text(size = 8, colour = "white", angle = 15),
        strip.text.x = element_text(size = 12, colour = "black", face = "bold"))

#motif 3
filt_toptable_3_dxr_fin <- combined_toptables_dxr %>% 
  dplyr::filter(entrezgene_ID  %in% final_genes_3) %>% 
  mutate(absFC = abs(logFC)) %>% 
  mutate(time = factor(Time, levels = c("24", "24R", "144R"), labels = c("24hr", "24hr Recovery", "144hr Recovery"))) %>% 
  ggplot(., aes(x = time, y = logFC))+
  geom_boxplot(aes(fill = time))+
  scale_fill_manual(values = time_col)+
  guides(fill = guide_legend(title = "Time"))+
  theme_bw()+
  xlab(" ")+
  ylab("logFC")+
  theme_bw()+
  ggtitle("LogFC for all genes in Motif 3 (n=231)")+
  theme(plot.title = element_text(size = rel(1.5), hjust = 0.5),
        axis.title = element_text(size = 15, colour = "black"),
        strip.background = element_rect(fill = "#CAD899"),
        axis.text.x = element_text(size = 8, colour = "white", angle = 15),
        strip.text.x = element_text(size = 12, colour = "black", face = "bold"))

#plots
filt_toptable_dxr_fin
filt_toptable_2_dxr_fin 
filt_toptable_3_dxr_fin


#now plot the abs logFC for each of these too
filt_toptable_abs_fin <- combined_toptables_dxr %>% 
  dplyr::filter(entrezgene_ID  %in% final_genes_1) %>% 
  mutate(absFC = abs(logFC)) %>% 
  mutate(time = factor(Time, levels = c("24", "24R", "144R"), labels = c("24hr", "24hr Recovery", "144hr Recovery"))) %>% 
  ggplot(., aes(x = time, y = absFC))+
  geom_boxplot(aes(fill = time))+
  scale_fill_manual(values = time_col)+
  guides(fill = guide_legend(title = "Time"))+
  theme_bw()+
  xlab(" ")+
  ylab("|logFC|")+
  theme_bw()+
  ggtitle("Abs LogFC for all genes in Motif 1 (n=5638)")+
  theme(plot.title = element_text(size = rel(1.5), hjust = 0.5),
        axis.title = element_text(size = 15, colour = "black"),
        strip.background = element_rect(fill = "#CAD899"),
        axis.text.x = element_text(size = 8, colour = "white", angle = 15),
        strip.text.x = element_text(size = 12, colour = "black", face = "bold"))

#motif 2
filt_toptable_2_abs_fin <- combined_toptables_dxr %>% 
  dplyr::filter(entrezgene_ID  %in% final_genes_2) %>% 
  mutate(absFC = abs(logFC)) %>% 
  mutate(time = factor(Time, levels = c("24", "24R", "144R"), labels = c("24hr", "24hr Recovery", "144hr Recovery"))) %>% 
  ggplot(., aes(x = time, y = absFC))+
  geom_boxplot(aes(fill = time))+
  scale_fill_manual(values = time_col)+
  guides(fill = guide_legend(title = "Time"))+
  theme_bw()+
  xlab(" ")+
  ylab("|logFC|")+
  theme_bw()+
  ggtitle("Abs LogFC for all genes in Motif 2 (n=6218)")+
  theme(plot.title = element_text(size = rel(1.5), hjust = 0.5),
        axis.title = element_text(size = 15, colour = "black"),
        strip.background = element_rect(fill = "#CAD899"),
        axis.text.x = element_text(size = 8, colour = "white", angle = 15),
        strip.text.x = element_text(size = 12, colour = "black", face = "bold"))

#motif 2
filt_toptable_3_abs_fin <- combined_toptables_dxr %>% 
  dplyr::filter(entrezgene_ID  %in% final_genes_3) %>% 
  mutate(absFC = abs(logFC)) %>% 
  mutate(time = factor(Time, levels = c("24", "24R", "144R"), labels = c("24hr", "24hr Recovery", "144hr Recovery"))) %>% 
  ggplot(., aes(x = time, y = absFC))+
  geom_boxplot(aes(fill = time))+
  scale_fill_manual(values = time_col)+
  guides(fill = guide_legend(title = "Time"))+
  theme_bw()+
  xlab(" ")+
  ylab("|logFC|")+
  theme_bw()+
  ggtitle("Abs LogFC for all genes in Motif 3 (n=231)")+
  theme(plot.title = element_text(size = rel(1.5), hjust = 0.5),
        axis.title = element_text(size = 15, colour = "black"),
        strip.background = element_rect(fill = "#CAD899"),
        axis.text.x = element_text(size = 8, colour = "white", angle = 15),
        strip.text.x = element_text(size = 12, colour = "black", face = "bold"))

#plots
filt_toptable_abs_fin
filt_toptable_2_abs_fin
filt_toptable_3_abs_fin



```

###Plot logFC of All Motifs
```{r logFC of Cormotif Motifs}
##motif 1
motif1_genes_fin <- final_genes_1
length(motif1_genes_fin)

##motif 2 
motif2_genes_fin <- final_genes_2
length(motif2_genes_fin)

##motif 3
motif3_genes_fin <- final_genes_3
length(motif3_genes_fin)

#Combine the toptables I have from pairwise analysis into a single dataframe
d24_toptable_dxr <- Toptable_V.D24T %>% 
  rownames_to_column(var = "entrezgene_ID") %>% 
  mutate(Time = "24")

d24r_toptable_dxr <- Toptable_V.D24R %>% 
  rownames_to_column(var = "entrezgene_ID") %>% 
  mutate(Time = "24R")

d144r_toptable_dxr <- Toptable_V.D144R %>% 
  rownames_to_column(var = "entrezgene_ID") %>% 
  mutate(Time = "144R")

combined_toptables_dxr <- bind_rows(
  d24_toptable_dxr,
  d24r_toptable_dxr,
  d144r_toptable_dxr)

#Filter the data based on each motif
filt_toptable_dxr_fin <- combined_toptables_dxr %>% 
  dplyr::filter(entrezgene_ID  %in% final_genes_1) %>% 
  mutate(absFC = abs(logFC)) %>% 
  mutate(time = factor(Time, levels = c("24", "24R", "144R"), labels = c("24hr", "24hr Recovery", "144hr Recovery"))) %>% 
  ggplot(., aes(x = time, y = logFC))+
  geom_boxplot(aes(fill = time))+
  scale_fill_manual(values = time_col)+
  guides(fill = guide_legend(title = "Time"))+
  theme_bw()+
  xlab(" ")+
  ylab("logFC")+
  theme_bw()+
  ggtitle("LogFC for all genes in Motif 1 (n=5638)")+
  theme(plot.title = element_text(size = rel(1.5), hjust = 0.5),
        axis.title = element_text(size = 15, colour = "black"),
        strip.background = element_rect(fill = "#CAD899"),
        axis.text.x = element_text(size = 8, colour = "white", angle = 15),
        strip.text.x = element_text(size = 12, colour = "black", face = "bold"))

#motif 2
filt_toptable_2_dxr_fin <- combined_toptables_dxr %>% 
  dplyr::filter(entrezgene_ID  %in% final_genes_2) %>% 
  mutate(absFC = abs(logFC)) %>% 
  mutate(time = factor(Time, levels = c("24", "24R", "144R"), labels = c("24hr", "24hr Recovery", "144hr Recovery"))) %>% 
  ggplot(., aes(x = time, y = logFC))+
  geom_boxplot(aes(fill = time))+
  scale_fill_manual(values = time_col)+
  guides(fill = guide_legend(title = "Time"))+
  theme_bw()+
  xlab(" ")+
  ylab("logFC")+
  theme_bw()+
  ggtitle("LogFC for all genes in Motif 2 (n=6218)")+
  theme(plot.title = element_text(size = rel(1.5), hjust = 0.5),
        axis.title = element_text(size = 15, colour = "black"),
        strip.background = element_rect(fill = "#CAD899"),
        axis.text.x = element_text(size = 8, colour = "white", angle = 15),
        strip.text.x = element_text(size = 12, colour = "black", face = "bold"))

#motif 3
filt_toptable_3_dxr_fin <- combined_toptables_dxr %>% 
  dplyr::filter(entrezgene_ID  %in% final_genes_3) %>% 
  mutate(absFC = abs(logFC)) %>% 
  mutate(time = factor(Time, levels = c("24", "24R", "144R"), labels = c("24hr", "24hr Recovery", "144hr Recovery"))) %>% 
  ggplot(., aes(x = time, y = logFC))+
  geom_boxplot(aes(fill = time))+
  scale_fill_manual(values = time_col)+
  guides(fill = guide_legend(title = "Time"))+
  theme_bw()+
  xlab(" ")+
  ylab("logFC")+
  theme_bw()+
  ggtitle("LogFC for all genes in Motif 3 (n=231)")+
  theme(plot.title = element_text(size = rel(1.5), hjust = 0.5),
        axis.title = element_text(size = 15, colour = "black"),
        strip.background = element_rect(fill = "#CAD899"),
        axis.text.x = element_text(size = 8, colour = "white", angle = 15),
        strip.text.x = element_text(size = 12, colour = "black", face = "bold"))

#plots
filt_toptable_dxr_fin
filt_toptable_2_dxr_fin 
filt_toptable_3_dxr_fin


#now plot the abs logFC for each of these too
filt_toptable_abs_fin <- combined_toptables_dxr %>% 
  dplyr::filter(entrezgene_ID  %in% final_genes_1) %>% 
  mutate(absFC = abs(logFC)) %>% 
  mutate(time = factor(Time, levels = c("24", "24R", "144R"), labels = c("24hr", "24hr Recovery", "144hr Recovery"))) %>% 
  ggplot(., aes(x = time, y = absFC))+
  geom_boxplot(aes(fill = time))+
  scale_fill_manual(values = time_col)+
  guides(fill = guide_legend(title = "Time"))+
  theme_bw()+
  xlab(" ")+
  ylab("|logFC|")+
  theme_bw()+
  ggtitle("Abs LogFC for all genes in Motif 1 (n=5638)")+
  theme(plot.title = element_text(size = rel(1.5), hjust = 0.5),
        axis.title = element_text(size = 15, colour = "black"),
        strip.background = element_rect(fill = "#CAD899"),
        axis.text.x = element_text(size = 8, colour = "white", angle = 15),
        strip.text.x = element_text(size = 12, colour = "black", face = "bold"))

#motif 2
filt_toptable_2_abs_fin <- combined_toptables_dxr %>% 
  dplyr::filter(entrezgene_ID  %in% final_genes_2) %>% 
  mutate(absFC = abs(logFC)) %>% 
  mutate(time = factor(Time, levels = c("24", "24R", "144R"), labels = c("24hr", "24hr Recovery", "144hr Recovery"))) %>% 
  ggplot(., aes(x = time, y = absFC))+
  geom_boxplot(aes(fill = time))+
  scale_fill_manual(values = time_col)+
  guides(fill = guide_legend(title = "Time"))+
  theme_bw()+
  xlab(" ")+
  ylab("|logFC|")+
  theme_bw()+
  ggtitle("Abs LogFC for all genes in Motif 2 (n=6218)")+
  theme(plot.title = element_text(size = rel(1.5), hjust = 0.5),
        axis.title = element_text(size = 15, colour = "black"),
        strip.background = element_rect(fill = "#CAD899"),
        axis.text.x = element_text(size = 8, colour = "white", angle = 15),
        strip.text.x = element_text(size = 12, colour = "black", face = "bold"))

#motif 2
filt_toptable_3_abs_fin <- combined_toptables_dxr %>% 
  dplyr::filter(entrezgene_ID  %in% final_genes_3) %>% 
  mutate(absFC = abs(logFC)) %>% 
  mutate(time = factor(Time, levels = c("24", "24R", "144R"), labels = c("24hr", "24hr Recovery", "144hr Recovery"))) %>% 
  ggplot(., aes(x = time, y = absFC))+
  geom_boxplot(aes(fill = time))+
  scale_fill_manual(values = time_col)+
  guides(fill = guide_legend(title = "Time"))+
  theme_bw()+
  xlab(" ")+
  ylab("|logFC|")+
  theme_bw()+
  ggtitle("Abs LogFC for all genes in Motif 3 (n=231)")+
  theme(plot.title = element_text(size = rel(1.5), hjust = 0.5),
        axis.title = element_text(size = 15, colour = "black"),
        strip.background = element_rect(fill = "#CAD899"),
        axis.text.x = element_text(size = 8, colour = "white", angle = 15),
        strip.text.x = element_text(size = 12, colour = "black", face = "bold"))

#plots
filt_toptable_abs_fin
filt_toptable_2_abs_fin
filt_toptable_3_abs_fin

```

###Put together log2cpm Genes for Each Motif
```{r log2cpm Cormotif Genes}
#use the final genes from cross-verifying with clustlike + p.post

#Load in my count matrices
# final_genes_1
# final_genes_2
# final_genes_3

#these are all the genes that are present in each category, make them into dataframes by filtering out the rest of the genes in my main boxplot df
boxplots_cormotif <- boxplot1

motif1_genes_fin <- boxplots_cormotif[boxplots_cormotif$Entrez_ID %in% final_genes_1,]
dim(motif1_genes_fin)
#5638 genes in 44 cols
motif2_genes_fin <- boxplots_cormotif[boxplots_cormotif$Entrez_ID %in% final_genes_2,]
dim(motif2_genes_fin)
#6218 genes in 44 cols
motif3_genes_fin <- boxplots_cormotif[boxplots_cormotif$Entrez_ID %in% final_genes_3,]
dim(motif3_genes_fin)
#231 genes in 44 cols

#pull out some random genes for each using sample

m1_genes_fin <- motif1_genes_fin[sample(nrow(motif1_genes_fin), 3), , drop = FALSE]

#Define gene list(s)
#these are the genes pulled out by m1_genes
initial_test_genes1_fin <- c(m1_genes_fin$SYMBOL)  
#Add more gene symbols as needed or add more categories

#Now put in the function I want to use to generate boxplots of genes
process_gene_data_1_fin <- function(gene) {
  gene_data <- motif1_genes_fin %>% filter(SYMBOL == gene)
  long_data <- gene_data %>%
    pivot_longer(cols = -c(Entrez_ID, SYMBOL), names_to = "Sample", values_to = "log2CPM") %>%
    mutate(
      Drug = case_when(
        grepl("DOX", Sample) ~ "DOX",
        grepl("DMSO", Sample) ~ "DMSO",
        TRUE ~ NA_character_
      ),
      Timepoint = case_when(
        grepl("_24T_", Sample) ~ "24T",
        grepl("_24R_", Sample) ~ "24R",
        grepl("_144R_", Sample) ~ "144R",
        TRUE ~ NA_character_
      ),
      Indv = case_when(
        grepl("Ind1$", Sample) ~ "1",
        grepl("Ind2$", Sample) ~ "2",
        grepl("Ind3$", Sample) ~ "3",
        grepl("Ind4$", Sample) ~ "4",
        grepl("Ind5$", Sample) ~ "5",
        grepl("Ind6$", Sample) ~ "6",
        grepl("Ind6REP$", Sample) ~ "6R",
        TRUE ~ NA_character_
      ),
      Condition = paste(Drug, Timepoint, sep = "_")
    )
  long_data$Condition <- factor(
    long_data$Condition,
    levels = c(
      "DOX_24T", 
      "DMSO_24T", 
      "DOX_24R", 
      "DMSO_24R", 
      "DOX_144R", 
      "DMSO_144R"
    )
  )
  return(long_data)
}

#Generate Boxplots from the above function using our gene list above
for (gene in initial_test_genes1_fin) {
  gene_data <- process_gene_data_1_fin(gene)
  p <- ggplot(gene_data, aes(x = Condition, y = log2CPM, fill = Drug)) +
    geom_boxplot(outlier.shape = NA) +
    geom_point(aes(color = Indv), size = 2, alpha = 0.5, position = position_jitter(width = -1, height = 0)) +
    scale_fill_manual(values = c("DOX" = "#499FBD", "DMSO" = "#BBBBBC")) +
    ggtitle(paste("Log2CPM Expression of", gene, "Motif 1")) +
    labs(x = "Treatment", y = "log2CPM") +
    theme_bw() +
    theme(
      plot.title = element_text(size = rel(2), hjust = 0.5),
      axis.title = element_text(size = 15, color = "black"),
      axis.text.x = element_text(size = 10, color = "black", angle = 90, hjust = 1)
    )
  print(p)
}

#####motif 2#####

m2_genes_fin <- motif2_genes_fin[sample(nrow(motif2_genes_fin), 3), , drop = FALSE]

#Define gene list(s)
#these are the genes pulled out by m1_genes
initial_test_genes2_fin <- c(m2_genes_fin$SYMBOL)  
#Add more gene symbols as needed or add more categories

#Now put in the function I want to use to generate boxplots of genes
process_gene_datam2_fin <- function(gene) {
  gene_data <- motif2_genes_fin %>% filter(SYMBOL == gene)
  long_data <- gene_data %>%
    pivot_longer(cols = -c(Entrez_ID, SYMBOL), names_to = "Sample", values_to = "log2CPM") %>%
    mutate(
      Drug = case_when(
        grepl("DOX", Sample) ~ "DOX",
        grepl("DMSO", Sample) ~ "DMSO",
        TRUE ~ NA_character_
      ),
      Timepoint = case_when(
        grepl("_24T_", Sample) ~ "24T",
        grepl("_24R_", Sample) ~ "24R",
        grepl("_144R_", Sample) ~ "144R",
        TRUE ~ NA_character_
      ),
      Indv = case_when(
        grepl("Ind1$", Sample) ~ "1",
        grepl("Ind2$", Sample) ~ "2",
        grepl("Ind3$", Sample) ~ "3",
        grepl("Ind4$", Sample) ~ "4",
        grepl("Ind5$", Sample) ~ "5",
        grepl("Ind6$", Sample) ~ "6",
        grepl("Ind6REP$", Sample) ~ "6R",
        TRUE ~ NA_character_
      ),
      Condition = paste(Drug, Timepoint, sep = "_")
    )
  long_data$Condition <- factor(
    long_data$Condition,
    levels = c(
      "DOX_24T", 
      "DMSO_24T", 
      "DOX_24R", 
      "DMSO_24R", 
      "DOX_144R", 
      "DMSO_144R"
    )
  )
  return(long_data)
}

#this function is saved under process_gene_data so I will save as an R object

#saveRDS(process_gene_data, "data/new/process_gene_data_funct.RDS")

#Generate Boxplots from the above function using our gene list above
for (gene in initial_test_genes2_fin) {
  gene_data <- process_gene_datam2_fin(gene)
  p <- ggplot(gene_data, aes(x = Condition, y = log2CPM, fill = Drug)) +
    geom_boxplot(outlier.shape = NA) +
    geom_point(aes(color = Indv), size = 2, alpha = 0.5, position = position_jitter(width = -1, height = 0)) +
    scale_fill_manual(values = c("DOX" = "#499FBD", "DMSO" = "#BBBBBC")) +
    ggtitle(paste("Log2CPM Expression of", gene, "Motif 2")) +
    labs(x = "Treatment", y = "log2CPM") +
    theme_bw() +
    theme(
      plot.title = element_text(size = rel(2), hjust = 0.5),
      axis.title = element_text(size = 15, color = "black"),
      axis.text.x = element_text(size = 10, color = "black", angle = 90, hjust = 1)
    )
  print(p)
}

#####motif 3#####

m3_genes_fin <- motif3_genes_fin[sample(nrow(motif3_genes_fin), 3), , drop = FALSE]

#Define gene list(s)
#these are the genes pulled out by m3_genes
initial_test_genes3_fin <- c(m3_genes_fin$SYMBOL)  
#Add more gene symbols as needed or add more categories

#Now put in the function I want to use to generate boxplots of genes
process_gene_datam3_fin <- function(gene) {
  gene_data <- motif3_genes_fin %>% filter(SYMBOL == gene)
  long_data <- gene_data %>%
    pivot_longer(cols = -c(Entrez_ID, SYMBOL), names_to = "Sample", values_to = "log2CPM") %>%
    mutate(
      Drug = case_when(
        grepl("DOX", Sample) ~ "DOX",
        grepl("DMSO", Sample) ~ "DMSO",
        TRUE ~ NA_character_
      ),
      Timepoint = case_when(
        grepl("_24T_", Sample) ~ "24T",
        grepl("_24R_", Sample) ~ "24R",
        grepl("_144R_", Sample) ~ "144R",
        TRUE ~ NA_character_
      ),
      Indv = case_when(
        grepl("Ind1$", Sample) ~ "1",
        grepl("Ind2$", Sample) ~ "2",
        grepl("Ind3$", Sample) ~ "3",
        grepl("Ind4$", Sample) ~ "4",
        grepl("Ind5$", Sample) ~ "5",
        grepl("Ind6$", Sample) ~ "6",
        grepl("Ind6REP$", Sample) ~ "6R",
        TRUE ~ NA_character_
      ),
      Condition = paste(Drug, Timepoint, sep = "_")
    )
  long_data$Condition <- factor(
    long_data$Condition,
    levels = c(
      "DOX_24T", 
      "DMSO_24T", 
      "DOX_24R", 
      "DMSO_24R", 
      "DOX_144R", 
      "DMSO_144R"
    )
  )
  return(long_data)
}

#Generate Boxplots from the above function using our gene list above
for (gene in initial_test_genes3_fin) {
  gene_data <- process_gene_datam3_fin(gene)
  p <- ggplot(gene_data, aes(x = Condition, y = log2CPM, fill = Drug)) +
    geom_boxplot(outlier.shape = NA) +
    geom_point(aes(color = Indv), size = 2, alpha = 0.5, position = position_jitter(width = -1, height = 0)) +
    scale_fill_manual(values = c("DOX" = "#499FBD", "DMSO" = "#BBBBBC")) +
    ggtitle(paste("Log2CPM Expression of", gene, "Motif 3")) +
    labs(x = "Treatment", y = "log2CPM") +
    theme_bw() +
    theme(
      plot.title = element_text(size = rel(2), hjust = 0.5),
      axis.title = element_text(size = 15, color = "black"),
      axis.text.x = element_text(size = 10, color = "black", angle = 90, hjust = 1)
    )
  print(p)
}

```

###GO/KEGG Final Genes Cormotif
```{r Cormotif GO KEGG Final Genes}
#now take these final gene sets for each motif - clustlike + p.post consensus genes

#define my background gene set
all_genes

# final_genes_1
# final_genes_2
# final_genes_3

library(gprofiler2)
#####Motif 1 Gene Set#####
# motif1_genes_matrix <- as.matrix(final_genes_1) 
# colnames(motif1_genes_matrix) <- c("entrezgene_ID")

# saveRDS(motif1_genes_matrix, "data/new/motif1_genes_matrix.RDS")

motif1_genes_matrix <- readRDS("data/new/motif1_genes_matrix.RDS")
length(motif1_genes_matrix)
#5638 genes in this set for motif 1

motif1_mat_GOKEGG <- gost(query = motif1_genes_matrix,
                          organism = "hsapiens",
                          ordered_query = FALSE,
                          measure_underrepresentation = FALSE,
                          evcodes = FALSE,
                          user_threshold = 0.05,
                          custom_bg = all_genes,
                          correction_method = c("fdr"),
                          sources = c("GO:BP", "KEGG"))

motif1_GOKEGG_genes <- gostplot(motif1_mat_GOKEGG, capped = FALSE, interactive = TRUE)
motif1_GOKEGG_genes

table_motif1_GOKEGG_genes <- motif1_mat_GOKEGG$result %>% 
  dplyr::select(c(source, term_id, term_name, intersection_size, term_size, p_value))

table_motif1_GOKEGG_genes %>% 
  mutate_at(.vars = 6, .funs = scales::label_scientific(digits=4)) %>% 
  kableExtra::kable(.,) %>% 
  kableExtra::kable_paper("striped", full_width = FALSE) %>% 
  kableExtra::kable_styling(full_width = FALSE, position = "left", bootstrap_options = c("striped", "hover")) %>% 
  kableExtra::scroll_box(width = "100%", height = "400px")

# write.csv(table_motif1_GOKEGG_genes, "data/new/table_motif1_GOKEGG_genes.csv")

#GO:BP
table_motif1_genes_GOBP <- table_motif1_GOKEGG_genes %>% 
  dplyr::filter(source=="GO:BP") %>% 
  dplyr::select(p_value, term_name, intersection_size) %>% 
  dplyr::slice_min(., n=10, order_by=p_value) %>% 
  mutate(log_val = -log10(p_value))

# saveRDS(table_motif1_genes_GOBP, "data/table_motif1_genes_GOBP.RDS")

table_motif1_genes_GOBP %>% ggplot(., aes(x = log_val, y = reorder(term_name, p_value), col= intersection_size)) +
  geom_point(aes(size = intersection_size)) +
  ggtitle("Cormotif Motif 1 Enriched GO:BP Terms")+
  xlab(expression("-log"[10]~"p-value"))+
  guides(col="none", size= guide_legend(title = "# of intersected \n terms"))+
  ylab("GO:BP term")+
  scale_y_discrete(labels = scales::label_wrap(30))+
  theme_bw()+
  theme(plot.title = element_text(size = rel(1.5), hjust = 0.5),
        axis.title = element_text(size = 15, colour = "black"),
        axis.ticks = element_line(linewidth = 1.5),
        axis.line = element_line(linewidth = 1.5),
        axis.text = element_text(size = 10, colour = "black", angle = 0),
        strip.text = element_text(size = 15, colour = "black", face = "bold"))

#KEGG
table_motif1_genes_KEGG <- table_motif1_GOKEGG_genes %>% 
  dplyr::filter(source=="KEGG") %>% 
  dplyr::select(p_value, term_name, intersection_size) %>% 
  dplyr::slice_min(., n=10, order_by=p_value) %>% 
  mutate(log_val = -log10(p_value))

table_motif1_genes_KEGG %>% ggplot(., aes(x = log_val, y = reorder(term_name, p_value), col= intersection_size)) +
  geom_point(aes(size = intersection_size)) +
  ggtitle("Cormotif Motif 1 DEGs Enriched KEGG Terms")+
  xlab(expression("-log"[10]~"p-value"))+
  guides(col="none", size= guide_legend(title = "# of intersected \n terms"))+
  ylab("KEGG term")+
  scale_y_discrete(labels = scales::label_wrap(30))+
  theme_bw()+
  theme(plot.title = element_text(size = rel(1.5), hjust = 0.5),
        axis.title = element_text(size = 15, colour = "black"),
        axis.ticks = element_line(linewidth = 1.5),
        axis.line = element_line(linewidth = 1.5),
        axis.text = element_text(size = 10, colour = "black", angle = 0),
        strip.text = element_text(size = 15, colour = "black", face = "bold"))

#####Motif 2 Genes#####
# motif2_genes_matrix <- as.matrix(final_genes_2) 
# colnames(motif2_genes_matrix) <- c("entrezgene_ID")

# saveRDS(motif2_genes_matrix, "data/new/motif2_genes_matrix.RDS")
motif2_genes_matrix <- readRDS("data/new/motif2_genes_matrix.RDS")
length(motif2_genes_matrix)
#6218 genes in this set for motif 2

motif2_mat_GOKEGG <- gost(query = motif2_genes_matrix,
                          organism = "hsapiens",
                          ordered_query = FALSE,
                          measure_underrepresentation = FALSE,
                          evcodes = FALSE,
                          user_threshold = 0.05,
                          custom_bg = all_genes,
                          correction_method = c("fdr"),
                          sources = c("GO:BP", "KEGG"))

motif2_GOKEGG_genes <- gostplot(motif2_mat_GOKEGG, capped = FALSE, interactive = TRUE)
motif2_GOKEGG_genes

table_motif2_GOKEGG_genes <- motif2_mat_GOKEGG$result %>% 
  dplyr::select(c(source, term_id, term_name, intersection_size, term_size, p_value))

table_motif2_GOKEGG_genes %>% 
  mutate_at(.vars = 6, .funs = scales::label_scientific(digits=4)) %>% 
  kableExtra::kable(.,) %>% 
  kableExtra::kable_paper("striped", full_width = FALSE) %>% 
  kableExtra::kable_styling(full_width = FALSE, position = "left", bootstrap_options = c("striped", "hover")) %>% 
  kableExtra::scroll_box(width = "100%", height = "400px")

# write.csv(table_motif2_GOKEGG_genes, "data/new/table_motif2_GOKEGG_genes.csv")

#GO:BP
table_motif2_genes_GOBP <- table_motif2_GOKEGG_genes %>% 
  dplyr::filter(source=="GO:BP") %>% 
  dplyr::select(p_value, term_name, intersection_size) %>% 
  dplyr::slice_min(., n=10, order_by=p_value) %>% 
  mutate(log_val = -log10(p_value))

# saveRDS(table_motif2_genes_GOBP, "data/table_motif2_genes_GOBP.RDS")

table_motif2_genes_GOBP %>% ggplot(., aes(x = log_val, y = reorder(term_name, p_value), col= intersection_size)) +
  geom_point(aes(size = intersection_size)) +
  ggtitle("Cormotif Motif 2 Enriched GO:BP Terms")+
  xlab(expression("-log"[10]~"p-value"))+
  guides(col="none", size= guide_legend(title = "# of intersected \n terms"))+
  ylab("GO:BP term")+
  scale_y_discrete(labels = scales::label_wrap(30))+
  theme_bw()+
  theme(plot.title = element_text(size = rel(1.5), hjust = 0.5),
        axis.title = element_text(size = 15, colour = "black"),
        axis.ticks = element_line(linewidth = 1.5),
        axis.line = element_line(linewidth = 1.5),
        axis.text = element_text(size = 10, colour = "black", angle = 0),
        strip.text = element_text(size = 15, colour = "black", face = "bold"))

#KEGG
table_motif2_genes_KEGG <- table_motif2_GOKEGG_genes %>% 
  dplyr::filter(source=="KEGG") %>% 
  dplyr::select(p_value, term_name, intersection_size) %>% 
  dplyr::slice_min(., n=10, order_by=p_value) %>% 
  mutate(log_val = -log10(p_value))

table_motif2_genes_KEGG %>% ggplot(., aes(x = log_val, y = reorder(term_name, p_value), col= intersection_size)) +
  geom_point(aes(size = intersection_size)) +
  ggtitle("Cormotif Motif 2 DEGs Enriched KEGG Terms")+
  xlab(expression("-log"[10]~"p-value"))+
  guides(col="none", size= guide_legend(title = "# of intersected \n terms"))+
  ylab("KEGG term")+
  scale_y_discrete(labels = scales::label_wrap(30))+
  theme_bw()+
  theme(plot.title = element_text(size = rel(1.5), hjust = 0.5),
        axis.title = element_text(size = 15, colour = "black"),
        axis.ticks = element_line(linewidth = 1.5),
        axis.line = element_line(linewidth = 1.5),
        axis.text = element_text(size = 10, colour = "black", angle = 0),
        strip.text = element_text(size = 15, colour = "black", face = "bold"))


#####Motif 3 DEGs GO KEGG#####
# motif3_genes_matrix <- as.matrix(final_genes_3) 
# colnames(motif3_genes_matrix) <- c("entrezgene_ID")

# saveRDS(motif3_genes_matrix, "data/new/motif3_genes_matrix.RDS")

motif3_genes_matrix <- readRDS("data/new/motif3_genes_matrix.RDS")
length(motif3_genes_matrix)
#231 genes in this set for motif 3

motif3_mat_GOKEGG <- gost(query = motif3_genes_matrix,
                          organism = "hsapiens",
                          ordered_query = FALSE,
                          measure_underrepresentation = FALSE,
                          evcodes = FALSE,
                          user_threshold = 0.05,
                          custom_bg = all_genes,
                          correction_method = c("fdr"),
                          sources = c("GO:BP", "KEGG"))

motif3_GOKEGG_genes <- gostplot(motif3_mat_GOKEGG, capped = FALSE, interactive = TRUE)
motif3_GOKEGG_genes

table_motif3_GOKEGG_genes <- motif3_mat_GOKEGG$result %>% 
  dplyr::select(c(source, term_id, term_name, intersection_size, term_size, p_value))

table_motif3_GOKEGG_genes %>% 
  mutate_at(.vars = 6, .funs = scales::label_scientific(digits=4)) %>% 
  kableExtra::kable(.,) %>% 
  kableExtra::kable_paper("striped", full_width = FALSE) %>% 
  kableExtra::kable_styling(full_width = FALSE, position = "left", bootstrap_options = c("striped", "hover")) %>% 
  kableExtra::scroll_box(width = "100%", height = "400px")

# write.csv(table_motif3_GOKEGG_genes, "data/new/table_motif3_GOKEGG_genes.csv")

#GO:BP
table_motif3_genes_GOBP <- table_motif3_GOKEGG_genes %>% 
  dplyr::filter(source=="GO:BP") %>% 
  dplyr::select(p_value, term_name, intersection_size) %>% 
  dplyr::slice_min(., n=10, order_by=p_value) %>% 
  mutate(log_val = -log10(p_value))

# saveRDS(table_motif3_genes_GOBP, "data/table_motif3_genes_GOBP.RDS")

table_motif3_genes_GOBP %>% ggplot(., aes(x = log_val, y = reorder(term_name, p_value), col= intersection_size)) +
  geom_point(aes(size = intersection_size)) +
  ggtitle("Cormotif Motif 3 Enriched GO:BP Terms")+
  xlab(expression("-log"[10]~"p-value"))+
  guides(col="none", size= guide_legend(title = "# of intersected \n terms"))+
  ylab("GO:BP term")+
  scale_y_discrete(labels = scales::label_wrap(30))+
  theme_bw()+
  theme(plot.title = element_text(size = rel(1.5), hjust = 0.5),
        axis.title = element_text(size = 15, colour = "black"),
        axis.ticks = element_line(linewidth = 1.5),
        axis.line = element_line(linewidth = 1.5),
        axis.text = element_text(size = 10, colour = "black", angle = 0),
        strip.text = element_text(size = 15, colour = "black", face = "bold"))

#KEGG
table_motif3_genes_KEGG <- table_motif3_GOKEGG_genes %>% 
  dplyr::filter(source=="KEGG") %>% 
  dplyr::select(p_value, term_name, intersection_size) %>% 
  dplyr::slice_min(., n=10, order_by=p_value) %>% 
  mutate(log_val = -log10(p_value))

table_motif3_genes_KEGG %>% ggplot(., aes(x = log_val, y = reorder(term_name, p_value), col= intersection_size)) +
  geom_point(aes(size = intersection_size)) +
  ggtitle("Cormotif Motif 3 DEGs Enriched KEGG Terms")+
  xlab(expression("-log"[10]~"p-value"))+
  guides(col="none", size= guide_legend(title = "# of intersected \n terms"))+
  ylab("KEGG term")+
  scale_y_discrete(labels = scales::label_wrap(30))+
  theme_bw()+
  theme(plot.title = element_text(size = rel(1.5), hjust = 0.5),
        axis.title = element_text(size = 15, colour = "black"),
        axis.ticks = element_line(linewidth = 1.5),
        axis.line = element_line(linewidth = 1.5),
        axis.text = element_text(size = 10, colour = "black", angle = 0),
        strip.text = element_text(size = 15, colour = "black", face = "bold"))

```
###Look at Unassigned Gene Set Cormotif
```{r Cormotif Unassigned Gene Set}
#now let's pull out the genes that were not assigned to a motif from above

#this one is giving me an issue with wflow_build so I'll fix it later

unassigned_genes_list <- readRDS("data/new/Cormotif/unassigned_genes_Cormotif.RDS")

#with these unassigned genes, I want to plot logFC and GO/KEGG of unassigned genes
#####logFC#####

##no motif genes
unassign_genes_fin <- unassigned_genes_list
length(unassign_genes_fin)
#2232 genes 

#Combine the toptables I have from pairwise analysis into a single dataframe
combined_toptables_dxr <- bind_rows(
  d24_toptable_dxr,
  d24r_toptable_dxr,
  d144r_toptable_dxr)

#Filter the data based on each motif
# filt_toptable_dxr_fin_unassign <- as.data.frame(combined_toptables_dxr) %>% 
#   dplyr::filter(Entrez_ID  %in% unassign_genes_fin) %>% 
#   mutate(absFC = abs(logFC)) %>% 
#   mutate(time = factor(Time, levels = c("24", "24R", "144R"), labels = c("24hr", "24hr Recovery", "144hr Recovery"))) %>% 
#   ggplot(., aes(x = time, y = logFC))+
#   geom_boxplot(aes(fill = time))+
#   scale_fill_manual(values = time_col)+
#   guides(fill = guide_legend(title = "Time"))+
#   theme_bw()+
#   xlab(" ")+
#   ylab("logFC")+
#   theme_bw()+
#   ggtitle("LogFC of Unassigned Genes (n=2232)")+
#   theme(plot.title = element_text(size = rel(1.5), hjust = 0.5),
#         axis.title = element_text(size = 15, colour = "black"),
#         strip.background = element_rect(fill = "#CAD899"),
#         axis.text.x = element_text(size = 8, colour = "white", angle = 15),
#         strip.text.x = element_text(size = 12, colour = "black", face = "bold"))
# 
# filt_toptable_dxr_fin_unassign


# filt_toptable_abs_fin_unassign <- as.data.frame(combined_toptables_dxr) %>% 
#   dplyr::filter(Entrez_ID  %in% unassign_genes_fin) %>% 
#   mutate(absFC = abs(logFC)) %>% 
#   mutate(time = factor(Time, levels = c("24", "24R", "144R"), labels = c("24hr", "24hr Recovery", "144hr Recovery"))) %>% 
#   ggplot(., aes(x = time, y = absFC))+
#   geom_boxplot(aes(fill = time))+
#   scale_fill_manual(values = time_col)+
#   guides(fill = guide_legend(title = "Time"))+
#   theme_bw()+
#   xlab(" ")+
#   ylab("|logFC|")+
#   theme_bw()+
#   ggtitle("Abs LogFC of Unassigned Genes (n=2232)")+
#   theme(plot.title = element_text(size = rel(1.5), hjust = 0.5),
#         axis.title = element_text(size = 15, colour = "black"),
#         strip.background = element_rect(fill = "#CAD899"),
#         axis.text.x = element_text(size = 8, colour = "white", angle = 15),
#         strip.text.x = element_text(size = 12, colour = "black", face = "bold"))
# 
# filt_toptable_abs_fin_unassign

####GO KEGG####
unassigned_genes_matrix <- as.matrix(unassigned_genes_list)
length(unassigned_genes_matrix)
#2232 genes in this set

unassign_mat_GOKEGG <- gost(query = unassigned_genes_matrix,
                          organism = "hsapiens",
                          ordered_query = FALSE,
                          measure_underrepresentation = FALSE,
                          evcodes = FALSE,
                          user_threshold = 0.05,
                          custom_bg = all_genes,
                          correction_method = c("fdr"),
                          sources = c("GO:BP", "KEGG"))

unassign_GOKEGG_genes <- gostplot(unassign_mat_GOKEGG, capped = FALSE, interactive = TRUE)
unassign_GOKEGG_genes

table_unassign_GOKEGG_genes <- unassign_mat_GOKEGG$result %>% 
  dplyr::select(c(source, term_id, term_name, intersection_size, term_size, p_value))

table_unassign_GOKEGG_genes %>% 
  mutate_at(.vars = 6, .funs = scales::label_scientific(digits=4)) %>% 
  kableExtra::kable(.,) %>% 
  kableExtra::kable_paper("striped", full_width = FALSE) %>% 
  kableExtra::kable_styling(full_width = FALSE, position = "left", bootstrap_options = c("striped", "hover")) %>% 
  kableExtra::scroll_box(width = "100%", height = "400px")

#GO:BP
table_unassign_genes_GOBP <- table_unassign_GOKEGG_genes %>% 
  dplyr::filter(source=="GO:BP") %>% 
  dplyr::select(p_value, term_name, intersection_size) %>% 
  dplyr::slice_min(., n=10, order_by=p_value) %>% 
  mutate(log_val = -log10(p_value))

table_unassign_genes_GOBP %>% ggplot(., aes(x = log_val, y = reorder(term_name, p_value), col= intersection_size)) +
  geom_point(aes(size = intersection_size)) +
  ggtitle("Cormotif Unassigned Enriched GO:BP Terms")+
  xlab(expression("-log"[10]~"p-value"))+
  guides(col="none", size= guide_legend(title = "# of intersected \n terms"))+
  ylab("GO:BP term")+
  scale_y_discrete(labels = scales::label_wrap(30))+
  theme_bw()+
  theme(plot.title = element_text(size = rel(1.5), hjust = 0.5),
        axis.title = element_text(size = 15, colour = "black"),
        axis.ticks = element_line(linewidth = 1.5),
        axis.line = element_line(linewidth = 1.5),
        axis.text = element_text(size = 10, colour = "black", angle = 0),
        strip.text = element_text(size = 15, colour = "black", face = "bold"))

#KEGG
table_unassign_genes_KEGG <- table_unassign_GOKEGG_genes %>% 
  dplyr::filter(source=="KEGG") %>% 
  dplyr::select(p_value, term_name, intersection_size) %>% 
  dplyr::slice_min(., n=10, order_by=p_value) %>% 
  mutate(log_val = -log10(p_value))

table_unassign_genes_KEGG %>% ggplot(., aes(x = log_val, y = reorder(term_name, p_value), col= intersection_size)) +
  geom_point(aes(size = intersection_size)) +
  ggtitle("Cormotif Unassigned DEGs Enriched KEGG Terms")+
  xlab(expression("-log"[10]~"p-value"))+
  guides(col="none", size= guide_legend(title = "# of intersected \n terms"))+
  ylab("KEGG term")+
  scale_y_discrete(labels = scales::label_wrap(30))+
  theme_bw()+
  theme(plot.title = element_text(size = rel(1.5), hjust = 0.5),
        axis.title = element_text(size = 15, colour = "black"),
        axis.ticks = element_line(linewidth = 1.5),
        axis.line = element_line(linewidth = 1.5),
        axis.text = element_text(size = 10, colour = "black", angle = 0),
        strip.text = element_text(size = 15, colour = "black", face = "bold"))



```
##Cormotif RUVs Corrected Norm Counts TMM and log2cpm
```{r  RUVs Cormotif with Norm Counts}
# #read in the norm counts df (normalized counts from RUV)
set1 <- readRDS("data/new/RUV/set1_RUVsk1_normcounts.RDS")
NormCounts_RUV_rep <- as.data.frame(set1$normalizedCounts)
# 
# #read in my metadata sheet that I'll use as the standard for labelling
# #this one already has the replicate individual removed
Metadata_2 <- readRDS("data/new/Metadata_2_norep.RDS")
# 
# #I'll have to remove the replicate at this stage so I can properly run Cormotif
NormCounts_RUV <- NormCounts_RUV_rep %>%
  dplyr::select(-(contains("6R")))
# 
# #now ensure the column names match the original dge$counts with Sample_name
colnames(NormCounts_RUV) <- Metadata_2$Sample_name
# 
# #now, make this into a dge object as I did for DE + Cormotif
dge_RUV <- DGEList(counts = NormCounts_RUV)
# 
# #put the Condition names as a factor onto the dge object for further sorting
dge_RUV$samples$group <- factor(Metadata_2[colnames(NormCounts_RUV), "Condition"])
# 
# #TMM normalize the normalized counts input with the dge object
dge_RUV_calc <- calcNormFactors(dge_RUV, method = "TMM")
# #this is producing a lot of NaNs warnings, perhaps because TMM should occur before norm counts?
# 
# #try by performing TMM normalization before norm counts in set1
# 
counts <- readRDS("data/new/RUV/filt_counts_matrix.RDS")
# #use this counts file to feed into set1 - but instead TMM normalize it first
# 
counts_tmm <- calcNormFactors(counts, method = "TMM")
# 
# set1_tmm <- RUVSeq::RUVs(x = counts_tmm, k =1, scIdx = scIdx, isLog = FALSE)
# error with tmm normalized counts going into RUVseq
# 
# summary(colSums(NormCounts_RUV))
# dge_RUV$samples
# # 
ncol(NormCounts_RUV) == nrow(Metadata_2)           # Should be TRUE
all(colnames(NormCounts_RUV) == rownames(Metadata_2))
# 
# 
# #save this file so I can read it in later!
# #saveRDS(dge_RUV_calc, "data/new/Cormotif/dge_matrix_forCormotif.RDS")
# 
# #check normalization factors from TMM normalization of LIBRARIES
# dge_RUV_calc$samples
# #it was normalized properly but generated NaNs warnings?
# #still has the same number of columns, properly labelled and in order according to metadata
#  #should be okay - let's try running it and see if it works properly
# 
# Metadata_2_ordered <- Metadata_2[match(colnames(NormCounts_RUV), Metadata_2$Sample_name), ]
# 
# #now cpm these TMM normalized norm counts
# cmf_RUV_cpm <- cpm(dge_RUV_calc, log = TRUE)
# 
# #change the column names to match the Metadata sheet I have
# colnames(cmf_RUV_cpm) <- (Metadata_2$Final_sample_name)
# 
# cmf_RUV_counts <- dge_RUV_calc
# 
# #now make your TMM normalized cpm of norm counts into a dataframe + add Entrez_ID as a col
# cmf_RUV_df <- cmf_RUV_cpm %>%
  # as.data.frame() %>%
  # rownames_to_column(., var = "Entrez_ID")
# 
# #save this to a csv file so I can reorder this matrix easily
# #write.csv(cmf_RUV_cpm, "data/new/Cormotif/RUV/Cormotif_RUVk1_cpm_matrix.csv")
# 
# #reorder my test matrix to match the new groupid I've made
# #I want my columns to be in this order:
# #DOX24T 1-6, DOX24R 1-6, DOX144R 1-6, DMSO24T 1-6, DMSO24R 1-6, DMSO144R 1-6
# Cormotif_RUV <- read.csv("data/new/cmf_RUV_final.csv")
# dim(Cormotif_RUV)
# # #14319 genes across 37 cols (1 is Entrez_ID)
# Cormotif_RUV_df <- data.frame(Cormotif_RUV)
# # 
# rownames(Cormotif_RUV_df) <- Cormotif_RUV_df$Entrez_ID
# exprs.cmf_RUV <- as.matrix(Cormotif_RUV_df[,2:37])
# dim(exprs.cmf_RUV)
# # 
# 
# #put together my group id and comparison id to make the correct comparisons between experimental conditions
# 
# #groupid tells which experimental conditions are grouped together
# #compid tells which experimental conditions should be compared against one another
# ##ie DOX24T vs DMSO24T matched control
# 
# groupid <- c(
#   DOX_24T_1 = 1,
#   DOX_24T_2 = 1,
#   DOX_24T_3 = 1,
#   DOX_24T_4 = 1,
#   DOX_24T_5 = 1,
#   DOX_24T_6 = 1,
#   DOX_24R_1 = 2,
#   DOX_24R_2 = 2,
#   DOX_24R_3 = 2,
#   DOX_24R_4 = 2,
#   DOX_24R_5 = 2,
#   DOX_24R_6 = 2,
#   DOX_144R_1 = 3,
#   DOX_144R_2 = 3,
#   DOX_144R_3 = 3,
#   DOX_144R_4 = 3,
#   DOX_144R_5 = 3,
#   DOX_144R_6 = 3,
#   DMSO_24T_1 = 4,
#   DMSO_24T_2 = 4,
#   DMSO_24T_3 = 4,
#   DMSO_24T_4 = 4,
#   DMSO_24T_5 = 4,
#   DMSO_24T_6 = 4,
#   DMSO_24R_1 = 5,
#   DMSO_24R_2 = 5,
#   DMSO_24R_3 = 5,
#   DMSO_24R_4 = 5,
#   DMSO_24R_5 = 5,
#   DMSO_24R_6 = 5,
#   DMSO_144R_1 = 6,
#   DMSO_144R_2 = 6,
#   DMSO_144R_3 = 6,
#   DMSO_144R_4 = 6,
#   DMSO_144R_5 = 6,
#   DMSO_144R_6 = 6
# )
# #saveRDS(groupid, "data/new/groupidCormotif.RDS")
# 
# compid <- data.frame(Cond1 = c(1, 2, 3), Cond2 = c(4, 5, 6))
# #saveRDS(compid, "data/new/compidCormotif.RDS")
```
##RUVs Cormotif TMM norm counts 
```{r RUVs Cormotif Test}

#raw counts file
counts <- readRDS("data/new/RUV/filt_counts_matrix.RDS")

#create a dgelist object from these counts
dge_test <- DGEList(counts = counts)
dim(dge_test$counts)
#14319 genes as normal, still contains replicate needed for RUVs

#apply TMM normalization to this DGElist object
dge_test_tmm <- calcNormFactors(object = dge_test, method = "TMM")
#this ran through just fine, must be something to do with applying TMM to normalized counts
dim(dge_test_tmm$counts)
#14319 genes as normal, still have the replicate so 42 cols
#this still has the entrez_id so I should probably make sure that this is carried down

#pass this TMM normalized DGElist into RUVs correction
colnames(dge_test_tmm) <- Metadata$Final_sample_name
dim(dge_test_tmm)
#14319 genes as normal


RUV_filt_counts_tmm <- dge_test_tmm$counts %>% 
  as.data.frame() 

Entrez_ID_tmm_RUV <- RUV_filt_counts_tmm$Entrez_ID
# saveRDS(Entrez_ID_tmm_RUV, "data/new/RUV/entrezID_tmm_RUV_list.RDS")

dim(RUV_filt_counts_tmm)
#14319 genes as normal, no need to add the filtering step as the counts are already filtered

#add in the annotation files
ind_num <- readRDS("data/new/ind_num.RDS")
annot <- read.csv("data/new/Metadata.csv")

#counts need to be integer values and in a numeric matrix
#note: the log transformation needs to be accounted for in the isLog argument in RUVs function.
counts_test_tmm <- as.matrix(RUV_filt_counts_tmm)
#saveRDS(counts_test_tmm, "data/new/RUV/counts_tmm_filtered.RDS")

# Create a DataFrame for the phenoData
phenoData <- DataFrame(annot)

# Now create the RangedSummarizedExperiment necessary for RUVs input
# looks like it did need both the phenodata and the counts.
set_tmm <- SummarizedExperiment(assays = counts_test_tmm, metadata = phenoData)
dim(set_tmm)
#14319 genes as before

# Generate a background matrix
# The column "Cond" holds the comparisons that you actually want to make. DOX_24, DMSO_24,5FU_24, DOX_3,etc.
scIdx <-RUVSeq::makeGroups(phenoData$Condition)
scIdx

#now run through RUV correction with my tmm normalized data to generate normalized counts
set1_tmm <- RUVSeq::RUVs(x = counts_test_tmm, k =1, scIdx = scIdx, isLog = FALSE)
dim(set1_tmm$normalizedCounts)
#14319 genes as before, still containing the replicate individual

#saveRDS(set1_tmm, "data/new/RUV/set1_TMMnorm_RUVsk1_normcounts.RDS")

#make a df of the data for Cormotif?
RUV_df1_tmm <- set1_tmm$W %>% as.data.frame()
RUV_df1_tmm$Names <- rownames(RUV_df1_tmm)

#ensure that the names match across samples
RUV_df_rm1_tmm <- RUV_df1_tmm[RUV_df1_tmm$Names %in% annot$Final_sample_name, ] 
RUV_1_tmm <-  RUV_df_rm1_tmm$W_1

#now that I've passed my TMM normalized counts into the set_tmm, proceed to Cormotif

#####Cormotif Data Setup#####
set1_tmm <- readRDS("data/new/RUV/set1_TMMnorm_RUVsk1_normcounts.RDS")
NormCounts_RUV_rep <- as.data.frame(set1_tmm$normalizedCounts)

#read in my metadata sheet that I'll use as the standard for labelling
#this one already has the replicate individual removed
Metadata_2 <- readRDS("data/new/Metadata_2_norep.RDS")

#I'll have to remove the replicate at this stage so I can properly run Cormotif
NormCounts_RUV <- NormCounts_RUV_rep %>% 
  dplyr::select(-(contains("6R")))
#14319 genes and 36 columns, the right size matrix for Cormotif

#now ensure the column names match the original dge$counts with Sample_name
colnames(NormCounts_RUV) <- Metadata_2$Sample_name
rownames(NormCounts_RUV) <- Entrez_ID_tmm_RUV

#now cpm the cormotif matrix you're going to use
##this should be tmm normalized log2cpm at the end for going into Cormotif
cmf_test <- cpm(NormCounts_RUV, log = TRUE)
colnames(cmf_test) <- (Metadata_2$Final_sample_name)

cmf_counts <- dge_test_tmm$counts %>% 
  as.data.frame() %>% 
  dplyr::select(-(contains("6R")))

cmf_test_df <- cmf_test %>% 
  as.data.frame() %>% 
  rownames_to_column(., var = "Entrez_ID")

#write.csv(x = cmf_test, file = "data/new/RUV/cormotif_test_matrix_TMMnorm.csv")

#reorder my test matrix to match the new groupid I've made
#I want my columns to be in this order:
#DOX24T 1-6, DOX24R 1-6, DOX144R 1-6, DMSO24T 1-6, DMSO24R 1-6, DMSO144R 1-6
Cormotif_ruv <- read.csv("data/new/RUV/Cormotif_RUV_final.csv")
dim(Cormotif_ruv)
#14319 genes across 37 cols (1 is Entrez_ID)
Cormotif_ruv_df <- data.frame(Cormotif_ruv)

rownames(Cormotif_ruv_df) <- Cormotif_ruv_df$Entrez_ID
exprs.cmf_ruv <- as.matrix(Cormotif_ruv_df[,2:37])
dim(exprs.cormotif)
#14319 genes in 36 columns, set up for plugging into Cormotif

#now I need to set up my groupid and compid accordingly

#put together my group id and comparison id to make the correct comparisons between experimental conditions

#groupid tells which experimental conditions are grouped together
#compid tells which experimental conditions should be compared against one another
##ie DOX24T vs DMSO24T matched control

groupid_csv <- read.csv("data/new/GroupID.csv")
#now I have to make this into a vector (named vector)?
groupid <- c(
  DOX_24T_1 = 1, 
  DOX_24T_2 = 1, 
  DOX_24T_3 = 1, 
  DOX_24T_4 = 1, 
  DOX_24T_5 = 1, 
  DOX_24T_6 = 1,
  DOX_24R_1 = 2, 
  DOX_24R_2 = 2, 
  DOX_24R_3 = 2, 
  DOX_24R_4 = 2, 
  DOX_24R_5 = 2, 
  DOX_24R_6 = 2,
  DOX_144R_1 = 3, 
  DOX_144R_2 = 3, 
  DOX_144R_3 = 3, 
  DOX_144R_4 = 3, 
  DOX_144R_5 = 3, 
  DOX_144R_6 = 3,
  DMSO_24T_1 = 4, 
  DMSO_24T_2 = 4, 
  DMSO_24T_3 = 4, 
  DMSO_24T_4 = 4, 
  DMSO_24T_5 = 4, 
  DMSO_24T_6 = 4,
  DMSO_24R_1 = 5, 
  DMSO_24R_2 = 5, 
  DMSO_24R_3 = 5, 
  DMSO_24R_4 = 5, 
  DMSO_24R_5 = 5, 
  DMSO_24R_6 = 5,
  DMSO_144R_1 = 6, 
  DMSO_144R_2 = 6, 
  DMSO_144R_3 = 6, 
  DMSO_144R_4 = 6, 
  DMSO_144R_5 = 6, 
  DMSO_144R_6 = 6
)
#saveRDS(groupid, "data/new/groupidCormotif.RDS")

compid <- data.frame(Cond1 = c(1, 2, 3), Cond2 = c(4, 5, 6))
#saveRDS(compid, "data/new/compidCormotif.RDS")
compid_cmf <- readRDS("data/new/compidCormotif.RDS")
```
###Run Cormotif RUVs TMM Norm Counts
```{r RUVs Cormotif Run}
#set the seed the same as the previous one to ensure consistency

#fit Cormotif model
# set.seed(19191)
#only set the seed ONCE
# 
# motif.fitted_ruv <- cormotiffit(
#   exprs = exprs.cmf_ruv,
#   groupid = groupid_csv,
#   compid = compid_cmf,
#   K = 1:10,
#   max.iter = 1000,
#   BIC = TRUE,
#   runtype = "logCPM"
# )

# saveRDS(motif.fitted_RUV, "data/new/RUV/motif.fitted_ruv_250624.RDS")
motif.fitted_RUV <- readRDS("data/new/RUV/motif.fitted_ruv_250624.RDS")

```
###Plot TMM Norm Counts RUVs Cormotif
```{r RUVs Cormotif Plots}

#plot BIC and AIC to see which number of motifs was best for both models
plotIC(motif.fitted_RUV)

motif.fitted_RUV$bic

#now plot the motifs themselves
plotMotif(motif.fitted_RUV, title = "Fitted Motifs for DXR RUVs")

#plot the probability legend
myColors <-  rev(c("#FFFFFF", "#E6E6E6" ,"#CCCCCC", "#B3B3B3", "#999999", "#808080", "#666666","#4C4C4C", "#333333", "#191919","#000000"))

plot.new()
legend('bottomleft',fill=myColors, legend =rev(c("0", "0.1", "0.2", "0.3", "0.4",  "0.5", "0.6", "0.7", "0.8","0.9", "1")), box.col="white",title = "Probability\nlegend", horiz=FALSE,title.cex=.8)

```

##Cormotif RUVs no TMM
```{r RUVs Plot Cormotif no TMM}
#plot the AIC and BIC (we're interested in the Bayesian most of all)
# plotIC(motif.fit_RUV)
# 
# #visual check of the lowest BIC
# motif.fit_RUV$bic
# 
# #plot the motifs
# plotMotif(motif.fit_RUV)
# 
# #plot the probability legend
# myColors <-  rev(c("#FFFFFF", "#E6E6E6" ,"#CCCCCC", "#B3B3B3", "#999999", "#808080", "#666666","#4C4C4C", "#333333", "#191919","#000000"))
# 
# plot.new()
# legend('bottomleft',fill=myColors, legend =rev(c("0", "0.1", "0.2", "0.3", "0.4",  "0.5", "0.6", "0.7", "0.8","0.9", "1")), box.col="white",title = "Probability\nlegend", horiz=FALSE,title.cex=.8)

```

##RUVs Cormotif log2 of Norm Counts
```{r RUVs Cormotif log2 Norm Counts}

# lognormcounts_CMF_rep <- as.matrix(set1$normalizedCounts)
# lognormcounts_CMF <- log2(lognormcounts_CMF_rep + 1)
# #add a pseudocount to ensure any values are not negative or zero
# 
# #first want to cut out the replicate samples as not needed for Cormotif
# lognormcounts_CMF <- as.data.frame(lognormcounts_CMF) %>% 
#   dplyr::select(-(contains("6R"))) %>% 
#   as.matrix()
# 
# #14319 genes in 36 columns, set up for plugging into Cormotif
# 
# #now I need to set up my groupid and compid accordingly
# 
# #put together my group id and comparison id to make the correct comparisons between experimental conditions
# 
# #groupid tells which experimental conditions are grouped together
# #compid tells which experimental conditions should be compared against one another
# ##ie DOX24T vs DMSO24T matched control
# 
# groupid_other <- readRDS("data/new/RUV/groupid_other_unrearranged.RDS")
# 
# #now put together your compid
# compid1 <- data.frame(Cond1 = c(1, 2, 3), Cond2 = c(4, 5, 6))

```

###Run Cormotif log2 normalized counts RUVs
```{r RUVs Cormotif log2 normalized counts Run}
#set the seed the same as the previous one to ensure consistency

#fit Cormotif model
# set.seed(19191)
#only set the seed ONCE

# motif.fit_RUV_log2 <- cormotiffit(
#   exprs = lognormcounts_CMF,
#   groupid = groupid_other,
#   compid = compid1,
#   K = 1:8,
#   max.iter = 500,
#   BIC = TRUE,
#   runtype = "logCPM"
# )

#Warning: Zero sample variances detected, have been offset away from zero#

# saveRDS(motif.fit_RUV_log2, "data/new/RUV/motif.fit_RUVnormcounts_log2NC_250629.RDS")
# motif.fit_RUV_log2 <- readRDS("data/new/RUV/motif.fit_RUVnormcounts_log2NC_250629.RDS")

```

###Plot RUVs Cormotif log2norm counts
```{r RUVs Plot Cormotif log2 of normcounts}
# #plot the AIC and BIC (we're interested in the Bayesian most of all)
# plotIC(motif.fit_RUV_log2)
# 
# #visual check of the lowest BIC
# motif.fit_RUV_log2$bic
# 
# #plot the motifs
# plotMotif(motif.fit_RUV_log2, title = "Log2 RUVs Norm Counts")
# 
#plot the probability legend
myColors <-  rev(c("#FFFFFF", "#E6E6E6" ,"#CCCCCC", "#B3B3B3", "#999999", "#808080", "#666666","#4C4C4C", "#333333", "#191919","#000000"))

plot.new()
legend('bottomleft',fill=myColors, legend =rev(c("0", "0.1", "0.2", "0.3", "0.4",  "0.5", "0.6", "0.7", "0.8","0.9", "1")), box.col="white",title = "Probability\nlegend", horiz=FALSE,title.cex=.8)

```
##Cormotif Log2cpm of Normalized Counts RUVs
```{r RUVs Cormotif log2cpm norm counts}
#since both the TMM normalized norm counts and the cpm norm counts are giving me issues:
#I am going to try this with just the log2 of the normalized counts from RUVs

lognormcounts_CMF_rep <- as.matrix(set1$normalizedCounts)
lognormcounts_CMF_cpm <- cpm(lognormcounts_CMF_rep + 1, log = TRUE)
#add a pseudocount to ensure any values are not negative or zero

#first want to cut out the replicate samples as not needed for Cormotif
lognormcounts_CMF_cpm <- as.data.frame(lognormcounts_CMF_cpm) %>% 
  dplyr::select(-(contains("6R"))) %>% 
  as.matrix()
#14319 genes in 36 cols

#write.csv(x = logNC_CMF_RUV, file = "data/new/RUV/Cormotif_log2normcounts_RUV_matrix.csv")

#14319 genes in 36 columns, set up for plugging into Cormotif

#now I need to set up my groupid and compid accordingly

#put together my group id and comparison id to make the correct comparisons between experimental conditions

#groupid tells which experimental conditions are grouped together
#compid tells which experimental conditions should be compared against one another
##ie DOX24T vs DMSO24T matched control

groupid_other <- readRDS("data/new/RUV/groupid_other_unrearranged.RDS")

#now I have to make this into a vector (named vector)?

compid <- data.frame(Cond1 = c(1, 3, 5), Cond2 = c(2, 4, 6))
compid1 <- data.frame(Cond1 = c(1, 2, 3), Cond2 = c(4, 5, 6))


```


###Run Cormotif log2cpm Norm Counts RUVs
```{r RUVs Run Cormotif log2cpm normcounts}

#set the seed the same as the previous one to ensure consistency

#fit Cormotif model
# set.seed(19191)
#only set the seed ONCE

# motif.fit_RUV_logNC <- cormotiffit(
#   exprs = lognormcounts_CMF_cpm,
#   groupid = groupid_other,
#   compid = compid1,
#   K = 1:8,
#   max.iter = 500,
#   BIC = TRUE,
#   runtype = "logCPM"
# )

# saveRDS(motif.fit_RUV_logNC, "data/new/RUV/motif.fit_RUVnormcounts_log2cpm_250630.RDS")
motif.fit_RUV_logNC_cpm <- readRDS("data/new/RUV/motif.fit_RUVnormcounts_log2cpm_250630.RDS")

```

###Plot Cormotif log2cpm Norm Counts RUVs
```{r RUVs Plot Cormotif log2cpm normcounts}
#plot the AIC and BIC (we're interested in the Bayesian most of all)
plotIC(motif.fit_RUV_logNC_cpm)

#visual check of the lowest BIC
motif.fit_RUV_logNC_cpm$bic

#plot the motifs
plotMotif(motif.fit_RUV_logNC_cpm)

#plot the probability legend
myColors <-  rev(c("#FFFFFF", "#E6E6E6" ,"#CCCCCC", "#B3B3B3", "#999999", "#808080", "#666666","#4C4C4C", "#333333", "#191919","#000000"))

plot.new()
legend('bottomleft',fill=myColors, legend =rev(c("0", "0.1", "0.2", "0.3", "0.4",  "0.5", "0.6", "0.7", "0.8","0.9", "1")), box.col="white",title = "Probability\nlegend", horiz=FALSE,title.cex=.8)

```

#Log2cpm Norm Counts Cormotif Downstream Analysis
```{r Cormotif log2cpm Norm Counts clustlike + p.post}

#extract the posterior probability that these DEGs belong to motifs
gene_prob_all_RUV <- motif.fit_RUV_logNC_cpm$bestmotif$p.post
rownames(gene_prob_all_RUV) <- rownames(lognormcounts_CMF_cpm)

#assign each gene to a motif with max post prob
assigned_motifs_RUV <- apply(gene_prob_all_RUV, 1, which.max)
max_probs_RUV <- apply(gene_prob_all_RUV, 1, max)

#combine these into a dataframe - motif assigned genes (p.post)
motif_assignment_df_RUV <- gene_prob_all_RUV %>%
  as.data.frame() %>%
  rownames_to_column("Gene") %>%
  mutate(
    Assigned_Motif = assigned_motifs_RUV[Gene],
    Max_Probability = max_probs_RUV[Gene]
  )

#make some histograms of the unfiltered data from Cormotif p.post

gene_prob_all_RUV %>% 
  as.data.frame() %>% 
  ggplot(., aes(x = V1))+
  geom_histogram(bins = 50)+
  xlim(0,1)+
  ggtitle("Cormotif Genes p.post RUV M1")

gene_prob_all_RUV %>% 
  as.data.frame() %>% 
  ggplot(., aes(x = V2))+
  geom_histogram(bins = 50)+
  xlim(0,1)+
  ggtitle("Cormotif Genes p.post RUV M2")


#extract the cluster likelihood - which DEGs are most likely to be in this cluster
motif_prob_RUV <- motif.fit_RUV_logNC_cpm$bestmotif$clustlike
rownames(motif_prob_RUV) <- rownames(gene_prob_all_RUV)
# write.csv(motif_prob_RUV,"data/new/cormotif_probability_genelist_all_RUV_log2cpm_NormCounts.csv")

#make some histograms to look at the distribution of clustlike genes without filtering
motif_prob_RUV %>% 
  as.data.frame() %>% 
  ggplot(., aes(x = V1))+
  geom_histogram(bins = 50)+
  xlim(0,1)+
  ggtitle("Cormotif Genes clustlike Distribution M1")

motif_prob_RUV %>% 
  as.data.frame() %>% 
  ggplot(., aes(x = V2))+
  geom_histogram(bins = 50)+
  xlim(0,1)+
  ggtitle("Cormotif Genes clustlike Distribution M2")


```

##P.post and Clustlike Together log2cpm norm counts Cormotif RUV
```{r Use p.post and clustlike together}
#begin with the clustlike cutoffs and then overlay the p.post to check if the genes are present in both

#these filters are the combination of the above analysis to get a gene set that fits in both p.post and clustlike

####motif 1####
#filter 1: clustlike
clust1_genes_RUV <- 
  motif_prob_RUV %>%
  as.data.frame() %>%
  filter(V1>0.8 & V2<0.5) %>% 
  rownames
length(clust1_genes_RUV)
#13600 genes

### Filter 2: Gene-level posterior pattern
prob_filtered_genes_1_RUV <- rownames(gene_prob_all_RUV[(gene_prob_all_RUV[,1] >0.05 & gene_prob_all_RUV[,1] <0.5 & gene_prob_all_RUV[,2] <0.5 & gene_prob_all_RUV[,3] <0.5),])
### Final intersection of both filters
final_genes_1_RUV <- intersect(clust1_genes_RUV, prob_filtered_genes_1_RUV)
cat("Number of genes passing both filters:", length(final_genes_1_RUV), "\n")
#7602 genes pass both filters here

####motif 2####
#filter 1: clustlike
clust2_genes_RUV <- motif_prob_RUV %>%
  as.data.frame() %>%
  filter(V2>0.5 & V1<0.5) %>% 
  rownames

length(clust2_genes_RUV)
#517 genes

### Filter 2: Gene-level posterior pattern
prob_filtered_genes_2_RUV <- rownames(gene_prob_all_RUV[(gene_prob_all_RUV[,1] >0.3 & gene_prob_all_RUV[,2] >0.5 & gene_prob_all_RUV[,3] >0.5),])
### Final intersection of both filters
final_genes_2_RUV <- intersect(clust2_genes_RUV, prob_filtered_genes_2_RUV)
cat("Number of genes passing both filters:", length(final_genes_2_RUV), "\n")

#501 genes pass both filters here

#what is the proportion of my genes that are included?
#p.post and clustlike together
7673+501
#8174
(8174/14319)*100
#57.08% of my genes are represented here out of the 14319 original

#what is the proportion of my genes that are included?
#clustlike only
13600+517
#14117
(14117/14319)*100
#98.6% of my genes are included with clustlike only
#want to find out which genes are not assigned to motifs

final_genes_list_RUV <- union(final_genes_1_RUV, final_genes_2_RUV)
length(final_genes_list_RUV)
#8103 genes as found above
initial_genes_list_RUV <- rownames(lognormcounts_CMF_cpm)
length(initial_genes_list_RUV)
#14319 genes as usual

unassigned_genes_list_RUV <- setdiff(initial_genes_list_RUV, final_genes_list_RUV)
length(unassigned_genes_list_RUV)
#6216 genes not assigned

final_genes_list_clustlike_RUV <- union(clust1_genes_RUV, clust2_genes_RUV)
length(final_genes_list_clustlike_RUV)
#14117 genes as above with clustlike only

unassigned_genes_list_RUV_clustlike <- setdiff(initial_genes_list_RUV, final_genes_list_clustlike_RUV)
length(unassigned_genes_list_RUV_clustlike)
#202 genes not assigned

# saveRDS(unassigned_genes_list_RUV, "data/new/RUV/CMF/unassigned_genes_RUVlog2cpm_NormCounts_Cormotif.RDS")

# saveRDS(unassigned_genes_list_RUV_clustlike, "data/new/RUV/CMF/unassigned_genes_clustlike_RUVslog2cpm_NormCounts_Cormotif.RDS")

#now, ensure that none of these genes are shared amongst categories
vennCor_final_RUV <- list(final_genes_1_RUV, final_genes_2_RUV)
ggVennDiagram(
  vennCor_final_RUV,
  category.names = c("M1", "M2")
) + ggtitle("Cormotif DEGs clustlike + p.post RUVs log2cpm NC")+
  theme(
    plot.title = element_text(size = 16, face = "bold"),  # Increase title size
    text = element_text(size = 16)  # Increase text size globally
  )

vennCor_final_RUV_clust <- list(clust1_genes_RUV, clust2_genes_RUV)
ggVennDiagram(
  vennCor_final_RUV_clust,
  category.names = c("M1", "M2")
) + ggtitle("Cormotif DEGs clustlike RUVs log2cpm NC")+
  theme(
    plot.title = element_text(size = 16, face = "bold"),  # Increase title size
    text = element_text(size = 16)  # Increase text size globally
  )

#no overlapping genes found in these gene sets

clusterdata_dxr_fin_RUV <- data.frame(
  Category = c("Motif 1", "Motif 2"), 
  Value = c(length(final_genes_1_RUV), length(final_genes_2_RUV)
))

clusterdata_dxr_fin_RUV_clust <- data.frame(
  Category = c("Motif 1", "Motif 2"), 
  Value = c(length(clust1_genes_RUV), length(clust2_genes_RUV)
))


piecolors_dxr_fin <- c("Motif 1" = "#007896", 
                       "Motif 2" = "#58508D")

#make a piechart of these distributions
clusterdata_dxr_fin_RUV %>% ggplot(aes(x = "", y = Value, fill = Category))+
  geom_bar(width = 1, stat = "identity")+
  coord_polar("y", start = 0)+
  geom_text(aes(label = Value),
            position = position_stack(vjust = 0.5),
            size = 4, color = "black")+
  labs(title = "Distr of Gene Clusters Cormotif RUVs", x = NULL, y = NULL)+
  theme_void()+
  scale_fill_manual(values = piecolors_dxr_fin)

clusterdata_dxr_fin_RUV_clust %>% ggplot(aes(x = "", y = Value, fill = Category))+
  geom_bar(width = 1, stat = "identity")+
  coord_polar("y", start = 0)+
  geom_text(aes(label = Value),
            position = position_stack(vjust = 0.5),
            size = 4, color = "black")+
  labs(title = "Distr of Gene Clusters Cormotif RUVs clustlike", x = NULL, y = NULL)+
  theme_void()+
  scale_fill_manual(values = piecolors_dxr_fin)

#now, continue by plotting the logFC of all of these gene sets per motif, as well as look at some random genes for log2cpm to see if the patterns are reflected in the example genes
```
###clustlike RUVs log2cpm Norm Counts RUVs logFC
```{r logFC Cormotif log2cpm Norm Counts RUVs Plot}
####clustlike + p.post logFC of initial set####

##motif 1
length(final_genes_1_RUV)
##motif 2 
length(final_genes_2_RUV)

#read in my toptables from pairwise analysis
Toptable_RUV_24T <- read.csv("data/new/DEGs/Toptable_RUV_24T_final.csv")
Toptable_RUV_24R <- read.csv("data/new/DEGs/Toptable_RUV_24R_final.csv")
Toptable_RUV_144R <- read.csv("data/new/DEGs/Toptable_RUV_144R_final.csv")

#Combine the toptables I have from pairwise analysis into a single dataframe
d24_toptable_dxr_RUV <- Toptable_RUV_24T %>% 
  dplyr::select(-(X)) %>% 
  mutate(Time = "24T")

d24r_toptable_dxr_RUV <- Toptable_RUV_24R %>% 
  dplyr::select(-(X)) %>% 
  mutate(Time = "24R")

d144r_toptable_dxr_RUV <- Toptable_RUV_144R %>% 
  dplyr::select(-(X)) %>% 
  mutate(Time = "144R")

#combine your toptables together and then select the columns I want
combined_toptables_dxr_RUV <- bind_rows(
  d24_toptable_dxr_RUV,
  d24r_toptable_dxr_RUV,
  d144r_toptable_dxr_RUV)


#Filter the data based on each motif
filt_toptable_dxr_fin_RUV <- combined_toptables_dxr_RUV %>% 
  dplyr::filter(Entrez_ID  %in% final_genes_1_RUV) %>% 
  mutate(absFC = abs(logFC)) %>% 
  mutate(time = factor(Time, levels = c("24T", "24R", "144R"), labels = c("24hr", "24hr Recovery", "144hr Recovery"))) %>% 
  ggplot(., aes(x = time, y = logFC))+
  geom_boxplot(aes(fill = time))+
  scale_fill_manual(values = time_col)+
  guides(fill = guide_legend(title = "Time"))+
  theme_bw()+
  xlab(" ")+
  ylab("logFC")+
  theme_bw()+
  ggtitle("LogFC Motif 1 RUVs clustlike + p.post (n=7602)")+
  theme(plot.title = element_text(size = rel(1.5), hjust = 0.5),
        axis.title = element_text(size = 15, colour = "black"),
        strip.background = element_rect(fill = "#CAD899"),
        axis.text.x = element_text(size = 8, colour = "white", angle = 15),
        strip.text.x = element_text(size = 12, colour = "black", face = "bold"))

#motif 2
filt_toptable_2_dxr_fin_RUV <- combined_toptables_dxr_RUV %>% 
  dplyr::filter(Entrez_ID  %in% final_genes_2_RUV) %>% 
  mutate(absFC = abs(logFC)) %>% 
  mutate(time = factor(Time, levels = c("24T", "24R", "144R"), labels = c("24hr", "24hr Recovery", "144hr Recovery"))) %>% 
  ggplot(., aes(x = time, y = logFC))+
  geom_boxplot(aes(fill = time))+
  scale_fill_manual(values = time_col)+
  guides(fill = guide_legend(title = "Time"))+
  theme_bw()+
  xlab(" ")+
  ylab("logFC")+
  theme_bw()+
  ggtitle("LogFC Motif 2 RUVs clustlike + p.post (n=501)")+
  theme(plot.title = element_text(size = rel(1.5), hjust = 0.5),
        axis.title = element_text(size = 15, colour = "black"),
        strip.background = element_rect(fill = "#CAD899"),
        axis.text.x = element_text(size = 8, colour = "white", angle = 15),
        strip.text.x = element_text(size = 12, colour = "black", face = "bold"))


#plots
filt_toptable_dxr_fin_RUV
filt_toptable_2_dxr_fin_RUV 


#now plot the abs logFC for each of these too
filt_toptable_abs_fin_RUV <- combined_toptables_dxr_RUV %>% 
  dplyr::filter(Entrez_ID  %in% final_genes_1_RUV) %>% 
  mutate(absFC = abs(logFC)) %>% 
  mutate(time = factor(Time, levels = c("24T", "24R", "144R"), labels = c("24hr", "24hr Recovery", "144hr Recovery"))) %>% 
  ggplot(., aes(x = time, y = absFC))+
  geom_boxplot(aes(fill = time))+
  scale_fill_manual(values = time_col)+
  guides(fill = guide_legend(title = "Time"))+
  theme_bw()+
  xlab(" ")+
  ylab("|logFC|")+
  theme_bw()+
  ggtitle("Abs LogFC Motif 1 RUVs clustlike + p.post (n=7602)")+
  theme(plot.title = element_text(size = rel(1.5), hjust = 0.5),
        axis.title = element_text(size = 15, colour = "black"),
        strip.background = element_rect(fill = "#CAD899"),
        axis.text.x = element_text(size = 8, colour = "white", angle = 15),
        strip.text.x = element_text(size = 12, colour = "black", face = "bold"))

#motif 2
filt_toptable_2_abs_fin_RUV <- combined_toptables_dxr_RUV %>% 
  dplyr::filter(Entrez_ID  %in% final_genes_2_RUV) %>% 
  mutate(absFC = abs(logFC)) %>% 
  mutate(time = factor(Time, levels = c("24T", "24R", "144R"), labels = c("24hr", "24hr Recovery", "144hr Recovery"))) %>% 
  ggplot(., aes(x = time, y = absFC))+
  geom_boxplot(aes(fill = time))+
  scale_fill_manual(values = time_col)+
  guides(fill = guide_legend(title = "Time"))+
  theme_bw()+
  xlab(" ")+
  ylab("|logFC|")+
  theme_bw()+
  ggtitle("Abs LogFC Motif 2 RUVs clustlike + p.post (n=501)")+
  theme(plot.title = element_text(size = rel(1.5), hjust = 0.5),
        axis.title = element_text(size = 15, colour = "black"),
        strip.background = element_rect(fill = "#CAD899"),
        axis.text.x = element_text(size = 8, colour = "white", angle = 15),
        strip.text.x = element_text(size = 12, colour = "black", face = "bold"))


#plots
filt_toptable_abs_fin_RUV
filt_toptable_2_abs_fin_RUV


# ####Now do this but have it for the clustlike only genes
# ##motif 1
# length(clust1_genes_RUV)
# #13600
# ##motif 2 
# length(clust2_genes_RUV)
# #517 genes
# 
# #Filter the data based on each motif
# filt_toptable_dxr_fin_RUV_clust <- combined_toptables_dxr_RUV %>% 
#   dplyr::filter(entrezgene_ID  %in% clust1_genes_RUV) %>% 
#   mutate(absFC = abs(logFC)) %>% 
#   mutate(time = factor(Time, levels = c("24T", "24R", "144R"), labels = c("24hr", "24hr Recovery", "144hr Recovery"))) %>% 
#   ggplot(., aes(x = time, y = logFC))+
#   geom_boxplot(aes(fill = time))+
#   scale_fill_manual(values = time_col)+
#   guides(fill = guide_legend(title = "Time"))+
#   theme_bw()+
#   xlab(" ")+
#   ylab("logFC")+
#   theme_bw()+
#   ggtitle("LogFC Motif 1 RUVs clustlike (n=13600)")+
#   theme(plot.title = element_text(size = rel(1.5), hjust = 0.5),
#         axis.title = element_text(size = 15, colour = "black"),
#         strip.background = element_rect(fill = "#CAD899"),
#         axis.text.x = element_text(size = 8, colour = "white", angle = 15),
#         strip.text.x = element_text(size = 12, colour = "black", face = "bold"))
# 
# #motif 2
# filt_toptable_2_dxr_fin_RUV_clust <- combined_toptables_dxr_RUV %>% 
#   dplyr::filter(entrezgene_ID  %in% clust2_genes_RUV) %>% 
#   mutate(absFC = abs(logFC)) %>% 
#   mutate(time = factor(Time, levels = c("24T", "24R", "144R"), labels = c("24hr", "24hr Recovery", "144hr Recovery"))) %>% 
#   ggplot(., aes(x = time, y = logFC))+
#   geom_boxplot(aes(fill = time))+
#   scale_fill_manual(values = time_col)+
#   guides(fill = guide_legend(title = "Time"))+
#   theme_bw()+
#   xlab(" ")+
#   ylab("logFC")+
#   ggtitle("LogFC Motif 2 RUVs clustlike (n=517)")+
#   theme(plot.title = element_text(size = rel(1.5), hjust = 0.5),
#         axis.title = element_text(size = 15, colour = "black"),
#         strip.background = element_rect(fill = "#CAD899"),
#         axis.text.x = element_text(size = 8, colour = "white", angle = 15),
#         strip.text.x = element_text(size = 12, colour = "black", face = "bold"))
# 
# 
# #plots
# filt_toptable_dxr_fin_RUV_clust
# filt_toptable_2_dxr_fin_RUV_clust
# 
# 
# #now plot the abs logFC for each of these too
# filt_toptable_abs_fin_RUV_clust <- combined_toptables_dxr_RUV %>% 
#   dplyr::filter(entrezgene_ID  %in% clust1_genes_RUV) %>% 
#   mutate(absFC = abs(logFC)) %>% 
#   mutate(time = factor(Time, levels = c("24T", "24R", "144R"), labels = c("24hr", "24hr Recovery", "144hr Recovery"))) %>% 
#   ggplot(., aes(x = time, y = absFC))+
#   geom_boxplot(aes(fill = time))+
#   scale_fill_manual(values = time_col)+
#   guides(fill = guide_legend(title = "Time"))+
#   theme_bw()+
#   xlab(" ")+
#   ylab("|logFC|")+
#   theme_bw()+
#   ggtitle("Abs LogFC Motif 1 RUVs clustlike (n=13600)")+
#   theme(plot.title = element_text(size = rel(1.5), hjust = 0.5),
#         axis.title = element_text(size = 15, colour = "black"),
#         strip.background = element_rect(fill = "#CAD899"),
#         axis.text.x = element_text(size = 8, colour = "white", angle = 15),
#         strip.text.x = element_text(size = 12, colour = "black", face = "bold"))
# 
# #motif 2
# filt_toptable_2_abs_fin_RUV_clust <- combined_toptables_dxr_RUV %>% 
#   dplyr::filter(entrezgene_ID  %in% clust2_genes_RUV) %>% 
#   mutate(absFC = abs(logFC)) %>% 
#   mutate(time = factor(Time, levels = c("24T", "24R", "144R"), labels = c("24hr", "24hr Recovery", "144hr Recovery"))) %>% 
#   ggplot(., aes(x = time, y = absFC))+
#   geom_boxplot(aes(fill = time))+
#   scale_fill_manual(values = time_col)+
#   guides(fill = guide_legend(title = "Time"))+
#   theme_bw()+
#   xlab(" ")+
#   ylab("|logFC|")+
#   theme_bw()+
#   ggtitle("Abs LogFC Motif 2 RUVs clustlike (n=517)")+
#   theme(plot.title = element_text(size = rel(1.5), hjust = 0.5),
#         axis.title = element_text(size = 15, colour = "black"),
#         strip.background = element_rect(fill = "#CAD899"),
#         axis.text.x = element_text(size = 8, colour = "white", angle = 15),
#         strip.text.x = element_text(size = 12, colour = "black", face = "bold"))
# 
# 
# #plots
# filt_toptable_abs_fin_RUV_clust
# filt_toptable_2_abs_fin_RUV_clust


```

###log2cpm Example Genes Cormotif RUVs log2cpm Norm Counts
```{r log2cpm Example Genes Cormotif log2cpm Norm Counts}
#use the final genes from cross-verifying with clustlike + p.post

#Load in my count matrices
#final_genes_1_RUV
#final_genes_2_RUV

#clust1_genes_RUV
#clust2_genes_RUV

#these are all the genes that are present in each category, make them into dataframes by filtering out the rest of the genes in my main boxplot df
boxplots_cormotif <- boxplot1

motif1_genes_fin_RUV <- boxplots_cormotif[boxplots_cormotif$Entrez_ID %in% final_genes_1_RUV,]
dim(motif1_genes_fin_RUV)
#7602 genes in 44 cols
motif2_genes_fin_RUV <- boxplots_cormotif[boxplots_cormotif$Entrez_ID %in% final_genes_2_RUV,]
dim(motif2_genes_fin_RUV)
#501 genes in 44 cols

#pull out some random genes for each using sample

m1_genes_fin_RUV <- motif1_genes_fin_RUV[sample(nrow(motif1_genes_fin_RUV), 3), , drop = FALSE]

#Define gene list(s)
#these are the genes pulled out by m1_genes
initial_test_genes1_fin_RUV <- c(m1_genes_fin_RUV$SYMBOL)  
#Add more gene symbols as needed or add more categories

#Now put in the function I want to use to generate boxplots of genes
process_gene_data_1_fin_RUV <- function(gene) {
  gene_data <- m1_genes_fin_RUV %>% filter(SYMBOL == gene)
  long_data <- gene_data %>%
    pivot_longer(cols = -c(Entrez_ID, SYMBOL), names_to = "Sample", values_to = "log2CPM") %>%
    mutate(
      Drug = case_when(
        grepl("DOX", Sample) ~ "DOX",
        grepl("DMSO", Sample) ~ "DMSO",
        TRUE ~ NA_character_
      ),
      Timepoint = case_when(
        grepl("_24T_", Sample) ~ "24T",
        grepl("_24R_", Sample) ~ "24R",
        grepl("_144R_", Sample) ~ "144R",
        TRUE ~ NA_character_
      ),
      Indv = case_when(
        grepl("Ind1$", Sample) ~ "1",
        grepl("Ind2$", Sample) ~ "2",
        grepl("Ind3$", Sample) ~ "3",
        grepl("Ind4$", Sample) ~ "4",
        grepl("Ind5$", Sample) ~ "5",
        grepl("Ind6$", Sample) ~ "6",
        grepl("Ind6REP$", Sample) ~ "6R",
        TRUE ~ NA_character_
      ),
      Condition = paste(Drug, Timepoint, sep = "_")
    )
  long_data$Condition <- factor(
    long_data$Condition,
    levels = c(
      "DOX_24T", 
      "DMSO_24T", 
      "DOX_24R", 
      "DMSO_24R", 
      "DOX_144R", 
      "DMSO_144R"
    )
  )
  return(long_data)
}

#Generate Boxplots from the above function using our gene list above
for (gene in initial_test_genes1_fin_RUV) {
  gene_data <- process_gene_data_1_fin_RUV(gene)
  p <- ggplot(gene_data, aes(x = Condition, y = log2CPM, fill = Drug)) +
    geom_boxplot(outlier.shape = NA) +
    geom_point(aes(color = Indv), size = 2, alpha = 0.5, position = position_jitter(width = -1, height = 0)) +
    scale_fill_manual(values = c("DOX" = "#499FBD", "DMSO" = "#BBBBBC")) +
    ggtitle(paste("Log2CPM Expression", gene, "Motif 1 RUVs")) +
    labs(x = "Treatment", y = "log2CPM") +
    theme_bw() +
    theme(
      plot.title = element_text(size = rel(2), hjust = 0.5),
      axis.title = element_text(size = 15, color = "black"),
      axis.text.x = element_text(size = 10, color = "black", angle = 90, hjust = 1)
    )
  print(p)
}

#####motif 2#####

m2_genes_fin_RUV <- motif2_genes_fin_RUV[sample(nrow(motif2_genes_fin_RUV), 3), , drop = FALSE]

#Define gene list(s)
#these are the genes pulled out by m1_genes
initial_test_genes2_fin_RUV <- c(m2_genes_fin_RUV$SYMBOL)  
#Add more gene symbols as needed or add more categories

#Now put in the function I want to use to generate boxplots of genes
process_gene_datam2_fin_RUV <- function(gene) {
  gene_data <- motif2_genes_fin_RUV %>% filter(SYMBOL == gene)
  long_data <- gene_data %>%
    pivot_longer(cols = -c(Entrez_ID, SYMBOL), names_to = "Sample", values_to = "log2CPM") %>%
    mutate(
      Drug = case_when(
        grepl("DOX", Sample) ~ "DOX",
        grepl("DMSO", Sample) ~ "DMSO",
        TRUE ~ NA_character_
      ),
      Timepoint = case_when(
        grepl("_24T_", Sample) ~ "24T",
        grepl("_24R_", Sample) ~ "24R",
        grepl("_144R_", Sample) ~ "144R",
        TRUE ~ NA_character_
      ),
      Indv = case_when(
        grepl("Ind1$", Sample) ~ "1",
        grepl("Ind2$", Sample) ~ "2",
        grepl("Ind3$", Sample) ~ "3",
        grepl("Ind4$", Sample) ~ "4",
        grepl("Ind5$", Sample) ~ "5",
        grepl("Ind6$", Sample) ~ "6",
        grepl("Ind6REP$", Sample) ~ "6R",
        TRUE ~ NA_character_
      ),
      Condition = paste(Drug, Timepoint, sep = "_")
    )
  long_data$Condition <- factor(
    long_data$Condition,
    levels = c(
      "DOX_24T", 
      "DMSO_24T", 
      "DOX_24R", 
      "DMSO_24R", 
      "DOX_144R", 
      "DMSO_144R"
    )
  )
  return(long_data)
}

#this function is saved under process_gene_data so I will save as an R object

#saveRDS(process_gene_data, "data/new/process_gene_data_funct.RDS")

#Generate Boxplots from the above function using our gene list above
for (gene in initial_test_genes2_fin_RUV) {
  gene_data <- process_gene_datam2_fin_RUV(gene)
  p <- ggplot(gene_data, aes(x = Condition, y = log2CPM, fill = Drug)) +
    geom_boxplot(outlier.shape = NA) +
    geom_point(aes(color = Indv), size = 2, alpha = 0.5, position = position_jitter(width = -1, height = 0)) +
    scale_fill_manual(values = c("DOX" = "#499FBD", "DMSO" = "#BBBBBC")) +
    ggtitle(paste("Log2CPM Expression", gene, "Motif 2 RUVs")) +
    labs(x = "Treatment", y = "log2CPM") +
    theme_bw() +
    theme(
      plot.title = element_text(size = rel(2), hjust = 0.5),
      axis.title = element_text(size = 15, color = "black"),
      axis.text.x = element_text(size = 10, color = "black", angle = 90, hjust = 1)
    )
  print(p)
}

```

##log2cpm Example Genes Cormotif clustlike

```{r log2cpm Example Genes Cormotif RUVs clustlike}
#use the final genes from cross-verifying with clustlike + p.post

#Load in my count matrices

#clust1_genes_RUV
#clust2_genes_RUV

#these are all the genes that are present in each category, make them into dataframes by filtering out the rest of the genes in my main boxplot df
boxplots_cormotif <- boxplot1

motif1_genes_fin_RUV_clust <- boxplots_cormotif[boxplots_cormotif$Entrez_ID %in% clust1_genes_RUV,]
dim(motif1_genes_fin_RUV_clust)
#13600 genes in 44 cols
motif2_genes_fin_RUV_clust <- boxplots_cormotif[boxplots_cormotif$Entrez_ID %in% clust2_genes_RUV,]
dim(motif2_genes_fin_RUV_clust)
#517 genes in 44 cols

#pull out some random genes for each using sample

m1_genes_fin_RUV_clust <- motif1_genes_fin_RUV_clust[sample(nrow(motif1_genes_fin_RUV_clust), 3), , drop = FALSE]

#Define gene list(s)
#these are the genes pulled out by m1_genes
initial_test_genes1_fin_RUV_clust <- c(m1_genes_fin_RUV_clust$SYMBOL)  
#Add more gene symbols as needed or add more categories

#Now put in the function I want to use to generate boxplots of genes
process_gene_data_1_fin_RUV_clust <- function(gene) {
  gene_data <- m1_genes_fin_RUV_clust %>% filter(SYMBOL == gene)
  long_data <- gene_data %>%
    pivot_longer(cols = -c(Entrez_ID, SYMBOL), names_to = "Sample", values_to = "log2CPM") %>%
    mutate(
      Drug = case_when(
        grepl("DOX", Sample) ~ "DOX",
        grepl("DMSO", Sample) ~ "DMSO",
        TRUE ~ NA_character_
      ),
      Timepoint = case_when(
        grepl("_24T_", Sample) ~ "24T",
        grepl("_24R_", Sample) ~ "24R",
        grepl("_144R_", Sample) ~ "144R",
        TRUE ~ NA_character_
      ),
      Indv = case_when(
        grepl("Ind1$", Sample) ~ "1",
        grepl("Ind2$", Sample) ~ "2",
        grepl("Ind3$", Sample) ~ "3",
        grepl("Ind4$", Sample) ~ "4",
        grepl("Ind5$", Sample) ~ "5",
        grepl("Ind6$", Sample) ~ "6",
        grepl("Ind6REP$", Sample) ~ "6R",
        TRUE ~ NA_character_
      ),
      Condition = paste(Drug, Timepoint, sep = "_")
    )
  long_data$Condition <- factor(
    long_data$Condition,
    levels = c(
      "DOX_24T", 
      "DMSO_24T", 
      "DOX_24R", 
      "DMSO_24R", 
      "DOX_144R", 
      "DMSO_144R"
    )
  )
  return(long_data)
}

#Generate Boxplots from the above function using our gene list above
for (gene in initial_test_genes1_fin_RUV_clust) {
  gene_data <- process_gene_data_1_fin_RUV_clust(gene)
  p <- ggplot(gene_data, aes(x = Condition, y = log2CPM, fill = Drug)) +
    geom_boxplot(outlier.shape = NA) +
    geom_point(aes(color = Indv), size = 2, alpha = 0.5, position = position_jitter(width = -1, height = 0)) +
    scale_fill_manual(values = c("DOX" = "#499FBD", "DMSO" = "#BBBBBC")) +
    ggtitle(paste("Log2CPM Expression", gene, "M1 RUVs clustlike")) +
    labs(x = "Treatment", y = "log2CPM") +
    theme_bw() +
    theme(
      plot.title = element_text(size = rel(2), hjust = 0.5),
      axis.title = element_text(size = 15, color = "black"),
      axis.text.x = element_text(size = 10, color = "black", angle = 90, hjust = 1)
    )
  print(p)
}

#####motif 2#####

m2_genes_fin_RUV_clust <- motif2_genes_fin_RUV_clust[sample(nrow(motif2_genes_fin_RUV_clust), 3), , drop = FALSE]

#Define gene list(s)
#these are the genes pulled out by m1_genes
initial_test_genes2_fin_RUV_clust <- c(m2_genes_fin_RUV_clust$SYMBOL)  
#Add more gene symbols as needed or add more categories

#Now put in the function I want to use to generate boxplots of genes
process_gene_datam2_fin_RUV_clust <- function(gene) {
  gene_data <- motif2_genes_fin_RUV_clust %>% filter(SYMBOL == gene)
  long_data <- gene_data %>%
    pivot_longer(cols = -c(Entrez_ID, SYMBOL), names_to = "Sample", values_to = "log2CPM") %>%
    mutate(
      Drug = case_when(
        grepl("DOX", Sample) ~ "DOX",
        grepl("DMSO", Sample) ~ "DMSO",
        TRUE ~ NA_character_
      ),
      Timepoint = case_when(
        grepl("_24T_", Sample) ~ "24T",
        grepl("_24R_", Sample) ~ "24R",
        grepl("_144R_", Sample) ~ "144R",
        TRUE ~ NA_character_
      ),
      Indv = case_when(
        grepl("Ind1$", Sample) ~ "1",
        grepl("Ind2$", Sample) ~ "2",
        grepl("Ind3$", Sample) ~ "3",
        grepl("Ind4$", Sample) ~ "4",
        grepl("Ind5$", Sample) ~ "5",
        grepl("Ind6$", Sample) ~ "6",
        grepl("Ind6REP$", Sample) ~ "6R",
        TRUE ~ NA_character_
      ),
      Condition = paste(Drug, Timepoint, sep = "_")
    )
  long_data$Condition <- factor(
    long_data$Condition,
    levels = c(
      "DOX_24T", 
      "DMSO_24T", 
      "DOX_24R", 
      "DMSO_24R", 
      "DOX_144R", 
      "DMSO_144R"
    )
  )
  return(long_data)
}

#this function is saved under process_gene_data so I will save as an R object

#saveRDS(process_gene_data, "data/new/process_gene_data_funct.RDS")

#Generate Boxplots from the above function using our gene list above
for (gene in initial_test_genes2_fin_RUV_clust) {
  gene_data <- process_gene_datam2_fin_RUV_clust(gene)
  p <- ggplot(gene_data, aes(x = Condition, y = log2CPM, fill = Drug)) +
    geom_boxplot(outlier.shape = NA) +
    geom_point(aes(color = Indv), size = 2, alpha = 0.5, position = position_jitter(width = -1, height = 0)) +
    scale_fill_manual(values = c("DOX" = "#499FBD", "DMSO" = "#BBBBBC")) +
    ggtitle(paste("Log2CPM Expression", gene, "M2 RUVs clustlike")) +
    labs(x = "Treatment", y = "log2CPM") +
    theme_bw() +
    theme(
      plot.title = element_text(size = rel(2), hjust = 0.5),
      axis.title = element_text(size = 15, color = "black"),
      axis.text.x = element_text(size = 10, color = "black", angle = 90, hjust = 1)
    )
  print(p)
}

```


###Cormotif RUVs log2cpm Norm Counts GO/KEGG
```{r GO/KEGG log2cpm Norm Counts Cormotif}
#now take these final gene sets for each motif - clustlike + p.post consensus genes

# final_genes_1_RUV
# final_genes_2_RUV

#clust1_genes_RUV
#clust2_genes_RUV


library(gprofiler2)
#####Motif 1 Gene Set#####
# motif1_genes_matrix_RUV <- as.matrix(final_genes_1_RUV) 
# colnames(motif1_genes_matrix_RUV) <- c("entrezgene_ID")

# saveRDS(motif1_genes_matrix_RUV, "data/new/RUV/CMF/motif1_genes_matrix_RUV.RDS")

motif1_genes_matrix_RUV <- readRDS("data/new/RUV/CMF/motif1_genes_matrix_RUV.RDS")
length(motif1_genes_matrix_RUV)
#7602 genes in this set for motif 1

motif1_mat_GOKEGG_RUV <- gost(query = motif1_genes_matrix_RUV,
                          organism = "hsapiens",
                          ordered_query = FALSE,
                          measure_underrepresentation = FALSE,
                          evcodes = FALSE,
                          user_threshold = 0.05,
                          custom_bg = all_genes,
                          correction_method = c("fdr"),
                          sources = c("GO:BP", "KEGG"))

motif1_GOKEGG_genes_RUV <- gostplot(motif1_mat_GOKEGG_RUV, capped = FALSE, interactive = TRUE)
motif1_GOKEGG_genes_RUV

table_motif1_GOKEGG_genes_RUV <- motif1_mat_GOKEGG_RUV$result %>% 
  dplyr::select(c(source, term_id, term_name, intersection_size, term_size, p_value))

table_motif1_GOKEGG_genes_RUV %>% 
  mutate_at(.vars = 6, .funs = scales::label_scientific(digits=4)) %>% 
  kableExtra::kable(.,) %>% 
  kableExtra::kable_paper("striped", full_width = FALSE) %>% 
  kableExtra::kable_styling(full_width = FALSE, position = "left", bootstrap_options = c("striped", "hover")) %>% 
  kableExtra::scroll_box(width = "100%", height = "400px")

# write.csv(table_motif1_GOKEGG_genes, "data/new/table_motif1_GOKEGG_genes.csv")

#GO:BP
table_motif1_genes_GOBP_RUV <- table_motif1_GOKEGG_genes_RUV %>% 
  dplyr::filter(source=="GO:BP") %>% 
  dplyr::select(p_value, term_name, intersection_size) %>% 
  dplyr::slice_min(., n=10, order_by=p_value) %>% 
  mutate(log_val = -log10(p_value))

# saveRDS(table_motif1_genes_GOBP, "data/table_motif1_genes_GOBP.RDS")

table_motif1_genes_GOBP_RUV %>% ggplot(., aes(x = log_val, y = reorder(term_name, p_value), col= intersection_size)) +
  geom_point(aes(size = intersection_size)) +
  ggtitle("M1 Enriched GO:BP Terms RUVs")+
  xlab(expression("-log"[10]~"p-value"))+
  guides(col="none", size= guide_legend(title = "# of intersected \n terms"))+
  ylab("GO:BP term")+
  scale_y_discrete(labels = scales::label_wrap(30))+
  theme_bw()+
  theme(plot.title = element_text(size = rel(1.5), hjust = 0.5),
        axis.title = element_text(size = 15, colour = "black"),
        axis.ticks = element_line(linewidth = 1.5),
        axis.line = element_line(linewidth = 1.5),
        axis.text = element_text(size = 10, colour = "black", angle = 0),
        strip.text = element_text(size = 15, colour = "black", face = "bold"))

#KEGG
table_motif1_genes_KEGG_RUV <- table_motif1_GOKEGG_genes_RUV %>% 
  dplyr::filter(source=="KEGG") %>% 
  dplyr::select(p_value, term_name, intersection_size) %>% 
  dplyr::slice_min(., n=10, order_by=p_value) %>% 
  mutate(log_val = -log10(p_value))

table_motif1_genes_KEGG_RUV %>% ggplot(., aes(x = log_val, y = reorder(term_name, p_value), col= intersection_size)) +
  geom_point(aes(size = intersection_size)) +
  ggtitle("M1 DEGs Enriched KEGG Terms RUVs")+
  xlab(expression("-log"[10]~"p-value"))+
  guides(col="none", size= guide_legend(title = "# of intersected \n terms"))+
  ylab("KEGG term")+
  scale_y_discrete(labels = scales::label_wrap(30))+
  theme_bw()+
  theme(plot.title = element_text(size = rel(1.5), hjust = 0.5),
        axis.title = element_text(size = 15, colour = "black"),
        axis.ticks = element_line(linewidth = 1.5),
        axis.line = element_line(linewidth = 1.5),
        axis.text = element_text(size = 10, colour = "black", angle = 0),
        strip.text = element_text(size = 15, colour = "black", face = "bold"))

#####Motif 2 Genes#####
# motif2_genes_matrix_RUV <- as.matrix(final_genes_2_RUV) 
# colnames(motif2_genes_matrix_RUV) <- c("entrezgene_ID")

# saveRDS(motif2_genes_matrix_RUV, "data/new/RUV/CMF/motif2_genes_matrix_RUV.RDS")

motif2_genes_matrix_RUV <- readRDS("data/new/RUV/CMF/motif2_genes_matrix_RUV.RDS")
length(motif2_genes_matrix_RUV)
#501 genes in this set for motif 2

motif2_mat_GOKEGG_RUV <- gost(query = motif2_genes_matrix_RUV,
                          organism = "hsapiens",
                          ordered_query = FALSE,
                          measure_underrepresentation = FALSE,
                          evcodes = FALSE,
                          user_threshold = 0.05,
                          custom_bg = all_genes,
                          correction_method = c("fdr"),
                          sources = c("GO:BP", "KEGG"))

motif2_GOKEGG_genes_RUV <- gostplot(motif2_mat_GOKEGG_RUV, capped = FALSE, interactive = TRUE)
motif2_GOKEGG_genes_RUV

table_motif2_GOKEGG_genes_RUV <- motif2_mat_GOKEGG_RUV$result %>% 
  dplyr::select(c(source, term_id, term_name, intersection_size, term_size, p_value))

table_motif2_GOKEGG_genes_RUV %>% 
  mutate_at(.vars = 6, .funs = scales::label_scientific(digits=4)) %>% 
  kableExtra::kable(.,) %>% 
  kableExtra::kable_paper("striped", full_width = FALSE) %>% 
  kableExtra::kable_styling(full_width = FALSE, position = "left", bootstrap_options = c("striped", "hover")) %>% 
  kableExtra::scroll_box(width = "100%", height = "400px")

# write.csv(table_motif2_GOKEGG_genes, "data/new/table_motif2_GOKEGG_genes.csv")

#GO:BP
table_motif2_genes_GOBP_RUV <- table_motif2_GOKEGG_genes_RUV %>% 
  dplyr::filter(source=="GO:BP") %>% 
  dplyr::select(p_value, term_name, intersection_size) %>% 
  dplyr::slice_min(., n=10, order_by=p_value) %>% 
  mutate(log_val = -log10(p_value))

# saveRDS(table_motif2_genes_GOBP, "data/table_motif2_genes_GOBP.RDS")

table_motif2_genes_GOBP_RUV %>% ggplot(., aes(x = log_val, y = reorder(term_name, p_value), col= intersection_size)) +
  geom_point(aes(size = intersection_size)) +
  ggtitle("M2 Enriched GO:BP Terms RUVs")+
  xlab(expression("-log"[10]~"p-value"))+
  guides(col="none", size= guide_legend(title = "# of intersected \n terms"))+
  ylab("GO:BP term")+
  scale_y_discrete(labels = scales::label_wrap(30))+
  theme_bw()+
  theme(plot.title = element_text(size = rel(1.5), hjust = 0.5),
        axis.title = element_text(size = 15, colour = "black"),
        axis.ticks = element_line(linewidth = 1.5),
        axis.line = element_line(linewidth = 1.5),
        axis.text = element_text(size = 10, colour = "black", angle = 0),
        strip.text = element_text(size = 15, colour = "black", face = "bold"))

#KEGG
table_motif2_genes_KEGG_RUV <- table_motif2_GOKEGG_genes_RUV %>% 
  dplyr::filter(source=="KEGG") %>% 
  dplyr::select(p_value, term_name, intersection_size) %>% 
  dplyr::slice_min(., n=10, order_by=p_value) %>% 
  mutate(log_val = -log10(p_value))

table_motif2_genes_KEGG_RUV %>% ggplot(., aes(x = log_val, y = reorder(term_name, p_value), col= intersection_size)) +
  geom_point(aes(size = intersection_size)) +
  ggtitle("M2 DEGs Enriched KEGG Terms RUVs")+
  xlab(expression("-log"[10]~"p-value"))+
  guides(col="none", size= guide_legend(title = "# of intersected \n terms"))+
  ylab("KEGG term")+
  scale_y_discrete(labels = scales::label_wrap(30))+
  theme_bw()+
  theme(plot.title = element_text(size = rel(1.5), hjust = 0.5),
        axis.title = element_text(size = 15, colour = "black"),
        axis.ticks = element_line(linewidth = 1.5),
        axis.line = element_line(linewidth = 1.5),
        axis.text = element_text(size = 10, colour = "black", angle = 0),
        strip.text = element_text(size = 15, colour = "black", face = "bold"))

```

```{r GO/KEGG Cormotif log2cpm clustlike only}

#now take these final gene sets for each motif - clustlike + p.post consensus genes

#clust1_genes_RUV
#clust2_genes_RUV


# library(gprofiler2)
#####Motif 1 Gene Set#####
# motif1_genes_matrix_RUV_clust <- as.matrix(clust1_genes_RUV)
# colnames(motif1_genes_matrix_RUV_clust) <- c("entrezgene_ID")

# saveRDS(motif1_genes_matrix_RUV_clust, "data/new/RUV/CMF/motif1_genes_matrix_RUV_clustlike.RDS")

motif1_genes_matrix_RUV_clust <- readRDS("data/new/RUV/CMF/motif1_genes_matrix_RUV_clustlike.RDS")
length(motif1_genes_matrix_RUV_clust)
#13600 genes in this set for motif 1

motif1_mat_GOKEGG_RUV_clust <- gost(query = motif1_genes_matrix_RUV_clust,
                          organism = "hsapiens",
                          ordered_query = FALSE,
                          measure_underrepresentation = FALSE,
                          evcodes = FALSE,
                          user_threshold = 0.05,
                          custom_bg = all_genes,
                          correction_method = c("fdr"),
                          sources = c("GO:BP", "KEGG"))

motif1_GOKEGG_genes_RUV_clust <- gostplot(motif1_mat_GOKEGG_RUV_clust, capped = FALSE, interactive = TRUE)
motif1_GOKEGG_genes_RUV_clust

table_motif1_GOKEGG_genes_RUV_clust <- motif1_mat_GOKEGG_RUV_clust$result %>% 
  dplyr::select(c(source, term_id, term_name, intersection_size, term_size, p_value))

table_motif1_GOKEGG_genes_RUV_clust %>% 
  mutate_at(.vars = 6, .funs = scales::label_scientific(digits=4)) %>% 
  kableExtra::kable(.,) %>% 
  kableExtra::kable_paper("striped", full_width = FALSE) %>% 
  kableExtra::kable_styling(full_width = FALSE, position = "left", bootstrap_options = c("striped", "hover")) %>% 
  kableExtra::scroll_box(width = "100%", height = "400px")

# write.csv(table_motif1_GOKEGG_genes, "data/new/table_motif1_GOKEGG_genes.csv")

#GO:BP
table_motif1_genes_GOBP_RUV_clust <- table_motif1_GOKEGG_genes_RUV_clust %>% 
  dplyr::filter(source=="GO:BP") %>% 
  dplyr::select(p_value, term_name, intersection_size) %>% 
  dplyr::slice_min(., n=10, order_by=p_value) %>% 
  mutate(log_val = -log10(p_value))

# saveRDS(table_motif1_genes_GOBP, "data/table_motif1_genes_GOBP.RDS")

table_motif1_genes_GOBP_RUV_clust %>% ggplot(., aes(x = log_val, y = reorder(term_name, p_value), col= intersection_size)) +
  geom_point(aes(size = intersection_size)) +
  ggtitle("M1 Enriched GO:BP Terms RUVs clustlike")+
  xlab(expression("-log"[10]~"p-value"))+
  guides(col="none", size= guide_legend(title = "# of intersected \n terms"))+
  ylab("GO:BP term")+
  scale_y_discrete(labels = scales::label_wrap(30))+
  theme_bw()+
  theme(plot.title = element_text(size = rel(1.5), hjust = 0.5),
        axis.title = element_text(size = 15, colour = "black"),
        axis.ticks = element_line(linewidth = 1.5),
        axis.line = element_line(linewidth = 1.5),
        axis.text = element_text(size = 10, colour = "black", angle = 0),
        strip.text = element_text(size = 15, colour = "black", face = "bold"))

#KEGG
table_motif1_genes_KEGG_RUV_clust <- table_motif1_GOKEGG_genes_RUV_clust %>% 
  dplyr::filter(source=="KEGG") %>% 
  dplyr::select(p_value, term_name, intersection_size) %>% 
  dplyr::slice_min(., n=10, order_by=p_value) %>% 
  mutate(log_val = -log10(p_value))

table_motif1_genes_KEGG_RUV_clust %>% ggplot(., aes(x = log_val, y = reorder(term_name, p_value), col= intersection_size)) +
  geom_point(aes(size = intersection_size)) +
  ggtitle("M1 DEGs Enriched KEGG Terms RUVs clustlike")+
  xlab(expression("-log"[10]~"p-value"))+
  guides(col="none", size= guide_legend(title = "# of intersected \n terms"))+
  ylab("KEGG term")+
  scale_y_discrete(labels = scales::label_wrap(30))+
  theme_bw()+
  theme(plot.title = element_text(size = rel(1.5), hjust = 0.5),
        axis.title = element_text(size = 15, colour = "black"),
        axis.ticks = element_line(linewidth = 1.5),
        axis.line = element_line(linewidth = 1.5),
        axis.text = element_text(size = 10, colour = "black", angle = 0),
        strip.text = element_text(size = 15, colour = "black", face = "bold"))

#####Motif 2 Genes#####
# motif2_genes_matrix_RUV_clust <- as.matrix(clust2_genes_RUV)
# colnames(motif2_genes_matrix_RUV_clust) <- c("entrezgene_ID")

# saveRDS(motif2_genes_matrix_RUV_clust, "data/new/RUV/CMF/motif2_genes_matrix_RUV_clustlike.RDS")

motif2_genes_matrix_RUV_clust <- readRDS("data/new/RUV/CMF/motif2_genes_matrix_RUV_clustlike.RDS")
length(motif2_genes_matrix_RUV_clust)
#517 genes in this set for motif 2

motif2_mat_GOKEGG_RUV_clust <- gost(query = motif2_genes_matrix_RUV_clust,
                          organism = "hsapiens",
                          ordered_query = FALSE,
                          measure_underrepresentation = FALSE,
                          evcodes = FALSE,
                          user_threshold = 0.05,
                          custom_bg = all_genes,
                          correction_method = c("fdr"),
                          sources = c("GO:BP", "KEGG"))

motif2_GOKEGG_genes_RUV_clust <- gostplot(motif2_mat_GOKEGG_RUV_clust, capped = FALSE, interactive = TRUE)
motif2_GOKEGG_genes_RUV_clust

table_motif2_GOKEGG_genes_RUV_clust <- motif2_mat_GOKEGG_RUV_clust$result %>% 
  dplyr::select(c(source, term_id, term_name, intersection_size, term_size, p_value))

table_motif2_GOKEGG_genes_RUV_clust %>% 
  mutate_at(.vars = 6, .funs = scales::label_scientific(digits=4)) %>% 
  kableExtra::kable(.,) %>% 
  kableExtra::kable_paper("striped", full_width = FALSE) %>% 
  kableExtra::kable_styling(full_width = FALSE, position = "left", bootstrap_options = c("striped", "hover")) %>% 
  kableExtra::scroll_box(width = "100%", height = "400px")

# write.csv(table_motif2_GOKEGG_genes, "data/new/table_motif2_GOKEGG_genes.csv")

#GO:BP
table_motif2_genes_GOBP_RUV_clust <- table_motif2_GOKEGG_genes_RUV_clust %>% 
  dplyr::filter(source=="GO:BP") %>% 
  dplyr::select(p_value, term_name, intersection_size) %>% 
  dplyr::slice_min(., n=10, order_by=p_value) %>% 
  mutate(log_val = -log10(p_value))

# saveRDS(table_motif2_genes_GOBP, "data/table_motif2_genes_GOBP.RDS")

table_motif2_genes_GOBP_RUV_clust %>% ggplot(., aes(x = log_val, y = reorder(term_name, p_value), col= intersection_size)) +
  geom_point(aes(size = intersection_size)) +
  ggtitle("M2 Enriched GO:BP Terms RUVs clustlike")+
  xlab(expression("-log"[10]~"p-value"))+
  guides(col="none", size= guide_legend(title = "# of intersected \n terms"))+
  ylab("GO:BP term")+
  scale_y_discrete(labels = scales::label_wrap(30))+
  theme_bw()+
  theme(plot.title = element_text(size = rel(1.5), hjust = 0.5),
        axis.title = element_text(size = 15, colour = "black"),
        axis.ticks = element_line(linewidth = 1.5),
        axis.line = element_line(linewidth = 1.5),
        axis.text = element_text(size = 10, colour = "black", angle = 0),
        strip.text = element_text(size = 15, colour = "black", face = "bold"))

#KEGG
table_motif2_genes_KEGG_RUV_clust <- table_motif2_GOKEGG_genes_RUV_clust %>% 
  dplyr::filter(source=="KEGG") %>% 
  dplyr::select(p_value, term_name, intersection_size) %>% 
  dplyr::slice_min(., n=10, order_by=p_value) %>% 
  mutate(log_val = -log10(p_value))

table_motif2_genes_KEGG_RUV_clust %>% ggplot(., aes(x = log_val, y = reorder(term_name, p_value), col= intersection_size)) +
  geom_point(aes(size = intersection_size)) +
  ggtitle("M2 DEGs Enriched KEGG Terms RUVs clustlike")+
  xlab(expression("-log"[10]~"p-value"))+
  guides(col="none", size= guide_legend(title = "# of intersected \n terms"))+
  ylab("KEGG term")+
  scale_y_discrete(labels = scales::label_wrap(30))+
  theme_bw()+
  theme(plot.title = element_text(size = rel(1.5), hjust = 0.5),
        axis.title = element_text(size = 15, colour = "black"),
        axis.ticks = element_line(linewidth = 1.5),
        axis.line = element_line(linewidth = 1.5),
        axis.text = element_text(size = 10, colour = "black", angle = 0),
        strip.text = element_text(size = 15, colour = "black", face = "bold"))

```


##Attempt Cormotif with Norm Counts Only
```{r RUVs Cormotif Plain Norm Counts}
# #now since I'm having some strange outputs with the transformed data
# #I want to try and just feed in the normalized counts only
# 
normcounts_CMF_rep <- as.data.frame(set1$normalizedCounts)
# 
#first want to cut out the replicate samples as not needed for Cormotif
normcounts_CMF <- as.data.frame(normcounts_CMF_rep) %>%
  dplyr::select(-(contains("6R")))

# #14319 genes in 36 columns, set up for plugging into Cormotif

# #now I need to set up my groupid and compid accordingly
# #put together my group id and comparison id to make the correct comparisons between experimental conditions

# #groupid tells which experimental conditions are grouped together
# #compid tells which experimental conditions should be compared against one another
# ##ie DOX24T vs DMSO24T matched control

#groupid that doesn't require changing order of matrix:
# groupid_other <- c(
#   DOX_24T_1 = 1,
#   DMSO_24T_1 = 4,
#   DOX_24R_1 = 2,
#   DMSO_24R_1 = 5,
#   DOX_144R_1 = 3,
#   DMSO_144R_1 = 6,
# 
#   DOX_24T_2 = 1,
#   DMSO_24T_2 = 4,
#   DOX_24R_2 = 2,
#   DMSO_24R_2 = 5,
#   DOX_144R_2 = 3,
#   DMSO_144R_2 = 6,
# 
#   DOX_24T_3 = 1,
#   DMSO_24T_3 = 4,
#   DOX_24R_3 = 2,
#   DMSO_24R_3 = 5,
#   DOX_144R_3 = 3,
#   DMSO_144R_3 = 6,
# 
#   DOX_24T_4 = 1,
#   DMSO_24T_4 = 4,
#   DOX_24R_4 = 2,
#   DMSO_24R_4 = 5,
#   DOX_144R_4 = 3,
#   DMSO_144R_4 = 6,
# 
#   DOX_24T_5 = 1,
#   DMSO_24T_5 = 4,
#   DOX_24R_5 = 2,
#   DMSO_24R_5 = 5,
#   DOX_144R_5 = 3,
#   DMSO_144R_5 = 6,
# 
#   DOX_24T_6 = 1,
#   DMSO_24T_6 = 4,
#   DOX_24R_6 = 2,
#   DMSO_24R_6 = 5,
#   DOX_144R_6 = 3,
#   DMSO_144R_6 = 6
# )

groupid_other <- readRDS("data/new/RUV/groupid_other_unrearranged.RDS")

compid <- data.frame(Cond1 = c(1, 3, 5), Cond2 = c(2, 4, 6))
compid1 <- data.frame(Cond1 = c(1, 2, 3), Cond2 = c(4, 5, 6))

```

###Run Cormotif Norm Counts Only
```{r RUVs Run Cormotif NormCounts Only}

# #set the seed the same as the previous one to ensure consistency
# 
# #fit Cormotif model
# # set.seed(19191)
# # #only set the seed ONCE
# # 
# # motif.fit_RUV_NC_test <- cormotiffit(
# #   exprs = exprs.NC_CMF_RUV,
# #   groupid = groupid_other,
# #   compid = compid,
# #   K = 1:10,
# #   max.iter = 1000,
# #   BIC = TRUE,
# #   runtype = "counts"
# # )
# 
#saveRDS(motif.fit_RUV_NC_test, "data/new/RUV/motif.fit_RUVnormcounts_compid_250630.RDS")
motif.fit_RUV_NC_test <- readRDS("data/new/RUV/motif.fit_RUVnormcounts_250630.RDS")

```
###Plot Cormotif Norm Counts Only
```{r RUVs Plot Cormotif NormCounts Only}
# #plot the AIC and BIC (we're interested in the Bayesian most of all)

plotIC(motif.fit_RUV_NC_test)
# 
# #visual check of the lowest BIC
# motif.fit_RUV_NC_test$bic
# 
# #plot the motifs
plotMotif(motif.fit_RUV_NC_test)
# 
#plot the probability legend
myColors <-  rev(c("#FFFFFF", "#E6E6E6" ,"#CCCCCC", "#B3B3B3", "#999999", "#808080", "#666666","#4C4C4C", "#333333", "#191919","#000000"))

plot.new()
legend('bottomleft',fill=myColors, legend =rev(c("0", "0.1", "0.2", "0.3", "0.4",  "0.5", "0.6", "0.7", "0.8","0.9", "1")), box.col="white",title = "Probability\nlegend", horiz=FALSE,title.cex=.8)

```

Now that I've finished up with Cormotif, I want to make comparisons across DEGs and Cormotif analysis to identify DEGs within my motifs
I also want to find out if any of my DEGs within a certain category (DDR, DIC, p53 target genes) are enriched in a motif.
```{r Cormotif DDR Enrichment Proportion Barplots}
#testing for each motif whether DNA damage response genes are enriched in that motif compared to all other tested genes

DNA_damage_genes <- readRDS("data/new/RUV/DDR_genes_entrezid.RDS")

total_DNA_damage_genes <- length(DNA_damage_genes)  #Total number of DNA damage genes
#should be 65 genes

#define my Cormotif gene lists
CMF_genes <- list(
  "Motif1" = motif1_genes_matrix, "Motif2" = motif2_genes_matrix, "Motif3" = motif3_genes_matrix
)

all_tested_genes <- unique(unlist(CMF_genes))
#this has the 12087 used for clustlike+ p.post together
#usual gene set is 14319

#compute my sets
ddr_set <- unique(na.omit(DNA_damage_genes))

motif_enrichment <- purrr::map_dfr(names(CMF_genes), function(motif_name) {
  motif_genes <- unique(CMF_genes[[motif_name]])
  
  # #print results
  # print(motif_enrichment)
  
  # Count in motif 
  in_motif_ddr     <- sum(motif_genes %in% ddr_set)
  #number of genes inside the motif that are DDR
  in_motif_non_ddr <- length(motif_genes) - in_motif_ddr
  #number of genes inside motif that are NOT DDR
  
  # Count outside motif 
  other_genes <- setdiff(all_tested_genes, motif_genes)
  #checking the difference between all genes and motif genes
  out_motif_ddr     <- sum(other_genes %in% ddr_set)
  #all genes outside motif that are DDR
  out_motif_non_ddr <- length(other_genes) - out_motif_ddr
  #all genes outside the motif that are NOT DDR
  
  # Build contingency table
  contingency_ddr_cmf <- matrix(c(in_motif_ddr, in_motif_non_ddr,
                          out_motif_ddr, out_motif_non_ddr),
                        nrow = 2, byrow = TRUE)
  
  #print results to check size of contingency table
  print(contingency_ddr_cmf)
  
  # Perform fisher's exact test - sample size too small for chi-square
  fisher_test_ddr_cmf <- fisher.test(contingency_ddr_cmf)
  p_value <- fisher_test_ddr_cmf$p.value
  
  # Output summary
  tibble(
    Motif = motif_name,
    In_Motif_DDR = in_motif_ddr,
    In_Motif_NonDDR = in_motif_non_ddr,
    Out_Motif_DDR = out_motif_ddr,
    Out_Motif_NonDDR = out_motif_non_ddr,
    Total_Genes = length(motif_genes),
    DNA_Damage_Proportion = in_motif_ddr / length(motif_genes) * 100,
    P_Value = fisher_test_ddr_cmf$p.value
  )
}) %>%
  mutate(Significance = case_when(
    P_Value < 0.05  ~ "*",
    TRUE            ~ ""
  ))

# Recreate motif_long from motif_enrichment (with fixed column names)
motif_long <- motif_enrichment %>%
  select(Motif, In_Motif_DDR, In_Motif_NonDDR, P_Value) %>%  # include P_Value
  pivot_longer(cols = c(In_Motif_DDR, In_Motif_NonDDR),
               names_to = "Category", values_to = "Count") %>%
  mutate(
    Category = ifelse(Category == "In_Motif_DDR", "Yes", "No"),
    Fraction = Count / ave(Count, Motif, FUN = sum),
    
    # Add significance stars inline
    Significant = case_when(
      P_Value < 0.05  ~ "*",
      TRUE            ~ ""
    )
  )

#now I want to make sure that the yes is at the top so I have to reorder
motif_long$Category <- factor(motif_long$Category, levels = c("Yes", "No"))

#ensure that the stars are also on top for significance
label_positions <- motif_long %>%
  filter(Category == "Yes") %>%
  mutate(y_pos = Fraction + 1.01)  # 101% above the bar for visual clarity

# Plot with corrected star positioning
ggplot(motif_long, aes(x = Motif, y = Fraction, fill = Category)) +
  geom_bar(stat = "identity", position = "stack") +
  geom_text(
    data = label_positions %>% filter(Significant != ""),
    aes(x = Motif, y = y_pos, label = Significant),
    size = 6,
    color = "black",
    fontface = "bold"
  ) +
  scale_y_continuous(labels = scales::percent_format(scale = 1), limits = c(0, 1.08)) +
  scale_fill_manual(values = c("Yes" = "#e41a1c", "No" = "#377eb8")) +
  labs(
    title = "Proportion of DNA Damage Genes per Cormotif Motif",
    x = "Cormotif Motif",
    y = "Percentage",
    fill = "DDR Gene"
  ) +
  theme_minimal() +
  theme(
    axis.title = element_text(size = 14),
    axis.text = element_text(size = 12),
    plot.title = element_text(size = 16, hjust = 0.5)
  )

#print the proportions so I know the exact percentages and p values
print(motif_long)


```

```{r DIC Genes Cormotif Proportion Barplots}

DOX_cardiotox_genes <- readRDS("data/new/RUV/DIC_genes_entrezid.RDS")

total_DIC_genes <- length(DOX_cardiotox_genes)  #Total number of DNA damage genes
#should be 29

#define my Cormotif gene lists
CMF_genes <- list(
  "Motif1" = motif1_genes_matrix, "Motif2" = motif2_genes_matrix, "Motif3" = motif3_genes_matrix
)

all_tested_genes <- unique(unlist(CMF_genes))
#this has the 12087 used for clustlike+ p.post together
#usual gene set is 14319

#compute my sets
dic_set <- unique(na.omit(DOX_cardiotox_genes))

motif_enrichment_dic <- purrr::map_dfr(names(CMF_genes), function(motif_name) {
  motif_genes <- unique(CMF_genes[[motif_name]])
  
  # #print this result to compare
  # print(motif_enrichment_dic)
  
  # Count in motif 
  in_motif_dic     <- sum(motif_genes %in% dic_set)
  #number of genes inside the motif that are dic
  in_motif_non_dic <- length(motif_genes) - in_motif_dic
  #number of genes inside motif that are NOT dic
  
  # Count outside motif 
  other_genes <- setdiff(all_tested_genes, motif_genes)
  #checking the difference between all genes and motif genes
  out_motif_dic     <- sum(other_genes %in% dic_set)
  #all genes outside motif that are dic
  out_motif_non_dic <- length(other_genes) - out_motif_dic
  #all genes outside the motif that are NOT dic
  
  # Build contingency table
  contingency_dic_cmf <- matrix(c(in_motif_dic, in_motif_non_dic,
                          out_motif_dic, out_motif_non_dic),
                        nrow = 2, byrow = TRUE)
  #print my contingency table to check sample size 
  print(contingency_dic_cmf)
  
  # Perform fisher's exact test (sample size too small for chi-square)
  fisher_test_dic_cmf <- fisher.test(contingency_dic_cmf)
  p_value <- fisher_test_dic_cmf$p.value
  
  # Output summary
  tibble(
    Motif = motif_name,
    In_Motif_dic = in_motif_dic,
    In_Motif_Nondic = in_motif_non_dic,
    Out_Motif_dic = out_motif_dic,
    Out_Motif_Nondic = out_motif_non_dic,
    Total_Genes = length(motif_genes),
    DNA_Damage_Proportion = in_motif_dic / length(motif_genes) * 100,
    P_Value = fisher_test_dic_cmf$p.value
  )
}) %>%
  mutate(Significance = case_when(
    P_Value < 0.05  ~ "*",
    TRUE            ~ ""
  ))

# Recreate motif_long from motif_enrichment (with fixed column names)
motif_long_dic <- motif_enrichment_dic %>%
  select(Motif, In_Motif_dic, In_Motif_Nondic, P_Value) %>%  # include P_Value
  pivot_longer(cols = c(In_Motif_dic, In_Motif_Nondic),
               names_to = "Category", values_to = "Count") %>%
  mutate(
    Category = ifelse(Category == "In_Motif_dic", "Yes", "No"),
    Fraction = Count / ave(Count, Motif, FUN = sum),
    
    # Add significance stars inline
    Significant = case_when(
      P_Value < 0.05  ~ "*",
      TRUE            ~ ""
    )
  )

#now I want to make sure that the yes is at the top so I have to reorder
motif_long_dic$Category <- factor(motif_long_dic$Category, levels = c("Yes", "No"))

#ensure that the stars are also on top for significance
label_positions_dic <- motif_long_dic %>%
  filter(Category == "Yes") %>%
  mutate(y_pos = Fraction + 1.01)  # 101% above the bar for visual clarity

# Plot with corrected star positioning
ggplot(motif_long_dic, aes(x = Motif, y = Fraction, fill = Category)) +
  geom_bar(stat = "identity", position = "stack") +
  geom_text(
    data = label_positions_dic %>% filter(Significant != ""),
    aes(x = Motif, y = y_pos, label = Significant),
    size = 6,
    color = "black",
    fontface = "bold"
  ) +
  scale_y_continuous(labels = scales::percent_format(scale = 1), limits = c(0, 1.08)) +
  scale_fill_manual(values = c("Yes" = "#e41a1c", "No" = "#377eb8")) +
  labs(
    title = "Proportion of DOX Cardiotox Genes per Cormotif Motif",
    x = "Cormotif Motif",
    y = "Percentage",
    fill = "DIC Gene"
  ) +
  theme_minimal() +
  theme(
    axis.title = element_text(size = 14),
    axis.text = element_text(size = 12),
    plot.title = element_text(size = 16, hjust = 0.5)
  )

#print this so I know the p-value and percentages
print(motif_long_dic)

```

```{r Cormotif p53 Target Gene Enrichment Proportion Barplots}

p53_target_genes <- readRDS("data/new/RUV/p53_targetgenes_entrezid.RDS")

total_p53_genes <- length(p53_target_genes)  #Total number of p53 target genes
#should be 300

#define my Cormotif gene lists
CMF_genes <- list(
  "Motif1" = motif1_genes_matrix, "Motif2" = motif2_genes_matrix, "Motif3" = motif3_genes_matrix
)

all_tested_genes <- unique(unlist(CMF_genes))
#this has the 12087 used for clustlike+ p.post together
#usual gene set is 14319

#compute my sets
p53_set <- unique(na.omit(p53_target_genes))

motif_enrichment_p53 <- purrr::map_dfr(names(CMF_genes), function(motif_name) {
  motif_genes <- unique(CMF_genes[[motif_name]])
  
  # #print this dataset
  # print(motif_enrichment_p53)
  
  # Count in motif 
  in_motif_p53     <- sum(motif_genes %in% p53_set)
  #number of genes inside the motif that are p53
  in_motif_non_p53 <- length(motif_genes) - in_motif_p53
  #number of genes inside motif that are NOT p53
  
  # Count outside motif 
  other_genes <- setdiff(all_tested_genes, motif_genes)
  #checking the difference between all genes and motif genes
  out_motif_p53     <- sum(other_genes %in% p53_set)
  #all genes outside motif that are p53
  out_motif_non_p53 <- length(other_genes) - out_motif_p53
  #all genes outside the motif that are NOT p53
  
  # Build contingency table
  contingency_p53_cmf <- matrix(c(in_motif_p53, in_motif_non_p53,
                          out_motif_p53, out_motif_non_p53),
                        nrow = 2, byrow = TRUE)
  #print the results so I can visualize the contingency tables for my motifs
  print(contingency_p53_cmf)
  
  # Perform fishers exact test (sample size too small for chi-square)
  fisher_test_p53_cmf <- fisher.test(contingency_p53_cmf)
  p_value <- fisher_test_p53_cmf$p.value
  
  # Output summary
  tibble(
    Motif = motif_name,
    In_Motif_p53 = in_motif_p53,
    In_Motif_Nonp53 = in_motif_non_p53,
    Out_Motif_p53 = out_motif_p53,
    Out_Motif_Nonp53 = out_motif_non_p53,
    Total_Genes = length(motif_genes),
    DNA_Damage_Proportion = in_motif_p53 / length(motif_genes) * 100,
    P_Value = fisher_test_p53_cmf$p.value
  )
}) %>%
  mutate(Significance = case_when(
    P_Value < 0.05  ~ "*",
    TRUE            ~ ""
  ))

# Recreate motif_long from motif_enrichment (with fixed column names)
motif_long_p53 <- motif_enrichment_p53 %>%
  select(Motif, In_Motif_p53, In_Motif_Nonp53, P_Value) %>%  # include P_Value
  pivot_longer(cols = c(In_Motif_p53, In_Motif_Nonp53),
               names_to = "Category", values_to = "Count") %>%
  mutate(
    Category = ifelse(Category == "In_Motif_p53", "Yes", "No"),
    Fraction = Count / ave(Count, Motif, FUN = sum),
    
    # Add significance stars inline
    Significant = case_when(
      P_Value < 0.05  ~ "*",
      TRUE            ~ ""
    )
  )

#now I want to make sure that the yes is at the top so I have to reorder
motif_long_p53$Category <- factor(motif_long_p53$Category, levels = c("Yes", "No"))

#ensure that the stars are also on top for significance
label_positions_p53 <- motif_long_p53 %>%
  filter(Category == "Yes") %>%
  mutate(y_pos = Fraction + 1.01)  # 101% above the bar for visual clarity

# Plot with corrected star positioning
ggplot(motif_long_p53, aes(x = Motif, y = Fraction, fill = Category)) +
  geom_bar(stat = "identity", position = "stack") +
  geom_text(
    data = label_positions_p53 %>% filter(Significant != ""),
    aes(x = Motif, y = y_pos, label = Significant),
    size = 6,
    color = "black",
    fontface = "bold"
  ) +
  scale_y_continuous(labels = scales::percent_format(scale = 1), limits = c(0, 1.08)) +
  scale_fill_manual(values = c("Yes" = "#e41a1c", "No" = "#377eb8")) +
  labs(
    title = "Proportion of p53 Target Genes per Cormotif Motif",
    x = "Cormotif Motif",
    y = "Percentage",
    fill = "p53 Gene"
  ) +
  theme_minimal() +
  theme(
    axis.title = element_text(size = 14),
    axis.text = element_text(size = 12),
    plot.title = element_text(size = 16, hjust = 0.5)
  )

#print these data to check percentages and p-value
print(motif_long_p53)

```

##Cormotif Proportion Barplots New Motifs RUVs Corrected
###DDR Genes Proportion Barplot RUVs Cormotif
```{r DDR Genes Proportion Barplot Cormotif RUVs clustlike only}
# DNA_damage_genes <- readRDS("data/new/RUV/DNA_damage_genes_symbolentrez.RDS")

DNA_damage_genes <- readRDS("data/new/RUV/DDR_genes_entrezid.RDS")

total_DNA_damage_genes <- length(DNA_damage_genes)  #Total number of DNA damage genes
#should be 65 genes

#define my Cormotif gene lists
CMF_genes_RUV <- list(
  "Motif1" = final_genes_1_RUV, 
  "Motif2" = final_genes_2_RUV
)

all_tested_genes_RUV <- unique(unlist(CMF_genes_RUV))
#this has the 12087 used for clustlike+ p.post together
#usual gene set is 14319

#compute my sets
ddr_set <- unique(na.omit(DNA_damage_genes))

motif_enrichment_RUV <- purrr::map_dfr(names(CMF_genes_RUV), function(motif_name) {
  motif_genes_RUV <- unique(CMF_genes_RUV[[motif_name]])
  
  #print these results
  # print(motif_enrichment_RUV)
  
  # Count in motif 
  in_motif_ddr_RUV     <- sum(motif_genes_RUV %in% ddr_set)
  #number of genes inside the motif that are DDR
  in_motif_non_ddr_RUV <- length(motif_genes_RUV) - in_motif_ddr_RUV
  #number of genes inside motif that are NOT DDR
  
  # Count outside motif 
  other_genes_RUV <- setdiff(all_tested_genes_RUV, motif_genes_RUV)
  #checking the difference between all genes and motif genes
  out_motif_ddr_RUV     <- sum(other_genes_RUV %in% ddr_set)
  #all genes outside motif that are DDR
  out_motif_non_ddr_RUV <- length(other_genes_RUV) - out_motif_ddr_RUV
  #all genes outside the motif that are NOT DDR
  
  # Build contingency table
  contingency_ddr_cmf_RUV <- matrix(c(in_motif_ddr_RUV, in_motif_non_ddr_RUV,
                          out_motif_ddr_RUV, out_motif_non_ddr_RUV),
                        nrow = 2, byrow = TRUE)
  
  #print the contingency table to check sample size
  print(contingency_ddr_cmf_RUV)
  
  # Perform fisher's exact test - sample size too small and unreliable for chi-square
  fisher_test_ddr_cmf_RUV <- fisher.test(contingency_ddr_cmf_RUV)
  p_value_RUV <- fisher_test_ddr_cmf_RUV$p.value
  
  # Output summary
  tibble(
    Motif = motif_name,
    In_Motif_DDR = in_motif_ddr_RUV,
    In_Motif_NonDDR = in_motif_non_ddr_RUV,
    Out_Motif_DDR = out_motif_ddr_RUV,
    Out_Motif_NonDDR = out_motif_non_ddr_RUV,
    Total_Genes = length(motif_genes_RUV),
    DNA_Damage_Proportion = in_motif_ddr_RUV / length(motif_genes_RUV) * 100,
    P_Value = fisher_test_ddr_cmf_RUV$p.value
  )
}) %>%
  mutate(Significance = case_when(
    P_Value < 0.05  ~ "*",
    TRUE            ~ ""
  ))

# Recreate motif_long from motif_enrichment (with fixed column names)
motif_long_RUV <- motif_enrichment_RUV %>%
  select(Motif, In_Motif_DDR, In_Motif_NonDDR, P_Value) %>%  # include P_Value
  pivot_longer(cols = c(In_Motif_DDR, In_Motif_NonDDR),
               names_to = "Category", values_to = "Count") %>%
  mutate(
    Category = ifelse(Category == "In_Motif_DDR", "Yes", "No"),
    Fraction = Count / ave(Count, Motif, FUN = sum),
    
    # Add significance stars inline
    Significant = case_when(
      P_Value < 0.05  ~ "*",
      TRUE            ~ ""
    )
  )

#now I want to make sure that the yes is at the top so I have to reorder
motif_long_RUV$Category <- factor(motif_long_RUV$Category, levels = c("Yes", "No"))

#ensure that the stars are also on top for significance
label_positions_RUV <- motif_long_RUV %>%
  filter(Category == "Yes") %>%
  mutate(y_pos = Fraction + 1.01)  # 101% above the bar for visual clarity

# Plot with corrected star positioning
ggplot(motif_long_RUV, aes(x = Motif, y = Fraction, fill = Category)) +
  geom_bar(stat = "identity", position = "stack") +
  geom_text(
    data = label_positions_RUV %>% filter(Significant != ""),
    aes(x = Motif, y = y_pos, label = Significant),
    size = 6,
    color = "black",
    fontface = "bold"
  ) +
  scale_y_continuous(labels = scales::percent_format(scale = 1), limits = c(0, 1.08)) +
  scale_fill_manual(values = c("Yes" = "#e41a1c", "No" = "#377eb8")) +
  labs(
    title = "Proportion DDR Genes per Motif RUVs clustlike + p.post",
    x = "Cormotif Motif",
    y = "Percentage",
    fill = "DDR Gene"
  ) +
  theme_minimal() +
  theme(
    axis.title = element_text(size = 14),
    axis.text = element_text(size = 12),
    plot.title = element_text(size = 16, hjust = 0.5)
  )

#print this to see p-value and percentages
print(motif_long_RUV)

```

###DIC Genes Cormotif RUVs
```{r DIC Genes Proportion Barplot Cormotif RUVs clustlike only}
DOX_cardiotox_genes <- readRDS("data/new/RUV/DIC_genes_entrezid.RDS")

total_DIC_genes <- length(DOX_cardiotox_genes)  #Total number of DNA damage genes
#should be 29

#define my Cormotif gene lists
CMF_genes_RUV_clust <- list(
  "Motif1" = clust1_genes_RUV, "Motif2" = clust2_genes_RUV
)

all_tested_genes <- unique(unlist(CMF_genes_RUV_clust))
#this has the 14117 genes used for clustlike only
#usual gene set is 14319

#compute my sets
dic_set <- unique(na.omit(DOX_cardiotox_genes))

motif_enrichment_dic_RUV_clust <- purrr::map_dfr(names(CMF_genes_RUV_clust), function(motif_name) {
  motif_genes_dic_RUV_clust <- unique(CMF_genes_RUV_clust[[motif_name]])
  
  #print this to get a summary of results
  # print(motif_enrichment_dic_RUV_clust)
  
  # Count in motif 
  in_motif_dic_RUV_clust <- sum(motif_genes_dic_RUV_clust %in% dic_set)
  #number of genes inside the motif that are dic
  in_motif_non_dic_RUV_clust <- length(motif_genes_dic_RUV_clust) - in_motif_dic_RUV_clust
  #number of genes inside motif that are NOT dic
  
  # Count outside motif 
  other_genes_dic_RUV_clust <- setdiff(all_tested_genes, motif_genes_dic_RUV_clust)
  #checking the difference between all genes and motif genes
  out_motif_dic_RUV_clust     <- sum(other_genes_dic_RUV_clust %in% dic_set)
  #all genes outside motif that are dic
  out_motif_non_dic_RUV_clust <- length(other_genes_dic_RUV_clust) - out_motif_dic_RUV_clust
  #all genes outside the motif that are NOT dic
  
  # Build contingency table
  contingency_dic_cmf_RUV_clust <- matrix(c(in_motif_dic_RUV_clust,
                                            in_motif_non_dic_RUV_clust,
                                            out_motif_dic_RUV_clust,
                                            out_motif_non_dic_RUV_clust),
                                          nrow = 2, byrow = TRUE)
  #print
  print(contingency_dic_cmf_RUV_clust)
  
  # Perform fisher's exact test (sample size too small for chi-square)
  fisher_test_dic_cmf_RUV_clust <- fisher.test(contingency_dic_cmf_RUV_clust)
  p_value <- fisher_test_dic_cmf_RUV_clust$p.value
  
  # Output summary
  tibble(
    Motif = motif_name,
    In_Motif_dic = in_motif_dic_RUV_clust,
    In_Motif_Nondic = in_motif_non_dic_RUV_clust,
    Out_Motif_dic = out_motif_dic_RUV_clust,
    Out_Motif_Nondic = out_motif_non_dic_RUV_clust,
    Total_Genes = length(motif_genes_dic_RUV_clust),
    DNA_Damage_Proportion = in_motif_dic_RUV_clust / length(motif_genes_dic_RUV_clust) * 100,
    P_Value = fisher_test_dic_cmf_RUV_clust$p.value
  )
}) %>%
  mutate(Significance = case_when(
    P_Value < 0.05  ~ "*",
    TRUE            ~ ""
  ))

# Recreate motif_long from motif_enrichment (with fixed column names)
motif_long_dic_RUV_clust <- motif_enrichment_dic_RUV_clust %>%
  select(Motif, In_Motif_dic, In_Motif_Nondic, P_Value) %>%  # include P_Value
  pivot_longer(cols = c(In_Motif_dic, In_Motif_Nondic),
               names_to = "Category", values_to = "Count") %>%
  mutate(
    Category = ifelse(Category == "In_Motif_dic", "Yes", "No"),
    Fraction = Count / ave(Count, Motif, FUN = sum),
    
    # Add significance stars inline
    Significant = case_when(
      P_Value < 0.05  ~ "*",
      TRUE            ~ ""
    )
  )

#now I want to make sure that the yes is at the top so I have to reorder
motif_long_dic_RUV_clust$Category <- factor(motif_long_dic_RUV_clust$Category, levels = c("Yes", "No"))

#ensure that the stars are also on top for significance
label_positions_dic_RUV_clust <- motif_long_dic_RUV_clust %>%
  filter(Category == "Yes") %>%
  mutate(y_pos = Fraction + 1.01)  # 101% above the bar for visual clarity

# Plot with corrected star positioning
ggplot(motif_long_dic_RUV_clust, aes(x = Motif, y = Fraction, fill = Category)) +
  geom_bar(stat = "identity", position = "stack") +
  geom_text(
    data = label_positions_dic_RUV_clust %>% filter(Significant != ""),
    aes(x = Motif, y = y_pos, label = Significant),
    size = 6,
    color = "black",
    fontface = "bold"
  ) +
  scale_y_continuous(labels = scales::percent_format(scale = 1), limits = c(0, 1.08)) +
  scale_fill_manual(values = c("Yes" = "#e41a1c", "No" = "#377eb8")) +
  labs(
    title = "Proportion DOX Cardiotox Genes per Motif RUVs clustlike",
    x = "Cormotif Motif",
    y = "Percentage",
    fill = "DIC Gene"
  ) +
  theme_minimal() +
  theme(
    axis.title = element_text(size = 14),
    axis.text = element_text(size = 12),
    plot.title = element_text(size = 16, hjust = 0.5)
  )

#print these data to check p-value and percentages
print(motif_long_dic_RUV_clust)

```

###DIC Genes RUVs Cormotif Proportion Barplot clustlike + p.post
```{r DIC Genes Proportion Barplot Cormotif RUVs clust+p.post}
DOX_cardiotox_genes <- readRDS("data/new/RUV/DIC_genes_entrezid.RDS")

total_DIC_genes <- length(DOX_cardiotox_genes)  #Total number of DNA damage genes
#should be 29

#define my Cormotif gene lists
CMF_genes_RUV <- list(
  "Motif1" = final_genes_1_RUV, "Motif2" = final_genes_2_RUV
)

all_tested_genes <- unique(unlist(CMF_genes_RUV))
#this has the 12087 used for clustlike+ p.post together
#usual gene set is 14319

#compute my sets
dic_set <- unique(na.omit(DOX_cardiotox_genes))

motif_enrichment_dic_RUV <- purrr::map_dfr(names(CMF_genes_RUV), function(motif_name) {
  motif_genes_dic_RUV <- unique(CMF_genes_RUV[[motif_name]])
  
  # print(motif_enrichment_dic_RUV)
  
  # Count in motif 
  in_motif_dic_RUV <- sum(motif_genes_dic_RUV %in% dic_set)
  #number of genes inside the motif that are dic
  in_motif_non_dic_RUV <- length(motif_genes_dic_RUV) - in_motif_dic_RUV
  #number of genes inside motif that are NOT dic
  
  # Count outside motif 
  other_genes_dic_RUV <- setdiff(all_tested_genes, motif_genes_dic_RUV)
  #checking the difference between all genes and motif genes
  out_motif_dic_RUV     <- sum(other_genes_dic_RUV %in% dic_set)
  #all genes outside motif that are dic
  out_motif_non_dic_RUV <- length(other_genes_dic_RUV) - out_motif_dic_RUV
  #all genes outside the motif that are NOT dic
  
  # Build contingency table
  contingency_dic_cmf_RUV <- matrix(c(in_motif_dic_RUV, in_motif_non_dic_RUV,
                          out_motif_dic_RUV, out_motif_non_dic_RUV),
                        nrow = 2, byrow = TRUE)
  
  #print contingency table
  print(contingency_dic_cmf_RUV)
  
  # Perform fisher's exact test
  fisher_test_dic_cmf_RUV <- fisher.test(contingency_dic_cmf_RUV)
  p_value <- fisher_test_dic_cmf_RUV$p.value
  
  # Output summary
  tibble(
    Motif = motif_name,
    In_Motif_dic = in_motif_dic_RUV,
    In_Motif_Nondic = in_motif_non_dic_RUV,
    Out_Motif_dic = out_motif_dic_RUV,
    Out_Motif_Nondic = out_motif_non_dic_RUV,
    Total_Genes = length(motif_genes_dic_RUV),
    DNA_Damage_Proportion = in_motif_dic_RUV / length(motif_genes_dic_RUV) * 100,
    P_Value = fisher_test_dic_cmf_RUV$p.value
  )
}) %>%
  mutate(Significance = case_when(
    P_Value < 0.05  ~ "*",
    TRUE            ~ ""
  ))

# Recreate motif_long from motif_enrichment (with fixed column names)
motif_long_dic_RUV <- motif_enrichment_dic_RUV %>%
  select(Motif, In_Motif_dic, In_Motif_Nondic, P_Value) %>%  # include P_Value
  pivot_longer(cols = c(In_Motif_dic, In_Motif_Nondic),
               names_to = "Category", values_to = "Count") %>%
  mutate(
    Category = ifelse(Category == "In_Motif_dic", "Yes", "No"),
    Fraction = Count / ave(Count, Motif, FUN = sum),
    
    # Add significance stars inline
    Significant = case_when(
      P_Value < 0.05  ~ "*",
      TRUE            ~ ""
    )
  )

#now I want to make sure that the yes is at the top so I have to reorder
motif_long_dic_RUV$Category <- factor(motif_long_dic_RUV$Category, levels = c("Yes", "No"))

#ensure that the stars are also on top for significance
label_positions_dic_RUV <- motif_long_dic_RUV %>%
  filter(Category == "Yes") %>%
  mutate(y_pos = Fraction + 1.01)  # 101% above the bar for visual clarity

# Plot with corrected star positioning
ggplot(motif_long_dic_RUV, aes(x = Motif, y = Fraction, fill = Category)) +
  geom_bar(stat = "identity", position = "stack") +
  geom_text(
    data = label_positions_dic_RUV %>% filter(Significant != ""),
    aes(x = Motif, y = y_pos, label = Significant),
    size = 6,
    color = "black",
    fontface = "bold"
  ) +
  scale_y_continuous(labels = scales::percent_format(scale = 1), limits = c(0, 1.08)) +
  scale_fill_manual(values = c("Yes" = "#e41a1c", "No" = "#377eb8")) +
  labs(
    title = "Proportion DOX Cardiotox Genes per Motif RUVs clustlike",
    x = "Cormotif Motif",
    y = "Percentage",
    fill = "DIC Gene"
  ) +
  theme_minimal() +
  theme(
    axis.title = element_text(size = 14),
    axis.text = element_text(size = 12),
    plot.title = element_text(size = 16, hjust = 0.5)
  )
```

###p53 Target Genes Cormotif RUVs
```{r p53 Target Genes Proportion Barplot Cormotif RUVs clustlike only}
p53_target_genes <- readRDS("data/new/RUV/p53_targetgenes_entrezid.RDS")

total_p53_genes <- length(p53_target_genes)  #Total number of p53 target genes
#should be 300

#define my Cormotif gene lists
CMF_genes_RUV_clust <- list(
  "Motif1" = clust1_genes_RUV, "Motif2" = clust2_genes_RUV
)

all_tested_genes_RUV_clust <- unique(unlist(CMF_genes_RUV_clust))
#this has the 14117 used for clustlike only
#usual gene set is 14319

#compute my sets
p53_set <- unique(na.omit(p53_target_genes))

motif_enrichment_p53_RUV_clust <- purrr::map_dfr(names(CMF_genes_RUV_clust), function(motif_name) {
  motif_genes_p53_RUV_clust <- unique(CMF_genes_RUV_clust[[motif_name]])
  
  # Count in motif 
  in_motif_p53_RUV_clust     <- sum(motif_genes_p53_RUV_clust %in% p53_set)
  #number of genes inside the motif that are p53
  in_motif_non_p53_RUV_clust <- length(motif_genes_p53_RUV_clust) - in_motif_p53_RUV_clust
  #number of genes inside motif that are NOT p53
  
  # Count outside motif 
  other_genes_p53_RUV_clust <- setdiff(all_tested_genes_RUV_clust, motif_genes_p53_RUV_clust)
  #checking the difference between all genes and motif genes
  out_motif_p53_RUV_clust <- sum(other_genes_p53_RUV_clust %in% p53_set)
  #all genes outside motif that are p53
  out_motif_non_p53_RUV_clust <- length(other_genes_p53_RUV_clust) - out_motif_p53_RUV_clust
  #all genes outside the motif that are NOT p53
  
  # Build contingency table
  contingency_p53_cmf_RUV_clust <- matrix(c(in_motif_p53_RUV_clust,
                                            in_motif_non_p53_RUV_clust,
                                            out_motif_p53_RUV_clust,
                                            out_motif_non_p53_RUV_clust),
                                          nrow = 2, byrow = TRUE)
  
  #print my contingency table
  print(contingency_p53_cmf_RUV_clust)
  
  # Perform fisher's exact test
  fisher_test_p53_cmf_RUV_clust <- fisher.test(contingency_p53_cmf_RUV_clust)
  p_value_RUV_clust <- fisher_test_p53_cmf_RUV_clust$p.value
  
  # Output summary
  tibble(
    Motif = motif_name,
    In_Motif_p53 = in_motif_p53_RUV_clust,
    In_Motif_Nonp53 = in_motif_non_p53_RUV_clust,
    Out_Motif_p53 = out_motif_p53_RUV_clust,
    Out_Motif_Nonp53 = out_motif_non_p53_RUV_clust,
    Total_Genes = length(motif_genes_p53_RUV_clust),
    DNA_Damage_Proportion = in_motif_p53_RUV_clust / length(motif_genes_p53_RUV_clust) * 100,
    P_Value = fisher_test_p53_cmf_RUV_clust$p.value
  )
}) %>%
  mutate(Significance = case_when(
    P_Value < 0.05  ~ "*",
    TRUE            ~ ""
  ))

# Recreate motif_long from motif_enrichment (with fixed column names)
motif_long_p53_RUV_clust <- motif_enrichment_p53_RUV_clust %>%
  select(Motif, In_Motif_p53, In_Motif_Nonp53, P_Value) %>%  # include P_Value
  pivot_longer(cols = c(In_Motif_p53, In_Motif_Nonp53),
               names_to = "Category", values_to = "Count") %>%
  mutate(
    Category = ifelse(Category == "In_Motif_p53", "Yes", "No"),
    Fraction = Count / ave(Count, Motif, FUN = sum),
    
    # Add significance stars inline
    Significant = case_when(
      P_Value < 0.05  ~ "*",
      TRUE            ~ ""
    )
  )

#now I want to make sure that the yes is at the top so I have to reorder
motif_long_p53_RUV_clust$Category <- factor(motif_long_p53_RUV_clust$Category, levels = c("Yes", "No"))

#ensure that the stars are also on top for significance
label_positions_p53_RUV_clust <- motif_long_p53_RUV_clust %>%
  filter(Category == "Yes") %>%
  mutate(y_pos = Fraction + 1.01)  # 101% above the bar for visual clarity

# Plot with corrected star positioning
ggplot(motif_long_p53_RUV_clust, aes(x = Motif, y = Fraction, fill = Category)) +
  geom_bar(stat = "identity", position = "stack") +
  geom_text(
    data = label_positions_p53_RUV_clust %>% filter(Significant != ""),
    aes(x = Motif, y = y_pos, label = Significant),
    size = 6,
    color = "black",
    fontface = "bold"
  ) +
  scale_y_continuous(labels = scales::percent_format(scale = 1), limits = c(0, 1.08)) +
  scale_fill_manual(values = c("Yes" = "#e41a1c", "No" = "#377eb8")) +
  labs(
    title = "Proportion p53 Target Genes per Motif RUVs clustlike",
    x = "Cormotif Motif",
    y = "Percentage",
    fill = "p53 Gene"
  ) +
  theme_minimal() +
  theme(
    axis.title = element_text(size = 14),
    axis.text = element_text(size = 12),
    plot.title = element_text(size = 16, hjust = 0.5)
  )

#print this dataframe to look at p-value and percentage
print(motif_long_p53_RUV_clust)

```
###p53 Target Genes Cormotif RUVs p.post + clustlike
```{r p53 Target Genes Cormotif RUVs p.post + clustlike}

p53_target_genes <- readRDS("data/new/RUV/p53_targetgenes_entrezid.RDS")

total_p53_genes <- length(p53_target_genes)  #Total number of p53 target genes
#should be 300

#define my Cormotif gene lists
CMF_genes_RUV <- list(
  "Motif1" = final_genes_1_RUV, 
  "Motif2" = final_genes_2_RUV
)
#7602 genes motif 1 + 501 genes motif 2

all_tested_genes_RUV <- unique(unlist(CMF_genes_RUV))
#this has the 8103 genes used for clustlike + p.post
#usual gene set is 14319

#compute my sets
p53_set <- unique(na.omit(p53_target_genes))

motif_enrichment_p53_RUV <- purrr::map_dfr(names(CMF_genes_RUV), function(motif_name) {
  motif_genes_p53_RUV <- unique(CMF_genes_RUV[[motif_name]])
  
  #print results
  # print(motif_enrichment_p53_RUV)
  
  # Count in motif 
  in_motif_p53_RUV     <- sum(motif_genes_p53_RUV %in% p53_set)
  #number of genes inside the motif that are p53
  in_motif_non_p53_RUV <- length(motif_genes_p53_RUV) - in_motif_p53_RUV
  #number of genes inside motif that are NOT p53
  
  # Count outside motif 
  other_genes_p53_RUV <- setdiff(all_tested_genes_RUV, motif_genes_p53_RUV)
  #checking the difference between all genes and motif genes
  out_motif_p53_RUV <- sum(other_genes_p53_RUV %in% p53_set)
  #all genes outside motif that are p53
  out_motif_non_p53_RUV <- length(other_genes_p53_RUV) - out_motif_p53_RUV
  #all genes outside the motif that are NOT p53
  
  # Build contingency table
  contingency_p53_cmf_RUV <- matrix(c(in_motif_p53_RUV, in_motif_non_p53_RUV,
                          out_motif_p53_RUV, out_motif_non_p53_RUV),
                        nrow = 2, byrow = TRUE)
  #print my contingency tables
  print(contingency_p53_cmf_RUV)
  
  # Perform fisher's exact test
  fisher_test_p53_cmf_RUV <- fisher.test(contingency_p53_cmf_RUV)
  p_value_RUV <- fisher_test_p53_cmf_RUV$p.value
  
  # Output summary
  tibble(
    Motif = motif_name,
    In_Motif_p53 = in_motif_p53_RUV,
    In_Motif_Nonp53 = in_motif_non_p53_RUV,
    Out_Motif_p53 = out_motif_p53_RUV,
    Out_Motif_Nonp53 = out_motif_non_p53_RUV,
    Total_Genes = length(motif_genes_p53_RUV),
    DNA_Damage_Proportion = in_motif_p53_RUV / length(motif_genes_p53_RUV) * 100,
    P_Value = fisher_test_p53_cmf_RUV$p.value
  )
}) %>%
  mutate(Significance = case_when(
    P_Value < 0.05  ~ "*",
    TRUE            ~ ""
  ))

# Recreate motif_long from motif_enrichment (with fixed column names)
motif_long_p53_RUV <- motif_enrichment_p53_RUV %>%
  select(Motif, In_Motif_p53, In_Motif_Nonp53, P_Value) %>%  # include P_Value
  pivot_longer(cols = c(In_Motif_p53, In_Motif_Nonp53),
               names_to = "Category", values_to = "Count") %>%
  mutate(
    Category = ifelse(Category == "In_Motif_p53", "Yes", "No"),
    Fraction = Count / ave(Count, Motif, FUN = sum),
    
    # Add significance stars inline
    Significant = case_when(
      P_Value < 0.05  ~ "*",
      TRUE            ~ ""
    )
  )

#now I want to make sure that the yes is at the top so I have to reorder
motif_long_p53_RUV$Category <- factor(motif_long_p53_RUV$Category, levels = c("Yes", "No"))

#ensure that the stars are also on top for significance
label_positions_p53_RUV <- motif_long_p53_RUV %>%
  filter(Category == "Yes") %>%
  mutate(y_pos = Fraction + 1.01)  # 101% above the bar for visual clarity

# Plot with corrected star positioning
ggplot(motif_long_p53_RUV, aes(x = Motif, y = Fraction, fill = Category)) +
  geom_bar(stat = "identity", position = "stack") +
  geom_text(
    data = label_positions_p53_RUV %>% filter(Significant != ""),
    aes(x = Motif, y = y_pos, label = Significant),
    size = 6,
    color = "black",
    fontface = "bold"
  ) +
  scale_y_continuous(labels = scales::percent_format(scale = 1), limits = c(0, 1.08)) +
  scale_fill_manual(values = c("Yes" = "#e41a1c", "No" = "#377eb8")) +
  labs(
    title = "Proportion p53 Target Genes per Motif RUVs clustlike + p.post",
    x = "Cormotif Motif",
    y = "Percentage",
    fill = "p53 Gene"
  ) +
  theme_minimal() +
  theme(
    axis.title = element_text(size = 14),
    axis.text = element_text(size = 12),
    plot.title = element_text(size = 16, hjust = 0.5)
  )

print(motif_long_p53_RUV)
```

#Final Cormotif RUVs Analysis
We will continue forward with the RUVs corrected data based on log2cpm of normalized counts
We will then use the Cormotif gene sets based on p.post and clustlike together
##DDR Proportion Bar plots Redo
```{r DDR Cormotif RUVs Proportion Barplots}

#I am going to alter my strategy to identify the proportion of genes within one motif that are or are not DDR, do the same for the second motif, and then test between the two for differences in their proportions

#read in my DDR gene set
DNA_damage_genes <- readRDS("data/new/RUV/DDR_genes_entrezid.RDS")

ddr_set <- unique(na.omit(DNA_damage_genes))

#DDR genes inside each motif
in_motif1_DDR <- sum(final_genes_1_RUV %in% ddr_set)
in_motif2_DDR <- sum(final_genes_2_RUV %in% ddr_set)

#non-DDR genes inside each motif
in_motif1_nonDDR <- length(final_genes_1_RUV) - in_motif1_DDR
in_motif2_nonDDR <- length(final_genes_2_RUV) - in_motif2_DDR

#make contingency tables for fishers exact tests
contingency_motifs_DDR <- matrix(c(
  in_motif1_DDR, in_motif1_nonDDR,
  in_motif2_DDR, in_motif2_nonDDR),
  nrow = 2, byrow = TRUE
)

#print the contingency tables
print(contingency_motifs_DDR)

#perform a fisher's exact test (small sample size)
fisher_test_motifs_DDR <- fisher.test(contingency_motifs_DDR)
#print fisher's exact test results
print(fisher_test_motifs_DDR)

#make a summary table of all of these data to plot
motif_summary_DDR <- tibble(
  Motif = c("Motif1", "Motif2"),
  DDR = c(in_motif1_DDR, in_motif2_DDR),
  non_DDR = c(in_motif1_nonDDR, in_motif2_nonDDR)
) %>%
  pivot_longer(cols = c(DDR, non_DDR), names_to = "Category", values_to = "Count") %>%
  mutate(
    Category = ifelse(Category == "DDR", "Yes", "No"),
    Fraction = Count / ave(Count, Motif, FUN = sum),
    Significant = ifelse(Category == "Yes" & fisher_test_motifs_DDR$p.value < 0.05, "*", "")
  )

#position significance stars just above bars
label_positions_DDR <- motif_summary_DDR %>%
  filter(Category == "Yes") %>%
  mutate(y_pos = Fraction + 1.01)

#change the ordering so that yes is on the top
motif_summary_DDR$Category <- factor(motif_summary_DDR$Category, levels = c("Yes", "No"))

#plot the proportions in a barplot
ggplot(motif_summary_DDR, aes(x = Motif, y = Fraction, fill = Category)) +
  geom_bar(stat = "identity", position = "stack") +
  geom_text(
    data = label_positions_DDR %>% filter(Significant != ""),
    aes(x = Motif, y = y_pos, label = Significant),
    size = 6,
    color = "black",
    fontface = "bold"
  ) +
  scale_y_continuous(labels = scales::percent_format(scale = 1), limits = c(0, 1.08)) +
  scale_fill_manual(values = c("Yes" = "#e41a1c", "No" = "#377eb8")) +
  labs(
    title = "Proportion of DDR Genes in Motif 1 vs Motif 2 (RUVs clust + p.post)",
    x = "Cormotif Motif",
    y = "Percentage",
    fill = "DDR Gene"
  ) +
  theme_minimal() +
  theme(
    axis.title = element_text(size = 14),
    axis.text = element_text(size = 12),
    plot.title = element_text(size = 16, hjust = 0.5)
  )


#print the proportions and p values
prop_motif1_DDR <- in_motif1_DDR / length(final_genes_1_RUV)
prop_motif2_DDR <- in_motif2_DDR / length(final_genes_2_RUV)
p_val_DDR <- fisher_test_motifs_DDR$p.value

cat(sprintf("Motif1: %.2f%% DDR genes (%d/%d)\n", 100*prop_motif1_DDR, in_motif1_DDR, length(final_genes_1_RUV)))
cat(sprintf("Motif2: %.2f%% DDR genes (%d/%d)\n", 100*prop_motif2_DDR, in_motif2_DDR, length(final_genes_2_RUV)))
cat(sprintf("DDR Fisher's Exact Test p-value: %.5f\n", p_val_DDR))
cat(sprintf("Odds ratio: %.3f\n", fisher_test_motifs_DDR$estimate))



```

##DIC Proportion Bar plots Redo
```{r DIC Genes Proportion Barplots RUVs clustlike + p.post}

#read in my DIC gene set
DOX_cardiotox_genes <- readRDS("data/new/RUV/DIC_genes_entrezid.RDS")

dic_set <- unique(na.omit(DOX_cardiotox_genes))

#DIC genes inside each motif
in_motif1_DIC <- sum(final_genes_1_RUV %in% dic_set)
in_motif2_DIC <- sum(final_genes_2_RUV %in% dic_set)

#non-DIC genes inside each motif
in_motif1_nonDIC <- length(final_genes_1_RUV) - in_motif1_DIC
in_motif2_nonDIC <- length(final_genes_2_RUV) - in_motif2_DIC

#make contingency tables for fishers exact tests
contingency_motifs_DIC <- matrix(c(
  in_motif1_DIC, in_motif1_nonDIC,
  in_motif2_DIC, in_motif2_nonDIC),
  nrow = 2, byrow = TRUE
)

#print the contingency tables
print(contingency_motifs_DIC)

#perform a fisher's exact test (small sample size)
fisher_test_motifs_DIC <- fisher.test(contingency_motifs_DIC)
#print fisher's exact test results
print(fisher_test_motifs_DIC)

#make a summary table of all of these data to plot
motif_summary_DIC <- tibble(
  Motif = c("Motif1", "Motif2"),
  DIC = c(in_motif1_DIC, in_motif2_DIC),
  non_DIC = c(in_motif1_nonDIC, in_motif2_nonDIC)
) %>%
  pivot_longer(cols = c(DIC, non_DIC), names_to = "Category", values_to = "Count") %>%
  mutate(
    Category = ifelse(Category == "DIC", "Yes", "No"),
    Fraction = Count / ave(Count, Motif, FUN = sum),
    Significant = ifelse(Category == "Yes" & fisher_test_motifs_DIC$p.value < 0.05, "*", "")
  )

#position significance stars just above bars
label_positions_DIC <- motif_summary_DIC %>%
  filter(Category == "Yes") %>%
  mutate(y_pos = Fraction + 1.01)

#change the ordering so that yes is on the top
motif_summary_DIC$Category <- factor(motif_summary_DIC$Category, levels = c("Yes", "No"))

#plot the proportions in a barplot
ggplot(motif_summary_DIC, aes(x = Motif, y = Fraction, fill = Category)) +
  geom_bar(stat = "identity", position = "stack") +
  geom_text(
    data = label_positions_DIC %>% filter(Significant != ""),
    aes(x = Motif, y = y_pos, label = Significant),
    size = 6,
    color = "black",
    fontface = "bold"
  ) +
  scale_y_continuous(labels = scales::percent_format(scale = 1), limits = c(0, 1.08)) +
  scale_fill_manual(values = c("Yes" = "#e41a1c", "No" = "#377eb8")) +
  labs(
    title = "Proportion of DIC Genes in Motif 1 vs Motif 2 (RUVs clust + p.post)",
    x = "Cormotif Motif",
    y = "Percentage",
    fill = "DIC Gene"
  ) +
  theme_minimal() +
  theme(
    axis.title = element_text(size = 14),
    axis.text = element_text(size = 12),
    plot.title = element_text(size = 16, hjust = 0.5)
  )


#print the proportions and p values
prop_motif1_DIC <- in_motif1_DIC / length(final_genes_1_RUV)
prop_motif2_DIC <- in_motif2_DIC / length(final_genes_2_RUV)
p_val_DIC <- fisher_test_motifs_DIC$p.value

cat(sprintf("Motif1: %.2f%% DIC genes (%d/%d)\n", 100*prop_motif1_DIC, in_motif1_DIC, length(final_genes_1_RUV)))
cat(sprintf("Motif2: %.2f%% DIC genes (%d/%d)\n", 100*prop_motif2_DIC, in_motif2_DIC, length(final_genes_2_RUV)))
cat(sprintf("DIC Fisher's Exact Test p-value: %.5f\n", p_val_DIC))
cat(sprintf("Odds ratio: %.3f\n", fisher_test_motifs_DIC$estimate))


```

##p53 Targets Proportion Barplots Redo
```{r p53 Cormotif RUVs Proportion Barplots clustlike + p.post}

#read in my p53 gene set
p53_target_genes <- readRDS("data/new/RUV/p53_targetgenes_entrezid.RDS")

p53_set <- unique(na.omit(p53_target_genes))

#p53 genes inside each motif
in_motif1_p53 <- sum(final_genes_1_RUV %in% p53_set)
in_motif2_p53 <- sum(final_genes_2_RUV %in% p53_set)

#non-p53 genes inside each motif
in_motif1_nonp53 <- length(final_genes_1_RUV) - in_motif1_p53
in_motif2_nonp53 <- length(final_genes_2_RUV) - in_motif2_p53

#make contingency tables for fishers exact tests
contingency_motifs_p53 <- matrix(c(
  in_motif1_p53, in_motif1_nonp53,
  in_motif2_p53, in_motif2_nonp53),
  nrow = 2, byrow = TRUE
)

#print the contingency tables
print(contingency_motifs_p53)

#perform a fisher's exact test (small sample size)
fisher_test_motifs_p53 <- fisher.test(contingency_motifs_p53)
#print fisher's exact test results
print(fisher_test_motifs_p53)

#make a summary table of all of these data to plot
motif_summary_p53 <- tibble(
  Motif = c("Motif1", "Motif2"),
  p53 = c(in_motif1_p53, in_motif2_p53),
  non_p53 = c(in_motif1_nonp53, in_motif2_nonp53)
) %>%
  pivot_longer(cols = c(p53, non_p53), names_to = "Category", values_to = "Count") %>%
  mutate(
    Category = ifelse(Category == "p53", "Yes", "No"),
    Fraction = Count / ave(Count, Motif, FUN = sum),
    Significant = ifelse(Category == "Yes" & fisher_test_motifs_p53$p.value < 0.05, "*", "")
  )

#position significance stars just above bars
label_positions_p53 <- motif_summary_p53 %>%
  filter(Category == "Yes") %>%
  mutate(y_pos = Fraction + 1.01)

#change the ordering so that yes is on the top
motif_summary_p53$Category <- factor(motif_summary_p53$Category, levels = c("Yes", "No"))

#plot the proportions in a barplot
ggplot(motif_summary_p53, aes(x = Motif, y = Fraction, fill = Category)) +
  geom_bar(stat = "identity", position = "stack") +
  geom_text(
    data = label_positions_p53 %>% filter(Significant != ""),
    aes(x = Motif, y = y_pos, label = Significant),
    size = 6,
    color = "black",
    fontface = "bold"
  ) +
  scale_y_continuous(labels = scales::percent_format(scale = 1), limits = c(0, 1.08)) +
  scale_fill_manual(values = c("Yes" = "#e41a1c", "No" = "#377eb8")) +
  labs(
    title = "Proportion of p53 Genes in Motif 1 vs Motif 2 (RUVs clust + p.post)",
    x = "Cormotif Motif",
    y = "Percentage",
    fill = "p53 Gene"
  ) +
  theme_minimal() +
  theme(
    axis.title = element_text(size = 14),
    axis.text = element_text(size = 12),
    plot.title = element_text(size = 16, hjust = 0.5)
  )


#print the proportions and p values
prop_motif1_p53 <- in_motif1_p53 / length(final_genes_1_RUV)
prop_motif2_p53 <- in_motif2_p53 / length(final_genes_2_RUV)
p_val_p53 <- fisher_test_motifs_p53$p.value

cat(sprintf("Motif1: %.2f%% p53 genes (%d/%d)\n", 100*prop_motif1_p53, in_motif1_p53, length(final_genes_1_RUV)))
cat(sprintf("Motif2: %.2f%% p53 genes (%d/%d)\n", 100*prop_motif2_p53, in_motif2_p53, length(final_genes_2_RUV)))
cat(sprintf("p53 Fisher's Exact Test p-value: %.5f\n", p_val_p53))
cat(sprintf("Odds ratio: %.3f\n", fisher_test_motifs_p53$estimate))


```

#Flow Cytometry Barplot
```{r Flow Cytometry Data Barplot and Boxplots, fig.width=3, fig.height=3}
#Individuals for Flow Cytometry
#1 = 84-1
#2 = 87-1
#3 = 78-1
#4 = 75-1
#5 = 17-3
#6 = 90-1

flow_dxr <- read_csv("C:/Users/emmap/OneDrive/Desktop/Ward Lab/Experiments/DXR Project/Flow/Recovery_flow_purity.csv",
                     show_col_types = FALSE)
# View(flow_dxr)

flow <- flow_dxr %>% column_to_rownames("Line")

####now that I've loaded in the lenient gating number for each, let's make a boxplot

flow_dxr %>% ggplot(aes(x=Individual, y=Purity, color = Line)) +
  geom_boxplot() +
  theme_bw(base_size = 16) + 
  labs(title = "Percent TNNT2 Positive iPSC-CMs") +
  ylim(0,105) +
  scale_color_manual(values = ind_col)
  

##make subsets based on species
flow_dxr %>% ggplot(aes(x=Individual, y=Purity, color = Individual)) +
  geom_boxplot() +
  theme_bw(base_size = 15) + 
  labs(title = "Percent TNNT2 Positive iPSC-CMs") +
  ylim(0,105) +
  scale_color_manual(values = ind_col)

leg_show <- c(size = FALSE, color = TRUE, alpha = FALSE)

  
ggplot(flow_dxr, aes(x = Individual, y = Purity))+
  geom_boxplot(aes(fill = Individual), show.legend = FALSE)+
  geom_point(aes(color = Individual, size = 5, alpha = 0.9), show.legend = leg_show) +
  ylim(0,105) +
  labs(title = "Percent TNNT2 Positive iPSC-CMs")+
  theme_bw(base_size = 16)+
  scale_color_manual(values = c("#003F5C", 
                                "#45AE91", 
                                "#58209D", 
                                "#8B3E9B", 
                                "#FF6361", 
                                "#BC4169", 
                                "#FF2362"))

###make a barplot as well
####put a line where the average is - 91.34

flow_dxr_df <- as.data.frame(flow_dxr)

# Compute mean value
avg_vals_dxr <- mean(flow_dxr_df$Purity)

# Plot
ggplot(flow_dxr_df, aes(x = Individual, y = Purity)) +
  geom_bar(stat = "identity", 
           fill = ind_col_norep,
           width = 0.9) +
  geom_hline(yintercept = avg_vals_dxr, 
             linetype = "dashed", 
             color = "black", 
             linewidth = 0.7) +
  # annotate("text", x = 5, 
  #          y = avg_vals_dxr + 2, 
  #          label = paste0(round(avg_vals_dxr, 1), "%"),
  #          color = "black", 
  #          hjust = 3.9) +
  scale_y_continuous(limits = c(0, 100), 
                     expand = c(0, 0)) +
  scale_x_discrete(expand = expansion(mult = c(0.02, 0.02)))+
  labs(title = "iPSC-CM Purity",
       y = "TNNT2 Expression (%)", 
       x = "Individual") +
  theme_minimal(base_size = 14)

```

