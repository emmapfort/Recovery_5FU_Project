---
title: "DXR DE Analysis"
author: "Emma M Pfortmiller"
date: "2025-05-14"
site: workflowr::wflow_site
output:
  workflowr::wflow_html:
    toc: true
    toc_depth: 2
    toc_float: true
    theme: journal
editor_options: 
  chunk_output_type: inline
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{css, echo=FALSE}
pre {
  max-height: 400px;
  overflow-y: auto;
}

pre[class] {
  max-height: 200px;
  
}
```

I did this part with Sayan according to his analysis to ensure that my matrix was consistent with his - allowing me to work on downstream analysis

```{r Necessary Libraries, message=FALSE, warning=FALSE, include=FALSE}
library(tidyverse)
library(Biobase)
library(limma)
library(edgeR)
library(edgebundleR)
library(scales)
library(biomaRt)
library(ggrepel)
library(ggfortify)
library(corrplot)
library(readr)
library(org.Hs.eg.db)
library(AnnotationDbi)
library(ComplexHeatmap)
library(circlize)
library(grid)
library(reshape2)
library(ggVennDiagram)
library(UpSetR)
library(ggpubr)
library(VennDiagram)
library(VennDetail)
library(BiocParallel)
library(RUVSeq)
library(SummarizedExperiment)
```



```{r Create My Dataframe With All Counts Files}
#load in libraries needed
#these counts files are from featureCounts, all saved as RDS objects

# ####Individual 1 - 84-1####
# Counts_84_DOX_24 <- readRDS("data/counts/Counts_84_DOX_24.RDS")
# Counts_84_DMSO_24 <- readRDS("data/counts/Counts_84_DMSO_24.RDS")
# Counts_84_DOX_24rec <- readRDS("data/counts/Counts_84_DOX_24rec.RDS")
# Counts_84_DMSO_24rec <- readRDS("data/counts/Counts_84_DMSO_24rec.RDS")
# Counts_84_DOX_144rec <- readRDS("data/counts/Counts_84_DOX_144rec.RDS")
# Counts_84_DMSO_144rec <- readRDS("data/counts/Counts_84_DMSO_144rec.RDS")
# 
# ####Individual 2 - 87-1####
# Counts_87_DOX_24 <- readRDS("data/counts/Counts_87_DOX_24.RDS")
# Counts_87_DMSO_24 <- readRDS("data/counts/Counts_87_DMSO_24.RDS")
# Counts_87_DOX_24rec <- readRDS("data/counts/Counts_87_DOX_24rec.RDS")
# Counts_87_DMSO_24rec <- readRDS("data/counts/Counts_87_DMSO_24rec.RDS")
# Counts_87_DOX_144rec <- readRDS("data/counts/Counts_87_DOX_144rec.RDS")
# Counts_87_DMSO_144rec <- readRDS("data/counts/Counts_87_DMSO_144rec.RDS")
# 
# ####Individual 3 - 78-1####
# Counts_78_DOX_24 <- readRDS("data/counts/Counts_78_DOX_24.RDS")
# Counts_78_DMSO_24 <- readRDS("data/counts/Counts_78_DMSO_24.RDS")
# Counts_78_DOX_24rec <- readRDS("data/counts/Counts_78_DOX_24rec.RDS")
# Counts_78_DMSO_24rec <- readRDS("data/counts/Counts_78_DMSO_24rec.RDS")
# Counts_78_DOX_144rec <- readRDS("data/counts/Counts_78_DOX_144rec.RDS")
# Counts_78_DMSO_144rec <- readRDS("data/counts/Counts_78_DMSO_144rec.RDS")
# 
# ####Individual 4 - 75-1####
# Counts_75_DOX_24 <- readRDS("data/counts/Counts_75_DOX_24.RDS")
# Counts_75_DMSO_24 <- readRDS("data/counts/Counts_75_DMSO_24.RDS")
# Counts_75_DOX_24rec <- readRDS("data/counts/Counts_75_DOX_24rec.RDS")
# Counts_75_DMSO_24rec <- readRDS("data/counts/Counts_75_DMSO_24rec.RDS")
# Counts_75_DOX_144rec <- readRDS("data/counts/Counts_75_DOX_144rec.RDS")
# Counts_75_DMSO_144rec <- readRDS("data/counts/Counts_75_DMSO_144rec.RDS")
# 
# ####Individual 5 - 17-3####
# Counts_17_DOX_24 <- readRDS("data/counts/Counts_17_DOX_24.RDS")
# Counts_17_DMSO_24 <- readRDS("data/counts/Counts_17_DMSO_24.RDS")
# Counts_17_DOX_24rec <- readRDS("data/counts/Counts_17_DOX_24rec.RDS")
# Counts_17_DMSO_24rec <- readRDS("data/counts/Counts_17_DMSO_24rec.RDS")
# Counts_17_DOX_144rec <- readRDS("data/counts/Counts_17_DOX_144rec.RDS")
# Counts_17_DMSO_144rec <- readRDS("data/counts/Counts_17_DMSO_144rec.RDS")
# 
# ####Individual 6 - 90-1####
# Counts_90_DOX_24 <- readRDS("data/counts/Counts_90_DOX_24.RDS")
# Counts_90_DMSO_24 <- readRDS("data/counts/Counts_90_DMSO_24.RDS")
# Counts_90_DOX_24rec <- readRDS("data/counts/Counts_90_DOX_24rec.RDS")
# Counts_90_DMSO_24rec <- readRDS("data/counts/Counts_90_DMSO_24rec.RDS")
# Counts_90_DOX_144rec <- readRDS("data/counts/Counts_90_DOX_144rec.RDS")
# Counts_90_DMSO_144rec <- readRDS("data/counts/Counts_90_DMSO_144rec.RDS")
# 
# ####Individual 7 - 90-1REP####
# Counts_90REP_DOX_24 <- readRDS("data/counts/Counts_90REP_DOX_24.RDS")
# Counts_90REP_DMSO_24 <- readRDS("data/counts/Counts_90REP_DMSO_24.RDS")
# Counts_90REP_DOX_24rec <- readRDS("data/counts/Counts_90REP_DOX_24rec.RDS")
# Counts_90REP_DMSO_24rec <- readRDS("data/counts/Counts_90REP_DMSO_24rec.RDS")
# Counts_90REP_DOX_144rec <- readRDS("data/counts/Counts_90REP_DOX_144rec.RDS")
# Counts_90REP_DMSO_144rec <- readRDS("data/counts/Counts_90REP_DMSO_144rec.RDS")

```

```{r Put Counts Together Into Dataframe}
# counts_raw_df <-
#    data.frame(
#      Counts_84_DOX_24,
#      Counts_84_DMSO_24$MCW_EMP_JT_R29_R1.bam,
#      Counts_84_DOX_24rec$MCW_EMP_JT_R30_R1.bam,
#      Counts_84_DMSO_24rec$MCW_EMP_JT_R32_R1.bam,
#      Counts_84_DOX_144rec$MCW_EMP_JT_R33_R1.bam,
#      Counts_84_DMSO_144rec$MCW_EMP_JT_R35_R1.bam,
#      Counts_87_DOX_24$MCW_EMP_JT_R36_R1.bam,
#      Counts_87_DMSO_24$MCW_EMP_JT_R38_R1.bam,
#      Counts_87_DOX_24rec$MCW_EMP_JT_R39_R1.bam,
#      Counts_87_DMSO_24rec$MCW_EMP_JT_R41_R1.bam,
#      Counts_87_DOX_144rec$MCW_EMP_JT_R42_R1.bam,
#      Counts_87_DMSO_144rec$MCW_EMP_JT_R44_R1.bam,
#      Counts_78_DOX_24$MCW_EMP_JT_R45_R1.bam,
#      Counts_78_DMSO_24$MCW_EMP_JT_R47_R1.bam,
#      Counts_78_DOX_24rec$MCW_EMP_JT_R48_R1.bam,
#      Counts_78_DMSO_24rec$MCW_EMP_JT_R50_R1.bam,
#      Counts_78_DOX_144rec$MCW_EMP_JT_R51_R1.bam,
#      Counts_78_DMSO_144rec$MCW_EMP_JT_R53_R1.bam,
#      Counts_75_DOX_24$MCW_EMP_JT_R54_R1.bam,
#      Counts_75_DMSO_24$MCW_EMP_JT_R56_R1.bam,
#      Counts_75_DOX_24rec$MCW_EMP_JT_R57_R1.bam,
#      Counts_75_DMSO_24rec$MCW_EMP_JT_R59_R1.bam,
#      Counts_75_DOX_144rec$MCW_EMP_JT_R60_R1.bam,
#      Counts_75_DMSO_144rec$MCW_EMP_JT_R62_R1.bam,
#      Counts_17_DOX_24$MCW_EMP_JT_R63_R1.bam,
#      Counts_17_DMSO_24$MCW_EMP_JT_R65_R1.bam,
#      Counts_17_DOX_24rec$MCW_EMP_JT_R66_R1.bam,
#      Counts_17_DMSO_24rec$MCW_EMP_JT_R68_R1.bam,
#      Counts_17_DOX_144rec$MCW_EMP_JT_R69_R1.bam,
#      Counts_17_DMSO_144rec$MCW_EMP_JT_R71_R1.bam,
#      Counts_90_DOX_24$MCW_EMP_JT_R72_R1.bam,
#      Counts_90_DMSO_24$MCW_EMP_JT_R74_R1.bam,
#      Counts_90_DOX_24rec$MCW_EMP_JT_R75_R1.bam,
#      Counts_90_DMSO_24rec$MCW_EMP_JT_R77_R1.bam,
#      Counts_90_DOX_144rec$MCW_EMP_JT_R78_R1.bam,
#      Counts_90_DMSO_144rec$MCW_EMP_JT_R80_R1.bam,
#      Counts_90REP_DOX_24$MCW_EMP_JT_R81_R1.bam,
#      Counts_90REP_DMSO_24$MCW_EMP_JT_R83_R1.bam,
#      Counts_90REP_DOX_24rec$MCW_EMP_JT_R84_R1.bam,
#      Counts_90REP_DMSO_24rec$MCW_EMP_JT_R86_R1.bam,
#      Counts_90REP_DOX_144rec$MCW_EMP_JT_R87_R1.bam,
#      Counts_90REP_DMSO_144rec$MCW_EMP_JT_R89_R1.bam
#    )

#now save this as a matrix
#counts_raw_matrix <- counts_raw_df %>% column_to_rownames(var = "X") %>% as.matrix()

counts_raw_matrix <- readRDS("data/new/counts_raw_matrix.RDS")

dim(counts_raw_matrix)
#28395 is my initial amount of genes prior to filtering

#write this to a csv so I can save it for later
#write.csv(counts_raw_matrix, "C:/Users/emmap/RDirectory/Recovery_RNAseq/Recovery_5FU/data/new/counts_raw_matrix_EMP_250514.csv")

#I also want to save this as an R object so I don't have to run the counts every time
#saveRDS(counts_raw_matrix, "data/new/counts_raw_matrix.RDS")

```

```{r Colors + Factors}
#I want to include the color schemes I have for my treatment, individuals, and timepoints
####Colors####
tx_col <- c("DOX" = "#499FBD", "DMSO" = "#BBBBBC")
col_tx_large <- rep(c("#499FBD" , "#BBBBBC"), 21)
col_tx_large_2 <- c(rep("#499FBD" , 3), rep("#BBBBBC", 3), 21)

ind_col <- c("#003F5C", "#45AE91",  "#58209D", "#8B3E9B", "#FF6361", "#BC4169", "#FF2362")

ind_col_norep <- c("#003F5C", "#45AE91",  "#58209D", "#8B3E9B", "#FF6361", "#BC4169")

time_col <- c("#238B45", "#74C476", "#C7E9C0")

cond_col <- c("#003F5C", "#45AE91",  "#58209D", "#8B3E9B", "#FF6361", "#BC4169")

```


```{r QC Mapping Plots}
#this dataframe contains my alignment percentages from featureCounts
##already filtered to only include DOX + DMSO samples
fC_DOXCounts <- readRDS("data/fC_DOXCounts.RDS")

#Now I want to plot these values out

####Reads by Sample####
reads_by_sample <- c("DOX" = "#499FBD", "DMSO" = "#BBBBBC")
fC_DOXCounts %>% 
  ggplot(., aes (x = Conditions, y = Total_Align, fill = Treatment, group_by = Line))+
  geom_col()+
 geom_hline(aes(yintercept=20000000))+
 scale_fill_manual(values=reads_by_sample)+
  ggtitle(expression("Total number of reads by sample"))+
  xlab("")+
  ylab(expression("RNA-sequencing reads"))+
  theme_bw()+
  theme(plot.title = element_text(size = rel(2), hjust = 0.5),
        axis.title = element_text(size = 15, color = "black"),
        axis.ticks = element_line(linewidth = 1.5),
        axis.text.y = element_text(size =10, color = "black", angle = 0, hjust = 0.8, vjust = 0.5),
        axis.text.x = element_text(size =10, color = "black", angle = 90, hjust = 1, vjust = 0.2),
        #strip.text.x = element_text(size = 15, color = "black", face = "bold"),
        strip.text.y = element_text(color = "white"))


####Read Counts by Treatment####
fC_DOXCounts %>% 
  ggplot(., aes (x =Treatment, y= Total_Align, fill = Treatment))+
  geom_boxplot()+
 scale_fill_manual(values=reads_by_sample)+
  ggtitle(expression("Total number of reads by treatment"))+
  xlab("")+
  ylab(expression("RNA-sequencing reads"))+
  theme_bw()+
  
  theme(plot.title = element_text(size = rel(2), hjust = 0.5),
        axis.title = element_text(size = 15, color = "black"),
        axis.ticks = element_line(linewidth = 1.5),
        axis.text.y = element_text(size =10, color = "black", angle = 0, hjust = 0.8, vjust = 0.5),
        axis.text.x = element_text(size =10, color = "black", angle = 90, hjust = 1, vjust = 0.2),
        #strip.text.x = element_text(size = 15, color = "black", face = "bold"),
        strip.text.y = element_text(color = "white"))

####Total Reads Per Individual####
fC_DOXCounts %>% 
  ggplot(., aes (x =as.factor(Line), y=Total_Align))+
  geom_boxplot(aes(fill=as.factor(Line)))+
 scale_fill_brewer(palette = "Dark2", name = "Individual")+
  ggtitle(expression("Total number of reads by individual"))+
  xlab("")+
  ylab(expression("RNA-sequencing reads"))+
  theme_bw()+

  theme(plot.title = element_text(size = rel(2), hjust = 0.5),
        axis.title = element_text(size = 15, color = "black"),
        axis.ticks = element_line(linewidth = 1.5),
        axis.text.y = element_text(size =10, color = "black", angle = 0, hjust = 0.8, vjust = 0.5),
        axis.text.x = element_text(size =10, color = "black", angle = 0, hjust = 1),
        #strip.text.x = element_text(size = 15, color = "black", face = "bold"),
        strip.text.y = element_text(color = "white"))

####Total Mapped Reads Per Drug####

reads_by_sample <- c("DOX" = "#499FBD", "DMSO" = "#BBBBBC")
fC_DOXCounts %>% 
  ggplot(., aes (x = Conditions, y = Assigned_Align, fill = Treatment, group_by = Line))+
  geom_col()+
 geom_hline(aes(yintercept=20000000))+
 scale_fill_manual(values=reads_by_sample)+
  ggtitle(expression("Total number of mapped reads by sample"))+
  xlab("")+
  ylab(expression("RNA-sequencing reads"))+
  theme_bw()+
  theme(plot.title = element_text(size = rel(2), hjust = 0.5),
        axis.title = element_text(size = 15, color = "black"),
        axis.ticks = element_line(linewidth = 1.5),
        axis.text.y = element_text(size =10, color = "black", angle = 0, hjust = 0.8, vjust = 0.5),
        axis.text.x = element_text(size =10, color = "black", angle = 90, hjust = 1, vjust = 0.2),
        #strip.text.x = element_text(size = 15, color = "black", face = "bold"),
        strip.text.y = element_text(color = "white"))


####Read Counts by Treatment####
fC_DOXCounts %>% 
  ggplot(., aes (x =Treatment, y= Assigned_Align, fill = Treatment))+
  geom_boxplot()+
 scale_fill_manual(values=reads_by_sample)+
  ggtitle(expression("Total number of mapped reads by treatment"))+
  xlab("")+
  ylab(expression("RNA-sequencing reads"))+
  theme_bw()+
  
  theme(plot.title = element_text(size = rel(2), hjust = 0.5),
        axis.title = element_text(size = 15, color = "black"),
        axis.ticks = element_line(linewidth = 1.5),
        axis.text.y = element_text(size =10, color = "black", angle = 0, hjust = 0.8, vjust = 0.5),
        axis.text.x = element_text(size =10, color = "black", angle = 90, hjust = 1, vjust = 0.2),
        #strip.text.x = element_text(size = 15, color = "black", face = "bold"),
        strip.text.y = element_text(color = "white"))

####Total Reads Per Individual####
fC_DOXCounts %>% 
  ggplot(., aes (x =as.factor(Line), y=Assigned_Align))+
  geom_boxplot(aes(fill=as.factor(Line)))+
 scale_fill_brewer(palette = "Dark2", name = "Individual")+
  ggtitle(expression("Total number of mapped reads by individual"))+
  xlab("")+
  ylab(expression("RNA-sequencing reads"))+
  theme_bw()+

  theme(plot.title = element_text(size = rel(2), hjust = 0.5),
        axis.title = element_text(size = 15, color = "black"),
        axis.ticks = element_line(linewidth = 1.5),
        axis.text.y = element_text(size =10, color = "black", angle = 0, hjust = 0.8, vjust = 0.5),
        axis.text.x = element_text(size =10, color = "black", angle = 0, hjust = 1),
        #strip.text.x = element_text(size = 15, color = "black", face = "bold"),
        strip.text.y = element_text(color = "white"))

```

Now, I want to filter my dataframe
Before I can filter by rowMeans, I must convert to log2cpm

```{r Dataframe Filtering}
#transform counts to cpm as a first step
counts_cpm_unfilt <- cpm(counts_raw_matrix, log = TRUE)
dim(counts_cpm_unfilt)
#I should have 28395 genes here since this is unfiltered

hist(counts_cpm_unfilt,  
     main = "Histogram of Unfiltered Counts", 
     xlab = expression("Log"[2]*" counts-per-million"), 
     col = 4)

###filter my data by rowMeans > 0 to exclude lowly expressed genes

filcpm_matrix <- subset(counts_cpm_unfilt, (rowMeans(counts_cpm_unfilt) > 0))
dim(filcpm_matrix)
#I should have 14319 genes here

#now let's make a histogram of this to check the difference
hist(filcpm_matrix,  
     main = "Histogram of Filtered Counts by rowMeans > 0", 
     xlab = expression("Log"[2]*" counts-per-million"), 
     col = 2)

#change the column names to match my samples - make sure that they are in the right order
#Individual 1 = 84-1 (M)
#Individual 2 = 87-1 (F)
#Individual 3 = 78-1 (F)
#Individual 4 = 75-1 (F)
#Individual 5 = 17-3 (M)
#Individual 6 = 90-1 (M)
#Individual 6REP = 90-1REP (M)

#Treatment/time should follow this order:
#DOX24tx
#DMSO24tx
#DOX24rec
#DMSO24rec
#DOX144rec
#DMSO144rec

colnames(filcpm_matrix) <- c("DOX_24T_Ind1",
                                "DMSO_24T_Ind1",
                                "DOX_24R_Ind1",
                                "DMSO_24R_Ind1",
                                "DOX_144R_Ind1",
                                "DMSO_144R_Ind1",
                                "DOX_24T_Ind2",
                                "DMSO_24T_Ind2",
                                "DOX_24R_Ind2",
                                "DMSO_24R_Ind2",
                                "DOX_144R_Ind2",
                                "DMSO_144R_Ind2",
                                "DOX_24T_Ind3",
                                "DMSO_24T_Ind3",
                                "DOX_24R_Ind3",
                                "DMSO_24R_Ind3",
                                "DOX_144R_Ind3",
                                "DMSO_144R_Ind3",
                                "DOX_24T_Ind4",
                                "DMSO_24T_Ind4",
                                "DOX_24R_Ind4",
                                "DMSO_24R_Ind4",
                                "DOX_144R_Ind4",
                                "DMSO_144R_Ind4",
                                "DOX_24T_Ind5",
                                "DMSO_24T_Ind5",
                                "DOX_24R_Ind5",
                                "DMSO_24R_Ind5",
                                "DOX_144R_Ind5",
                                "DMSO_144R_Ind5",
                                "DOX_24T_Ind6",
                                "DMSO_24T_Ind6",
                                "DOX_24R_Ind6",
                                "DMSO_24R_Ind6",
                                "DOX_144R_Ind6",
                                "DMSO_144R_Ind6",
                                "DOX_24T_Ind6REP",
                                "DMSO_24T_Ind6REP",
                                "DOX_24R_Ind6REP",
                                "DMSO_24R_Ind6REP",
                                "DOX_144R_Ind6REP",
                                "DMSO_144R_Ind6REP")

#export this as a csv
#write.csv(filcpm_matrix, "data/new/filcpm_final_matrix.csv")

```

```{r QC Filtering Boxplots}
#make boxplots of all counts vs log2cpm filtered counts

#set the margins so the x axis isn't cut off
##I don't mind if this one is partially cut off since all you need is the library number and not the whole name
par(mar = c(8,4,2,2))
#boxplot of unfiltered cpm matrix
boxplot(counts_cpm_unfilt, 
        main = "Boxplots of Unfiltered log2cpm", 
        names = colnames(counts_cpm_unfilt), 
        adj=1, las = 2, cex.axis = 0.7)

#set the margins so the x axis isn't cut off
par(mar = c(8,4,2,2))
#boxplot of filtered cpm matrix
boxplot(filcpm_matrix, 
        main = "Boxplots of Filtered log2cpm (rowMeans > 0)", 
        names = colnames(filcpm_matrix), 
        adj=1, las = 2, cex.axis = 0.7)

```

After making my final matrix, I pulled the gene symbols from the entrez IDs I had as my rownames
I ran this initially and then moved the column into my final matrix
My final matrix is called filcpm_final_matrix.csv saved under data

```{r Put Together My Data for Filtered Gene List}
##I did this earlier so don't run again, I put the list into the filcpm_final_matrix.csv
# # ----------------- Load Required Libraries -----------------
# library(dplyr)
# library(readr)
# library(org.Hs.eg.db)
# library(AnnotationDbi)
# # ----------------- Load Data -----------------
# sample_data <- read_csv("data/filcpm_final_matrix.csv", show_col_types = FALSE)
# # ----------------- Ensure Entrez_ID is Present and in Character Format -----------------
# # Check column names
# print(colnames(sample_data))
# # Rename if needed (adjust if the column name is not exactly 'Entrez_ID')
# # sample_data <- sample_data %>% rename(Entrez_ID = `actual_column_name`)
# # Convert Entrez_ID to character
# sample_data <- sample_data %>%
#   mutate(Entrez_ID = as.character(Entrez_ID))
# # ----------------- Map Entrez_ID to Gene Symbol -----------------
# gene_symbols <- AnnotationDbi::select(
#   org.Hs.eg.db,
#   keys = sample_data$Entrez_ID,
#   columns = c("SYMBOL"),
#   keytype = "ENTREZID"
# )
# # ----------------- Join Back to Main Data -----------------
# sample_annotated <- left_join(sample_data, gene_symbols, by = c("Entrez_ID" = "ENTREZID"))
# # ----------------- Save Annotated Output -----------------
# #write_csv(sample_annotated, "data/Sample_annotated.csv")

#Since I ran this before, Sample_annotated.csv columns of EntrezID and Symbol have been copied into my final matrix - so disregard this file except for record-keeping
```

Now that I have my final matrix, I would like to check some key genes
I want to make sure that these genes are responding as we expect
We have triple checked this dataset to ensure that columns are in order

```{r Check Response Genes log2cpm}
#Load in my count matrix
boxplot1 <- read.csv("data/new/filcpm_final_matrix.csv") %>% 
  as.data.frame()

#save boxplot1 as an object filcpm_matrix_genes
#saveRDS(boxplot1, "data/new/filcpm_matrix_genes.RDS")

#Define gene list(s)
initial_test_genes <- c("CDKN1A", "MDM2", "BAX", "RARG", "TP53", "TOP2B", "TOP2A")  
#Add more gene symbols as needed or add more categories

#Now put in the function I want to use to generate boxplots of genes
process_gene_data <- function(gene) {
  gene_data <- boxplot1 %>% filter(SYMBOL == gene)
  long_data <- gene_data %>%
    pivot_longer(cols = -c(Entrez_ID, SYMBOL), names_to = "Sample", values_to = "log2CPM") %>%
    mutate(
      Drug = case_when(
        grepl("DOX", Sample) ~ "DOX",
        grepl("DMSO", Sample) ~ "DMSO",
        TRUE ~ NA_character_
      ),
      Timepoint = case_when(
        grepl("_24T_", Sample) ~ "24T",
        grepl("_24R_", Sample) ~ "24R",
        grepl("_144R_", Sample) ~ "144R",
        TRUE ~ NA_character_
      ),
      Indv = case_when(
        grepl("Ind1$", Sample) ~ "1",
        grepl("Ind2$", Sample) ~ "2",
        grepl("Ind3$", Sample) ~ "3",
        grepl("Ind4$", Sample) ~ "4",
        grepl("Ind5$", Sample) ~ "5",
        grepl("Ind6$", Sample) ~ "6",
        grepl("Ind6REP$", Sample) ~ "6R",
        TRUE ~ NA_character_
      ),
      Condition = paste(Drug, Timepoint, sep = "_")
    )
  long_data$Condition <- factor(
    long_data$Condition,
    levels = c(
      "DOX_24T", 
      "DMSO_24T", 
      "DOX_24R", 
      "DMSO_24R", 
      "DOX_144R", 
      "DMSO_144R"
    )
  )
  return(long_data)
}

#this function is saved under process_gene_data so I will save as an R object

#saveRDS(process_gene_data, "data/new/process_gene_data_funct.RDS")

#Generate Boxplots from the above function using our gene list above
for (gene in initial_test_genes) {
  gene_data <- process_gene_data(gene)
  p <- ggplot(gene_data, aes(x = Condition, y = log2CPM, fill = Drug)) +
    geom_boxplot(outlier.shape = NA) +
    geom_point(aes(color = Indv), size = 2, alpha = 0.5, position = position_jitter(width = -1, height = 0)) +
    scale_fill_manual(values = c("DOX" = "#499FBD", "DMSO" = "#BBBBBC")) +
    ggtitle(paste("Log2CPM Expression of", gene)) +
    labs(x = "Treatment", y = "log2CPM") +
    theme_bw() +
    theme(
      plot.title = element_text(size = rel(2), hjust = 0.5),
      axis.title = element_text(size = 15, color = "black"),
      axis.text.x = element_text(size = 10, color = "black", angle = 90, hjust = 1)
    )
  print(p)
}

```

Now I've confirmed with some boxplots that my genes are present and (mostly) behaving as they should
- Sayan's CDKN1A and MDM2 are initially high at 24hr in DOX 0.5
- My CDKN1A and MDM2 are similar to DMSO at 24hr DOX 0.5
  - These genes increase at DOX24R
  - These genes are also high at DOX144R but not as high as 24R
However, TP53 and BAX are acting similarly across our data

```{r PCA Analysis}
#Now I want to check if my data is as expected on a PCA plot
#perform PCA calculations
prcomp_res_unfilt <- prcomp(t(counts_cpm_unfilt %>% as.matrix()), center =  TRUE)

prcomp_res_filt <- prcomp(t(filcpm_matrix %>% as.matrix()), center =  TRUE)

#read in my metadata annotations
Metadata <- read.csv("data/new/Metadata.csv")

#add in labels for individual numbers
ind_num <- c("1", "1", "1", "1", "1", "1", 
             "2", "2", "2", "2", "2", "2", 
             "3", "3", "3", "3", "3", "3", 
             "4", "4", "4", "4", "4", "4", 
             "5", "5", "5", "5", "5", "5", 
             "6", "6", "6", "6", "6", "6", 
             "6R", "6R", "6R", "6R", "6R", "6R")

# saveRDS(ind_num, "data/new/ind_num.RDS")

#now plot my PCA for unfiltered log2cpm
####PC1/PC2####
ggplot2::autoplot(prcomp_res_unfilt, data = Metadata, colour = "Condition", shape = "Time", size =4, x=1, y=2) +
  ggrepel::geom_text_repel(label=ind_num, vjust = -.5, max.overlaps = 30) +
  scale_color_manual(values=cond_col) +
  ggtitle(expression("PCA of Unfiltered log"[2]*"cpm")) +
  theme_bw()

####PC2/PC3####
ggplot2::autoplot(prcomp_res_unfilt, data = Metadata, colour = "Condition", shape = "Time", size =4, x=2, y=3) +
  ggrepel::geom_text_repel(label=ind_num, vjust = -.5, max.overlaps = 30) +
  scale_color_manual(values=cond_col) +
  ggtitle(expression("PCA of Unfiltered log"[2]*"cpm")) +
  theme_bw()

####PC3/PC4####
ggplot2::autoplot(prcomp_res_unfilt, data = Metadata, colour = "Condition", shape = "Time", size =4, x=3, y=4) +
  ggrepel::geom_text_repel(label=ind_num, vjust = -.5, max.overlaps = 30) +
  scale_color_manual(values=cond_col) +
  ggtitle(expression("PCA of Unfiltered log"[2]*"cpm")) +
  theme_bw()


#Now plot my PCA for filtered log2cpm
####PC1/PC2####
ggplot2::autoplot(prcomp_res_filt, data = Metadata, colour = "Condition", shape = "Time", size =4, x=1, y=2) +
  ggrepel::geom_text_repel(label=ind_num, vjust = -.5, max.overlaps = 30) +
  scale_color_manual(values=cond_col) +
  ggtitle(expression("PCA of Filtered log"[2]*"cpm")) +
  theme_bw()


ggplot2::autoplot(prcomp_res_filt, data = Metadata, colour = "Condition", shape = "Time", size =4, x=1, y=2) +
  ggrepel::geom_text_repel(label=ind_num, vjust = -.5, max.overlaps = 30) +
  scale_color_manual(values=cond_col) +
  ggtitle(expression("PCA of Filtered log"[2]*"cpm")) +
  theme_bw()


####PC2/PC3####
ggplot2::autoplot(prcomp_res_filt, data = Metadata, colour = "Condition", shape = "Time", size =4, x=2, y=3) +
  ggrepel::geom_text_repel(label=ind_num, vjust = -.5, max.overlaps = 30) +
  scale_color_manual(values=cond_col) +
  ggtitle(expression("PCA of Filtered log"[2]*"cpm")) +
  theme_bw()

####PC3/PC4####
ggplot2::autoplot(prcomp_res_filt, data = Metadata, colour = "Condition", shape = "Time", size =4, x=3, y=4) +
  ggrepel::geom_text_repel(label=ind_num, vjust = -.5, max.overlaps = 30) +
  scale_color_manual(values=cond_col) +
  ggtitle(expression("PCA of Filtered log"[2]*"cpm")) +
  theme_bw()
```

```{r Correlation Heatmaps, fig.width=12, fig.height=10}

#check to make sure that the column names are correct
lcpm_2 <- filcpm_matrix
colnames(lcpm_2) <- Metadata$Final_sample_name

#compute the correlation matrices, one pearson and one spearman
cor_matrix_pearson <- cor(lcpm_2, 
                          y = NULL, 
                          use = "everything",  
                          method = "pearson")
cor_matrix_spearman <- cor(lcpm_2,
                           y = NULL,
                           use = "everything",
                           method = "spearman")

# Extract metadata columns
Individual <- as.character(Metadata$Ind)
Time <- as.character(Metadata$Time)
Treatment <- as.character(Metadata$Drug)

# Define color palettes for annotations
annot_col_cor = list(drugs = c("DOX" = "#499FBD", 
                               "DMSO" = "#BBBBBC"),
                     individuals = c("1" = "#003F5C", 
                                     "2" = "#45AE91", 
                                     "3" = "#58209D", 
                                     "4" = "#8B3E9B", 
                                     "5" = "#FF6361", 
                                     "6" = "#BC4169", 
                                     "6R" = "#FF2362"),
                     timepoints = c("24T" = "#238B45",
                                    "24R" = "#74C476", 
                                    "144R" = "#C7E9C0"))

drug_colors <- c("DOX" = "#499FBD", 
                 "DMSO" = "#BBBBBC")
ind_colors <- c("1" = "red",
                "2" = "orange",
                "3" = "yellow",
                "4" = "green",
                "5" = "blue",
                "6" = "violet",
                "6R" = "purple")
time_colors <- c("24T" = "#238B45",
                 "24R" = "#74C476",
                 "144R" = "#C7E9C0")

# Create annotations
top_annotation <- HeatmapAnnotation(
  Individual = Individual, 
  Time = Time,
  Treatment = Treatment,
  col = list(
    Individual = ind_colors, 
    Time = time_colors,
    Treatment = drug_colors
  )
)

####ANNOTATED HEATMAPS####
# pheatmap(cor_matrix_pearson, border_color = "black", legend = TRUE, angle_col = 90, display_numbers = FALSE, number_color = "black", fontsize = 10, fontsize_number = 5, annotation_col = top_annotation, annotation_colors = annot_col)

####Pearson Heatmap####
heatmap_pearson <- Heatmap(cor_matrix_pearson,
                           name = "Pearson",
                           top_annotation = top_annotation,
                           show_row_names = TRUE,
                           show_column_names = TRUE,
                           cluster_rows = TRUE,
                           cluster_columns = TRUE,
                           border = TRUE)

# Draw the heatmap
draw(heatmap_pearson)

####Spearman Heatmap####
heatmap_spearman <- Heatmap(cor_matrix_spearman,
                           name = "Spearman",
                           top_annotation = top_annotation,
                           show_row_names = TRUE,
                           show_column_names = TRUE,
                           cluster_rows = TRUE,
                           cluster_columns = TRUE,
                           border = TRUE)

# Draw the heatmap
draw(heatmap_spearman)

```

```{r Make Filtered Gene List}
#Now I want to make a filtered gene list (my rownames)
##I will use this to filter my counts for limma + Cormotif

filt_gene_list <- rownames(filcpm_matrix)
#save this filtered gene list as I'll use it to filter my counts
#saveRDS(filt_gene_list, "data/new/filt_gene_list.RDS")

```

```{r Filter Counts for DE}
counts_raw_matrix <- readRDS("data/new/counts_raw_matrix.RDS")
#change column names to match samples for my raw counts matrix
colnames(counts_raw_matrix) <- c("DOX_24T_Ind1",
                                "DMSO_24T_Ind1",
                                "DOX_24R_Ind1",
                                "DMSO_24R_Ind1",
                                "DOX_144R_Ind1",
                                "DMSO_144R_Ind1",
                                "DOX_24T_Ind2",
                                "DMSO_24T_Ind2",
                                "DOX_24R_Ind2",
                                "DMSO_24R_Ind2",
                                "DOX_144R_Ind2",
                                "DMSO_144R_Ind2",
                                "DOX_24T_Ind3",
                                "DMSO_24T_Ind3",
                                "DOX_24R_Ind3",
                                "DMSO_24R_Ind3",
                                "DOX_144R_Ind3",
                                "DMSO_144R_Ind3",
                                "DOX_24T_Ind4",
                                "DMSO_24T_Ind4",
                                "DOX_24R_Ind4",
                                "DMSO_24R_Ind4",
                                "DOX_144R_Ind4",
                                "DMSO_144R_Ind4",
                                "DOX_24T_Ind5",
                                "DMSO_24T_Ind5",
                                "DOX_24R_Ind5",
                                "DMSO_24R_Ind5",
                                "DOX_144R_Ind5",
                                "DMSO_144R_Ind5",
                                "DOX_24T_Ind6",
                                "DMSO_24T_Ind6",
                                "DOX_24R_Ind6",
                                "DMSO_24R_Ind6",
                                "DOX_144R_Ind6",
                                "DMSO_144R_Ind6",
                                "DOX_24T_Ind6REP",
                                "DMSO_24T_Ind6REP",
                                "DOX_24R_Ind6REP",
                                "DMSO_24R_Ind6REP",
                                "DOX_144R_Ind6REP",
                                "DMSO_144R_Ind6REP")


#subset my count matrix based on filtered CPM matrix
x <- counts_raw_matrix[row.names(filcpm_matrix),]
dim(x)
#14319 genes as expected!
#this is still in counts form

#remove my replicate individual at this time
x_norep <- x[,1:36]

#modify my metadata to match
Metadata_2 <- Metadata[1:36,]
rownames(Metadata_2) <- Metadata_2$Sample_bam
colnames(x_norep) <- Metadata_2$Sample_ID
rownames(Metadata_2) <- Metadata_2$Sample_ID

Metadata_2$Condition <- make.names(Metadata_2$Condition)
Metadata_2$Ind <- as.character(Metadata_2$Ind)

#saveRDS(Metadata_2, "data/new/Metadata_2_norep.RDS")
```

```{r Differential Expression Analysis}

#create DGEList object
dge <- DGEList(counts = x_norep)
dge$samples$group <- factor(Metadata_2$Condition)
dge <- calcNormFactors(dge, method = "TMM")

#saveRDS(dge, "data/new/dge_matrix.RDS")

#check normalization factors from TMM normalization of LIBRARIES
dge$samples

#create my design matrix for DE
design <- model.matrix(~ 0 + Metadata_2$Condition)
colnames(design) <- gsub("Metadata_2\\$Condition", "", colnames(design))

#take care that the matrix automatically sorts cols alphabetically
##currently DMSO144R, DMSO24R, DMSO24T, DOX144R, DOX24R, DOX24T

#run duplicate correlation for individual effect
corfit <- duplicateCorrelation(object = dge$counts, design = design, block = Metadata_2$Ind)

#voom transformation and plot
v <- voom(dge, design, block = Metadata_2$Ind, correlation = corfit$consensus.correlation, plot = TRUE)

#fit my linear model
fit <- lmFit(v, design, block = Metadata_2$Ind, correlation = corfit$consensus.correlation)

#make my contrast matrix to compare across tx and veh
contrast_matrix <- makeContrasts(
  V.D24T = DOX_24T - DMSO_24T,
  V.D24R = DOX_24R - DMSO_24R, 
  V.D144R = DOX_144R - DMSO_144R,
  levels = design
)

#apply these contrasts to compare DOX to DMSO VEH
fit2 <- contrasts.fit(fit, contrast_matrix)
fit2 <- eBayes(fit2)

#plot the mean-variance trend
plotSA(fit2, main = "Final model: Mean-Variance trend")

#look at the summary of your results
##this tells you the number of DEGs in each condition
results_summary <- decideTests(fit2, adjust.method = "BH", p.value = 0.05)
summary(results_summary)
#        V.D24 V.D24r V.D144r
# Down    4723   3593     359
# NotSig  5076   7151   13810
# Up      4520   3575     150

vennDiagram(object = results_summary, include = c("up", "down"))

```

```{r Make Toptables of DEGs}

# Generate Top Table for Specific Comparisons

Toptable_V.D24T <- topTable(fit = fit2, coef = "V.D24T", number = nrow(x), adjust.method = "BH", p.value = 1, sort.by = "none")
#write.csv(Toptable_V.D24T, "data/new/DEGs/Toptable_V.D24T.csv")

Toptable_V.D24R <- topTable(fit = fit2, coef = "V.D24R", number = nrow(x), adjust.method = "BH", p.value = 1, sort.by = "none")
#write.csv(Toptable_V.D24R, "data/new/DEGs/Toptable_V.D24R.csv")

Toptable_V.D144R <- topTable(fit = fit2, coef = "V.D144R", number = nrow(x), adjust.method = "BH", p.value = 1, sort.by = "none")
#write.csv(Toptable_V.D144R, "data/new/DEGs/Toptable_V.D144R.csv")

#save all of these toptables as R objects
# saveRDS(list(
#   V.D24T = Toptable_V.D24T,
#   V.D24R = Toptable_V.D24R,
#   V.D144R = Toptable_V.D144R
# ), file = "data/new/Toptable_list.RDS")

Toptable_list <- readRDS("data/new/Toptable_list.RDS")

```


```{r Top 5 DEGs Limma}
#use your three toptables so I can pull out top 5 genes from each based on adj. p val

top5_D24T <- Toptable_V.D24T[order(Toptable_V.D24T$adj.P.Val), ][1:5,] %>% 
  rownames_to_column(., var = "Entrez_ID")
top5_D24R <- Toptable_V.D24R[order(Toptable_V.D24R$adj.P.Val), ][1:5,] %>% 
  rownames_to_column(., var = "Entrez_ID")
top5_D144R <- Toptable_V.D144R[order(Toptable_V.D144R$adj.P.Val), ][1:5,] %>% 
  rownames_to_column(., var = "Entrez_ID")

#now that I've pulled the top 5 DEGs from each, make a list to pull them from my log2cpm data

boxplot1 <- read.csv("data/new/filcpm_final_matrix.csv") %>% 
  as.data.frame()

#Define gene list
#these are the top 5 genes pulled from my toptables
top5_D24T_geneslist <- c(top5_D24T$Entrez_ID)
top5_D24R_geneslist <- c(top5_D24R$Entrez_ID)
top5_D144R_geneslist <- c(top5_D144R$Entrez_ID)
#Add more gene symbols as needed or add more categories

#now pull these from my log2cpm matrix
top5_D24T_genes <- boxplot1[boxplot1$Entrez_ID %in% top5_D24T_geneslist,]
dim(top5_D24T_genes)
#5 genes in 44 cols
top5_D24R_genes <- boxplot1[boxplot1$Entrez_ID %in% top5_D24R_geneslist,]
dim(top5_D24R_genes)
#5 genes in 44 cols
top5_D144R_genes <- boxplot1[boxplot1$Entrez_ID %in% top5_D144R_geneslist,]
dim(top5_D144R_genes)
#5 genes in 44 cols

#Now put in the function I want to use to generate boxplots of genes
#####D24T#####
process_top5_D24T <- function(gene) {
  gene_data <- top5_D24T_genes %>% filter(Entrez_ID == gene)
  long_data <- gene_data %>%
    pivot_longer(cols = -c(Entrez_ID, SYMBOL), names_to = "Sample", values_to = "log2cpm") %>%
    mutate(
      Drug = case_when(
        grepl("DOX", Sample) ~ "DOX",
        grepl("DMSO", Sample) ~ "DMSO",
        TRUE ~ NA_character_
      ),
      Timepoint = case_when(
        grepl("_24T_", Sample) ~ "24T",
        grepl("_24R_", Sample) ~ "24R",
        grepl("_144R_", Sample) ~ "144R",
        TRUE ~ NA_character_
      ),
      Indv = case_when(
        grepl("Ind1$", Sample) ~ "1",
        grepl("Ind2$", Sample) ~ "2",
        grepl("Ind3$", Sample) ~ "3",
        grepl("Ind4$", Sample) ~ "4",
        grepl("Ind5$", Sample) ~ "5",
        grepl("Ind6$", Sample) ~ "6",
        grepl("Ind6R$", Sample) ~ "6R",
        TRUE ~ NA_character_
      ),
      Condition = paste(Drug, Timepoint, sep = "_")
    )
  long_data$Condition <- factor(
    long_data$Condition,
    levels = c(
      "DOX_24T", 
      "DMSO_24T", 
      "DOX_24R", 
      "DMSO_24R", 
      "DOX_144R", 
      "DMSO_144R"
    )
  )
  return(long_data)
}


#Generate Boxplots from the above function using our gene list above
for (gene in top5_D24T_geneslist) {
  gene_data <- process_top5_D24T(gene)
  p <- ggplot(gene_data, aes(x = Condition, y = log2cpm, fill = Drug)) +
    geom_boxplot(outlier.shape = NA) +
    geom_point(aes(color = Indv), size = 2, alpha = 0.5, position = position_jitter(width = -1, height = 0)) +
    scale_fill_manual(values = c("DOX" = "#499FBD", "DMSO" = "#BBBBBC")) +
    ggtitle(paste("Log2cpm Expression of", gene, "top 5 DEGs D24T")) +
    labs(x = "Treatment", y = "log2cpm") +
    theme_bw() +
    theme(
      plot.title = element_text(size = rel(2), hjust = 0.5),
      axis.title = element_text(size = 15, color = "black"),
      axis.text.x = element_text(size = 10, color = "black", angle = 90, hjust = 1)
    )
  print(p)
}

#####D24R#####
process_top5_D24R <- function(gene) {
  gene_data <- top5_D24R_genes %>% filter(Entrez_ID == gene)
  long_data <- gene_data %>%
    pivot_longer(cols = -c(Entrez_ID, SYMBOL), names_to = "Sample", values_to = "log2cpm") %>%
    mutate(
      Drug = case_when(
        grepl("DOX", Sample) ~ "DOX",
        grepl("DMSO", Sample) ~ "DMSO",
        TRUE ~ NA_character_
      ),
      Timepoint = case_when(
        grepl("_24T_", Sample) ~ "24T",
        grepl("_24R_", Sample) ~ "24R",
        grepl("_144R_", Sample) ~ "144R",
        TRUE ~ NA_character_
      ),
      Indv = case_when(
        grepl("Ind1$", Sample) ~ "1",
        grepl("Ind2$", Sample) ~ "2",
        grepl("Ind3$", Sample) ~ "3",
        grepl("Ind4$", Sample) ~ "4",
        grepl("Ind5$", Sample) ~ "5",
        grepl("Ind6$", Sample) ~ "6",
        grepl("Ind6R$", Sample) ~ "6R",
        TRUE ~ NA_character_
      ),
      Condition = paste(Drug, Timepoint, sep = "_")
    )
  long_data$Condition <- factor(
    long_data$Condition,
    levels = c(
      "DOX_24T", 
      "DMSO_24T", 
      "DOX_24R", 
      "DMSO_24R", 
      "DOX_144R", 
      "DMSO_144R"
    )
  )
  return(long_data)
}


#Generate Boxplots from the above function using our gene list above
for (gene in top5_D24R_geneslist) {
  gene_data <- process_top5_D24R(gene)
  p <- ggplot(gene_data, aes(x = Condition, y = log2cpm, fill = Drug)) +
    geom_boxplot(outlier.shape = NA) +
    geom_point(aes(color = Indv), size = 2, alpha = 0.5, position = position_jitter(width = -1, height = 0)) +
    scale_fill_manual(values = c("DOX" = "#499FBD", "DMSO" = "#BBBBBC")) +
    ggtitle(paste("Log2cpm Expression of", gene, "top 5 DEGs D24R")) +
    labs(x = "Treatment", y = "log2cpm") +
    theme_bw() +
    theme(
      plot.title = element_text(size = rel(2), hjust = 0.5),
      axis.title = element_text(size = 15, color = "black"),
      axis.text.x = element_text(size = 10, color = "black", angle = 90, hjust = 1)
    )
  print(p)
}

#####D144R#####
process_top5_D144R <- function(gene) {
  gene_data <- top5_D144R_genes %>% filter(Entrez_ID == gene)
  long_data <- gene_data %>%
    pivot_longer(cols = -c(Entrez_ID, SYMBOL), names_to = "Sample", values_to = "log2cpm") %>%
    mutate(
      Drug = case_when(
        grepl("DOX", Sample) ~ "DOX",
        grepl("DMSO", Sample) ~ "DMSO",
        TRUE ~ NA_character_
      ),
      Timepoint = case_when(
        grepl("_24T_", Sample) ~ "24T",
        grepl("_24R_", Sample) ~ "24R",
        grepl("_144R_", Sample) ~ "144R",
        TRUE ~ NA_character_
      ),
      Indv = case_when(
        grepl("Ind1$", Sample) ~ "1",
        grepl("Ind2$", Sample) ~ "2",
        grepl("Ind3$", Sample) ~ "3",
        grepl("Ind4$", Sample) ~ "4",
        grepl("Ind5$", Sample) ~ "5",
        grepl("Ind6$", Sample) ~ "6",
        grepl("Ind6R$", Sample) ~ "6R",
        TRUE ~ NA_character_
      ),
      Condition = paste(Drug, Timepoint, sep = "_")
    )
  long_data$Condition <- factor(
    long_data$Condition,
    levels = c(
      "DOX_24T", 
      "DMSO_24T", 
      "DOX_24R", 
      "DMSO_24R", 
      "DOX_144R", 
      "DMSO_144R"
    )
  )
  return(long_data)
}


#Generate Boxplots from the above function using our gene list above
for (gene in top5_D144R_geneslist) {
  gene_data <- process_top5_D144R(gene)
  p <- ggplot(gene_data, aes(x = Condition, y = log2cpm, fill = Drug)) +
    geom_boxplot(outlier.shape = NA) +
    geom_point(aes(color = Indv), size = 2, alpha = 0.5, position = position_jitter(width = -1, height = 0)) +
    scale_fill_manual(values = c("DOX" = "#499FBD", "DMSO" = "#BBBBBC")) +
    ggtitle(paste("Log2cpm Expression of", gene, "top 5 DEGs D144R")) +
    labs(x = "Treatment", y = "log2cpm") +
    theme_bw() +
    theme(
      plot.title = element_text(size = rel(2), hjust = 0.5),
      axis.title = element_text(size = 15, color = "black"),
      axis.text.x = element_text(size = 10, color = "black", angle = 90, hjust = 1)
    )
  print(p)
}


```

```{r DOX24T DEGs logFC all Conditions}
# Toptable_V.D24T

# Load DEGs Data
DOX_24T <- read.csv("data/new/DEGs/Toptable_V.D24T.csv")
DOX_24R <- read.csv("data/new/DEGs/Toptable_V.D24R.csv")
DOX_144R <- read.csv("data/new/DEGs/Toptable_V.D144R.csv")

#make a list of all of the genes in this set so I can plot the logFC in other sets
D24T_DEGs <- DOX_24T$Entrez_ID[DOX_24T$adj.P.Val < 0.05]
length(D24T_DEGs)
#9243 genes in length after adj. p value cutoff
#if I did p value only - 9658 genes

#now that I have a list of my DEGs from D24T - pull these genes out from the other DEG lists
# D24R_DEGs <- Toptable_V.D24R[Toptable_V.D24R$adj.P.Val < 0.05,]

# D24R_DEGs_D24T <- D24R_DEGs %>%  
#   rownames_to_column(., var = "Entrez_ID")

# D24R_DEGs_D24T <- D24R_DEGs_D24T[D24R_DEGs_D24T$Entrez_ID %in% D24T_DEGs,]
# dim(D24R_DEGs_D24T)
#4831 genes in common here after adj p value cutoff

# D144R_DEGs <- Toptable_V.D144R[Toptable_V.D144R$adj.P.Val < 0.05,]
# 
# D144R_DEGs_D24T <- D144R_DEGs %>%  
#   rownames_to_column(., var = "Entrez_ID")
# 
# D144R_DEGs_D24T <- D144R_DEGs_D24T[D144R_DEGs_D24T$Entrez_ID %in% D24T_DEGs,]
# dim(D144R_DEGs_D24T)
#322 genes in common after adj p value cutoff

#now I want to plot the logFC of these

#ignore the above for now, just plot those full gene sets in logFC
D24T_DEGs <- DOX_24T$Entrez_ID[DOX_24T$adj.P.Val < 0.05]
length(D24T_DEGs)

D24R_DEGs <- DOX_24R$Entrez_ID[DOX_24R$adj.P.Val < 0.05]
length(D24R_DEGs)

D144R_DEGs <- DOX_144R$Entrez_ID[DOX_144R$adj.P.Val < 0.05]
length(D144R_DEGs)
#now that I have the full list of genes, I want to plot the logFC across conditions
#to do this - make a combined toptable

# Toptable_list

#plot the set of genes across conditions
# 
# logFC_long_allsets <- imap_dfr(Toptable_list, function(tbl, condition) {
#   tbl %>% 
#     rownames_to_column(var = "Entrez_ID") %>% 
#     dplyr::select(Entrez_ID, logFC) %>% 
#     mutate(Condition = condition)
# })
# 
# 
# ggplot(logFC_long_allsets, aes(x = Condition, y = logFC, group = Entrez_ID, color = Entrez_ID)) +
#   geom_boxplot() +
#   geom_point(size = 2) +
#   labs(
#     title = "logFC of Genes Across Conditions",
#     x = "Condition",
#     y = "logFC"
#   ) +
#   theme_minimal()


####Try this####

#Combine the toptables I have from pairwise analysis into a single dataframe
d24_toptable_dxr <- Toptable_V.D24T %>% 
  rownames_to_column(var = "Entrez_ID") %>% 
  mutate(Time = "24")

d24r_toptable_dxr <- Toptable_V.D24R %>% 
  rownames_to_column(var = "Entrez_ID") %>% 
  mutate(Time = "24R")

d144r_toptable_dxr <- Toptable_V.D144R %>% 
  rownames_to_column(var = "Entrez_ID") %>% 
  mutate(Time = "144R")

combined_toptables_dxr <- bind_rows(
  d24_toptable_dxr,
  d24r_toptable_dxr,
  d144r_toptable_dxr)

#Filter the data based on each motif
filt_toptable_dxr <- combined_toptables_dxr %>% 
  dplyr::filter(Entrez_ID  %in% D24T_DEGs) %>% 
  mutate(absFC = abs(logFC)) %>% 
  mutate(time = factor(Time, levels = c("24", "24R", "144R"), labels = c("24hr", "24hr Recovery", "144hr Recovery"))) %>% 
  ggplot(., aes(x = time, y = logFC))+
  geom_boxplot(aes(fill = time))+
  scale_fill_manual(values = time_col)+
  guides(fill = guide_legend(title = "Time"))+
  theme_bw()+
  xlab(" ")+
  ylab("logFC")+
  theme_bw()+
  ggtitle("LogFC for D24T DEGs Across Conditions")+
  theme(plot.title = element_text(size = rel(1.5), hjust = 0.5),
        axis.title = element_text(size = 15, colour = "black"),
        strip.background = element_rect(fill = "#CAD899"),
        axis.text.x = element_text(size = 8, colour = "white", angle = 15),
        strip.text.x = element_text(size = 12, colour = "black", face = "bold"))

#now do the same with the other conditions

filt_toptable_dxr_24r <- combined_toptables_dxr %>% 
  dplyr::filter(Entrez_ID  %in% D24R_DEGs) %>% 
  mutate(absFC = abs(logFC)) %>% 
  mutate(time = factor(Time, levels = c("24", "24R", "144R"), labels = c("24hr", "24hr Recovery", "144hr Recovery"))) %>% 
  ggplot(., aes(x = time, y = logFC))+
  geom_boxplot(aes(fill = time))+
  scale_fill_manual(values = time_col)+
  guides(fill = guide_legend(title = "Time"))+
  theme_bw()+
  xlab(" ")+
  ylab("logFC")+
  theme_bw()+
  ggtitle("LogFC for D24R DEGs Across Conditions")+
  theme(plot.title = element_text(size = rel(1.5), hjust = 0.5),
        axis.title = element_text(size = 15, colour = "black"),
        strip.background = element_rect(fill = "#CAD899"),
        axis.text.x = element_text(size = 8, colour = "white", angle = 15),
        strip.text.x = element_text(size = 12, colour = "black", face = "bold"))

#D144R

filt_toptable_dxr_144r <- combined_toptables_dxr %>% 
  dplyr::filter(Entrez_ID  %in% D144R_DEGs) %>% 
  mutate(absFC = abs(logFC)) %>% 
  mutate(time = factor(Time, levels = c("24", "24R", "144R"), labels = c("24hr", "24hr Recovery", "144hr Recovery"))) %>% 
  ggplot(., aes(x = time, y = logFC))+
  geom_boxplot(aes(fill = time))+
  scale_fill_manual(values = time_col)+
  guides(fill = guide_legend(title = "Time"))+
  theme_bw()+
  xlab(" ")+
  ylab("logFC")+
  theme_bw()+
  ggtitle("LogFC for D144R DEGs Across Conditions")+
  theme(plot.title = element_text(size = rel(1.5), hjust = 0.5),
        axis.title = element_text(size = 15, colour = "black"),
        strip.background = element_rect(fill = "#CAD899"),
        axis.text.x = element_text(size = 8, colour = "white", angle = 15),
        strip.text.x = element_text(size = 12, colour = "black", face = "bold"))

#now put the names of these graphs to print them
filt_toptable_dxr
filt_toptable_dxr_24r
filt_toptable_dxr_144r


```

```{r RUVs Correction Data Setup - no RUV yet, fig.height=6, fig.width=8}

filt_gene_list <- rownames(filcpm_matrix)
#14319 genes as usual

#in order to make this match with annot later down the line, change the col names for counts_raw_matrix to match final_sample_names in annot

#i'll also want to make sure I keep the replicate for this set

colnames(counts_raw_matrix) <- Metadata$Final_sample_name

RUV_filt_counts <- counts_raw_matrix %>% 
  as.data.frame() %>% 
  dplyr::filter(., row.names(.)%in% filt_gene_list)

#add in the annotation files
ind_num <- readRDS("data/new/ind_num.RDS")
annot <- read.csv("data/new/Metadata.csv")

#  counts need to be integer values and in a numeric matrix
# note: the log transformation needs to be accounted for in the isLog argument in RUVs function.
counts <- as.matrix(RUV_filt_counts)
#saveRDS(counts, "data/new/RUV/filt_counts_matrix.RDS")

# Create a DataFrame for the phenoData
phenoData <- DataFrame(annot)

# Now create the RangedSummarizedExperiment necessary for RUVs input
# looks like it did need both the phenodata and the counts.
set <- SummarizedExperiment(assays =  counts, metadata = phenoData)

# Generate a background matrix
# The column "Cond" holds the comparisons that you actually want to make. DOX_24, DMSO_24,5FU_24, DOX_3,etc.
scIdx <-RUVSeq::makeGroups(phenoData$Condition)
scIdx

#now I've made all of the data I need for this - they are located in each section for k values

#DO NOT USE THESE COUNTS FOR LINEAR MODELING

#colors for all of the plots
fill_col_ind <- c("#66C2A5", "#FC8D62", "#1F78B4", "#E78AC3", "#A6D854", "#FFD92A", "#8B3E9B")

fill_col_ind_dark <- c("#003F5C", "#45AE91",  "#58508D", "#BC4099", "#8B3E9B", "#FF6361", "#FF2362")

fill_col_tx <- c("#63666D", "#499FBD", "#DCACED")

fill_col_txtime <- c("#003F5C", "#45AE91",  "#58508D", "#BC4099", "#8B3E9B", "#FF6361", "#FF2362", "#A6D854", "#FC8D62")

# before ruv (counts PCA)
prcomp_res_counts <- prcomp(t(counts), scale. = FALSE, center = TRUE)
annot_prcomp_res <- prcomp_res_counts$x %>% cbind(., annot)

group_2 <- annot$Condition

#now plot my PCA for filtered counts
####PC1/PC2####
ggplot2::autoplot(prcomp_res_counts, 
                  data = annot, 
                  colour = "Condition", 
                  shape = "Time", 
                  size =4, 
                  x=1, 
                  y=2) +
  ggrepel::geom_text_repel(label=ind_num, 
                           vjust = -0.5, 
                           max.overlaps = 30) +
  scale_color_manual(values=cond_col) +
  ggtitle(expression("PCA of Filtered Counts")) +
  theme_bw()

####PC2/PC3####
ggplot2::autoplot(prcomp_res_counts, 
                  data = annot, 
                  colour = "Condition", 
                  shape = "Time", 
                  size =4, 
                  x=2, 
                  y=3) +
  ggrepel::geom_text_repel(label=ind_num, 
                           vjust = -0.5, 
                           max.overlaps = 30) +
  scale_color_manual(values=cond_col) +
  ggtitle(expression("PCA of Filtered Counts")) +
  theme_bw()

#go ahead and plot PCA of log2cpm to compare (somewhat) later since the norm counts output isn't possible with these data since they don't undergo correction

prcomp_res_cpm <- prcomp(t(filcpm_matrix %>% as.matrix()), center =  TRUE)

####PC1/PC2####
ggplot2::autoplot(prcomp_res_cpm, 
                  data = annot, 
                  colour = "Condition", 
                  shape = "Time", 
                  size =4, 
                  x=1, 
                  y=2) +
  ggrepel::geom_text_repel(label=ind_num, 
                           vjust = -0.5, 
                           max.overlaps = 30) +
  scale_color_manual(values=cond_col) +
  ggtitle(expression("PCA of log2cpm no RUVs")) +
  theme_bw()

####PC2/PC3####
ggplot2::autoplot(prcomp_res_cpm, 
                  data = annot, 
                  colour = "Condition", 
                  shape = "Time", 
                  size =4, 
                  x=2, 
                  y=3) +
  ggrepel::geom_text_repel(label=ind_num, 
                           vjust = -0.5, 
                           max.overlaps = 30) +
  scale_color_manual(values=cond_col) +
  ggtitle(expression("PCA of log2cpm no RUVs")) +
  theme_bw()


####new PCA plots no correction####
#PCA plots for each value of k attached in each section

#####Now start performing RUV 1-3###

```

```{r RUVs k1, fig.height=6, fig.width=8}
#Apply RUVs function from RUVSeq
#"k" will be iteratively adjusted over time depending on your PCA.
set1 <- RUVSeq::RUVs(x = counts, k =1, scIdx = scIdx, isLog = FALSE)

#get the ruv weights to put into the linear model. n weights = k.
#k=1
RUV_df1 <- set1$W %>% as.data.frame()
RUV_df1$Names <- rownames(RUV_df1)

#Check that the names match
#k=1
RUV_df_rm1 <- RUV_df1[RUV_df1$Names %in% annot$Final_sample_name, ] 
RUV_1 <-  RUV_df_rm1$W_1

#saveRDS(RUV_df_rm1, "data/new/RUV_df_rm1.RDS")
#saveRDS(RUV_1, "data/new/RUV_1.RDS")

#PCA checks
#k=1
prcomp_res_1 <- prcomp(t(set1$normalizedCounts), scale. = FALSE, center = TRUE)
annot_prcomp_res_1 <- prcomp_res_1$x %>% cbind(., annot)

ggplot2::autoplot(prcomp_res_1, data = annot, colour = "Condition", shape = "Time", size =4, x = 1, y = 2)+
  theme_bw()+
  scale_color_manual(values=cond_col)+
  ggrepel::geom_text_repel(label= ind_num, vjust = -0.5, max.overlaps = 30)+
  ggtitle("RUVs Correction k=1 NormCounts")

ggplot2::autoplot(prcomp_res_1, data = annot, colour = "Condition", shape = "Time", size =4, x=2, y=3)+
  theme_bw()+
  scale_color_manual(values=cond_col)+
  ggrepel::geom_text_repel(label= ind_num, vjust = -0.5, max.overlaps = 30)+
  ggtitle("RUVs Correction k=1 NormCounts")

#also try by converting these values to log2cpm

RUV_df_rm1_cpm <- cpm(set1$normalizedCounts, log = TRUE)

prcomp_res_1_cpm <- prcomp(t(RUV_df_rm1_cpm), scale. = FALSE, center = TRUE)
annot_prcomp_res_1_cpm <- prcomp_res_1_cpm$x %>% cbind(., annot)

##PC1/2
ggplot2::autoplot(prcomp_res_1_cpm, 
                  data = annot, 
                  colour = "Condition", 
                  shape = "Time", 
                  size = 4,
                  x=1,
                  y=2)+
  theme_bw()+
  scale_color_manual(values=cond_col)+
  ggrepel::geom_text_repel(label= ind_num, 
                           vjust = -0.5, 
                           max.overlaps = 30)+
  ggtitle("RUVs Correction k=1 log2cpm")

###PC2/3
ggplot2::autoplot(prcomp_res_1_cpm, 
                  data = annot, 
                  colour = "Condition", 
                  shape = "Time", 
                  size = 4, 
                  x=2, 
                  y=3)+
  theme_bw()+
  scale_color_manual(values=cond_col)+
  ggrepel::geom_text_repel(label= ind_num, 
                           vjust = -0.5, 
                           max.overlaps = 30)+
  ggtitle("RUVs Correction k=1 log2cpm")

```


```{r RUVs k2, fig.height=6, fig.width=8}
#Apply RUVs function from RUVSeq
#"k" will be iteratively adjusted over time depending on your PCA.
set2 <- RUVSeq::RUVs(x = counts, k =2, scIdx = scIdx, isLog = FALSE)

#get the ruv weights to put into the linear model. n weights = k.
#k=2
RUV_df2 <- set2$W %>% as.data.frame()
RUV_df2$Names <- rownames(RUV_df2)

#Check that the names match
#k=2
RUV_df_rm2 <- RUV_df2[RUV_df2$Names %in% annot$Final_sample_name, ] 
RUV_2 <-  RUV_df_rm2$W_2

#PCA checks
#k=2
prcomp_res_2 <- prcomp(t(set2$normalizedCounts), scale. = FALSE, center = TRUE)
annot_prcomp_res_2 <- prcomp_res_2$x %>% cbind(., annot)

##PC1/2
ggplot2::autoplot(prcomp_res_2, 
                  data = annot, 
                  colour = "Condition", 
                  shape = "Time", 
                  size =4, 
                  x=1,
                  y=2)+
  theme_bw()+
  scale_color_manual(values=cond_col)+
  ggrepel::geom_text_repel(label= ind_num, 
                           vjust = -0.5, 
                           max.overlaps = 30)+
  ggtitle("RUVs Correction k=2 NormCounts")

###PC2/3
ggplot2::autoplot(prcomp_res_2, 
                  data = annot, 
                  colour = "Condition", 
                  shape = "Time", 
                  size =4, 
                  x=2, 
                  y=3)+
  theme_bw()+
  scale_color_manual(values=cond_col)+
  ggrepel::geom_text_repel(label= ind_num, 
                           vjust = -0.5, 
                           max.overlaps = 30)+
  ggtitle("RUVs Correction k=2 NormCounts")

#now convert this to log2cpm using the normalized counts from set2

RUV_df_rm2_cpm <- cpm(set2$normalizedCounts, log = TRUE)

prcomp_res_2_cpm <- prcomp(t(RUV_df_rm2_cpm), scale. = FALSE, center = TRUE)
annot_prcomp_res_2_cpm <- prcomp_res_2_cpm$x %>% cbind(., annot)

ggplot2::autoplot(prcomp_res_2_cpm, 
                  data = annot, 
                  colour = "Condition", 
                  shape = "Time", 
                  size =4, 
                  x=1, 
                  y=2)+
  theme_bw()+
  scale_color_manual(values=cond_col)+
  ggrepel::geom_text_repel(label= ind_num, 
                           vjust = -0.5, 
                           max.overlaps = 30)+
  ggtitle("RUVs Correction k=2 log2cpm")

###PC2/3
ggplot2::autoplot(prcomp_res_2_cpm, 
                  data = annot, 
                  colour = "Condition", 
                  shape = "Time", 
                  size =4, 
                  x=2, 
                  y=3)+
  theme_bw()+
  scale_color_manual(values=cond_col)+
  ggrepel::geom_text_repel(label= ind_num, 
                           vjust = -0.5, 
                           max.overlaps = 30)+
  ggtitle("RUVs Correction k=2 log2cpm")

```

```{r RUVs k3, fig.height=6, fig.width=8}

#Apply RUVs function from RUVSeq
#"k" will be iteratively adjusted over time depending on your PCA.
set3 <- RUVSeq::RUVs(x = counts, k =3, scIdx = scIdx, isLog = FALSE)

#get the ruv weights to put into the linear model. n weights = k.
#k=3
RUV_df3 <- set3$W %>% as.data.frame()
RUV_df3$Names <- rownames(RUV_df3)

#Check that the names match
#k=3
RUV_df_rm3 <- RUV_df3[RUV_df3$Names %in% annot$Final_sample_name, ] 
RUV_3 <-  RUV_df_rm3$W_3

#PCA checks
#k=3
prcomp_res_3 <- prcomp(t(set3$normalizedCounts), scale. = FALSE, center = TRUE)
annot_prcomp_res_3 <- prcomp_res_3$x %>% cbind(., annot)

###PC1/2
ggplot2::autoplot(prcomp_res_3, 
                  data = annot, 
                  colour = "Condition", 
                  shape = "Time", 
                  size =4, 
                  x=1, 
                  y=2)+
  theme_bw()+
  scale_color_manual(values=cond_col)+
  ggrepel::geom_text_repel(label= ind_num, 
                           vjust = -0.5, 
                           max.overlaps = 30)+
  ggtitle("RUVs Correction k=3 NormCounts")

###PC2/3
ggplot2::autoplot(prcomp_res_3, 
                  data = annot, 
                  colour = "Condition", 
                  shape = "Time", 
                  size =4, 
                  x=2, 
                  y=3)+
  theme_bw()+
  scale_color_manual(values=cond_col)+
  ggrepel::geom_text_repel(label= ind_num, 
                           vjust = -0.5, 
                           max.overlaps = 30)+
  ggtitle("RUVs Correction k=3 NormCounts")

#now convert this to log2cpm using the normalized counts from set3

RUV_df_rm3_cpm <- cpm(set3$normalizedCounts, log = TRUE)

prcomp_res_3_cpm <- prcomp(t(RUV_df_rm3_cpm), scale. = FALSE, center = TRUE)
annot_prcomp_res_3_cpm <- prcomp_res_3_cpm$x %>% cbind(., annot)

##PC1/2
ggplot2::autoplot(prcomp_res_3_cpm, 
                  data = annot, 
                  colour = "Condition", 
                  shape = "Time", 
                  size =4, 
                  x=1, 
                  y=2)+
  theme_bw()+
  scale_color_manual(values=cond_col)+
  ggrepel::geom_text_repel(label= ind_num, 
                           vjust = -0.5, 
                           max.overlaps = 30)+
  ggtitle("RUVs Correction k=3 log2cpm")

###PC2/3
ggplot2::autoplot(prcomp_res_3_cpm, 
                  data = annot, 
                  colour = "Condition", 
                  shape = "Time", 
                  size =4, 
                  x=2, 
                  y=3)+
  theme_bw()+
  scale_color_manual(values=cond_col)+
  ggrepel::geom_text_repel(label= ind_num, 
                           vjust = -0.5, 
                           max.overlaps = 30)+
  ggtitle("RUVs Correction k=3 log2cpm")

```

```{r RUVs Boxplots of Contributing Factors, include = FALSE}
#I want to take a look at my RUV corrected k=3 PCA to see what the major contributing factors are - I'll create boxplots with my metadata to accompany the PCA plots

#load my normalized counts data and my log2cpm converted data
# normcounts_k1_matrix <- set1$normalizedCounts %>% as.matrix()
# RUV_k1_cpm <- cpm(set1$normalizedCounts, log = TRUE)
# 
# #load in my metadata sheet
# Metadata_RUV <- read.csv("data/Metadata.csv")
# Metadata_RUV$Time <- factor(Metadata_RUV$Time, 
#                             levels = c("24T", "24R", "144R"), 
#                             labels = c("24T", "24R", "144R"))
# Metadata_RUV$Ind <- as.factor(Metadata_RUV$Ind)
# Metadata_RUV$Drug <- as.character(Metadata$Drug)
# Metadata_RUV$Sex <- factor(Metadata_RUV$Sex, 
#                            levels = c("M", "F")) 
# 
# 
# #PCA plots in normalized counts and log2cpm
# 
# prcomp_res_3_RUV_normcounts <- prcomp(t(normcounts_k3_matrix), scale. = FALSE, center = TRUE)
# pca_df_3_RUV_normcounts <- as.data.frame(prcomp_res_3_RUV_normcounts$x[, 1:3])  #PC1PC3
# pca_df_3_RUV_normcounts$Ind <- Metadata_RUV$Ind
# pca_df_3_RUV_normcounts$Drug <- Metadata_RUV$Drug
# pca_df_3_RUV_normcounts$Time <- Metadata_RUV$Time
# pca_df_3_RUV_normcounts$Sex <- Metadata_RUV$Sex
# 
# prcomp_res_3_RUV_cpm <- prcomp(t(RUV_k3_cpm), scale. = FALSE, center = TRUE)
# pca_df_3_RUV_cpm <- as.data.frame(prcomp_res_3_RUV_cpm$x[,1:3]) #PC1-3
# pca_df_3_RUV_cpm$Ind <- Metadata_RUV$Ind
# pca_df_3_RUV_cpm$Drug <- Metadata_RUV$Drug
# pca_df_3_RUV_cpm$Time <- Metadata_RUV$Time
# pca_df_3_RUV_cpm$Sex <- Metadata_RUV$Sex
# 
# #p-value from linear model
# get_regr_pval <- function(mod) {
#   stopifnot(class(mod) == "lm")
#   fstat <- summary(mod)$fstatistic
#   pval <- 1 - pf(fstat[1], fstat[2], fstat[3])
#   return(pval)
# }
# 
# #create boxplots of PCA contributing factors based on metadata
# plot_pc_k3_normcounts_box <- function(df, group_var, pc) {
#   group_data <- df[[group_var]]
#   n_groups <- length(unique(group_data))
#   
#   if (n_groups > 1) {
#     model <- lm(df[[pc]] ~ group_data)
#     pval <- get_regr_pval(model)
#     pval_label <- paste0("p-value: ", signif(pval, 3))
#   } else {
#     pval_label <- "p-value: NA"
#   }
#   
#   ggplot(df, aes(x = .data[[group_var]], y = .data[[pc]], fill = .data[[group_var]])) +
#     geom_boxplot(color = "black") +
#     theme_bw(base_size = 11) +
#     ylab(pc) + xlab(group_var) +
#     ggtitle(NULL, subtitle = pval_label) +
#     theme(
#       legend.position = "none",
#       plot.subtitle = element_text(size = 10),
#       panel.border = element_rect(color = "black", fill = NA)
#     )
# }
# 
# #Generate 12 plots: PC13  Ind, Drug, Time, Sex (these are )
# pcs <- c("PC1", "PC2", "PC3")
# group_vars <- c("Ind", "Drug", "Time", "Sex")
# plots <- list()
# 
# for (pc in pcs) {
#   for (group in group_vars) {
#     key <- paste(pc, group, sep = "_")
#     
#     base_plot <- plot_pc_k3_normcounts_box(pca_df_3_RUV_normcounts, group, pc)
#     
#     if (pc == "PC1") {
#       upper_limit <- max(pca_df_3_RUV_normcounts[[pc]], na.rm = TRUE) * 1.1
#       plots[[key]] <- base_plot +
#         scale_y_continuous(limits = c(-60, upper_limit),
#                            breaks = c(-60, -30, 0, 30, 60, 90, 120))
#     } else {
#       plots[[key]] <- base_plot
#     }
#   }
# }
# 
# #  Remove main titles (retain subtitles for p-values)
# plots <- lapply(plots, function(p) {
#   p + theme(plot.title = element_blank())
# })
# 
# #  Create column headers
# header_ind  <- ggplot() + theme_void() + ggtitle("Ind")   + theme(plot.title = element_text(hjust = 0.5, size = 14, face = "bold"))
# header_drug <- ggplot() + theme_void() + ggtitle("Drug")  + theme(plot.title = element_text(hjust = 0.5, size = 14, face = "bold"))
# header_conc <- ggplot() + theme_void() + ggtitle("Conc")  + theme(plot.title = element_text(hjust = 0.5, size = 14, face = "bold"))
# header_time <- ggplot() + theme_void() + ggtitle("Time")  + theme(plot.title = element_text(hjust = 0.5, size = 14, face = "bold"))
# header_sex  <- ggplot() + theme_void() + ggtitle("Sex")   + theme(plot.title = element_text(hjust = 0.5, size = 14, face = "bold"))  #  New header
# 
# #  Assemble 5-column layout with 3 PC rows
# final_plot <- (
#   (header_ind | header_drug | header_conc | header_time | header_sex) /
#     (plots[["PC1_Ind"]] | plots[["PC1_Drug"]] | plots[["PC1_Conc"]] | plots[["PC1_Time"]] | plots[["PC1_Sex"]]) /
#     (plots[["PC2_Ind"]] | plots[["PC2_Drug"]] | plots[["PC2_Conc"]] | plots[["PC2_Time"]] | plots[["PC2_Sex"]]) /
#     (plots[["PC3_Ind"]] | plots[["PC3_Drug"]] | plots[["PC3_Conc"]] | plots[["PC3_Time"]] | plots[["PC3_Sex"]])
# ) + plot_layout(heights = c(0.07, 1, 1, 1))  # Title row height
# 
# #  Display the plot
# print(final_plot)


```


```{r RUVs HM Spearman, fig.height=10, fig.width=12}
#Now that I've put together the PCA plots for both normalized counts and log2cpm
#I want to make these into heatmaps

####RUVs k=1-3
#check to make sure that the column names are correct
dim(RUV_filt_counts)
dim(set1$normalizedCounts)
dim(set2$normalizedCounts)
dim(set3$normalizedCounts)

#take the normalized counts from k=1 and put together a dataframe with the correct columns
normcounts_k0 <- RUV_filt_counts
normcounts_k1 <- set1$normalizedCounts %>% as.data.frame()
#do the same with k=2 and k=3
normcounts_k2 <- set2$normalizedCounts %>% as.data.frame()
normcounts_k3 <- set3$normalizedCounts %>% as.data.frame()

#do the same with the log2cpm conversion
cpm_k0 <- cpm(normcounts_k0, log = TRUE) %>% as.data.frame()
cpm_k1 <- cpm(set1$normalizedCounts, log = TRUE) %>% as.data.frame()
cpm_k2 <- cpm(set2$normalizedCounts, log = TRUE) %>% as.data.frame()
cpm_k3 <- cpm(set3$normalizedCounts, log = TRUE) %>% as.data.frame()

#compute the correlation matrices for RUVs 1-3 with normalized counts
#k=0
cor_matrix_spmn_k0 <- cor(normcounts_k0,
                          y = NULL,
                          use = "everything", 
                          method = "spearman")
#k=1
cor_matrix_spmn_k1 <- cor(normcounts_k1,
                           y = NULL,
                           use = "everything",
                           method = "spearman")

#k=2
cor_matrix_spmn_k2 <- cor(normcounts_k2,
                          y = NULL,
                          use = "everything",
                          method = "spearman")

#k=3
cor_matrix_spmn_k3 <- cor(normcounts_k3,
                          y = NULL,
                          use = "everything",
                          method = "spearman")

#Do the same with the log2cpm converted versions
#k=0
cor_matrix_spmn_k0_cpm <- cor(cpm_k0,
                           y = NULL,
                           use = "everything",
                           method = "spearman")

#k=1
cor_matrix_spmn_k1_cpm <- cor(cpm_k1,
                           y = NULL,
                           use = "everything",
                           method = "spearman")

#k=2
cor_matrix_spmn_k2_cpm <- cor(cpm_k2,
                          y = NULL,
                          use = "everything",
                          method = "spearman")

#k=3
cor_matrix_spmn_k3_cpm <- cor(cpm_k3,
                          y = NULL,
                          use = "everything",
                          method = "spearman")

#extract metadata columns
Individual <- as.character(Metadata$Ind)
Time <- as.character(Metadata$Time)
Treatment <- as.character(Metadata$Drug)

# Define color palettes for annotations
annot_col_cor = list(Treatment = c("DOX" = "#499FBD", 
                               "DMSO" = "#BBBBBC"),
                     Individuals = c("1" = "#003F5C", 
                                     "2" = "#45AE91", 
                                     "3" = "#58209D", 
                                     "4" = "#8B3E9B", 
                                     "5" = "#FF6361", 
                                     "6" = "#BC4169", 
                                     "6R" = "#FF2362"),
                     Timepoints = c("24T" = "#238B45",
                                    "24R" = "#74C476", 
                                    "144R" = "#C7E9C0"))

tx_colors <- c("DOX" = "#499FBD", 
                 "DMSO" = "#BBBBBC")
ind_colors <- c("1" = "red",
                "2" = "orange",
                "3" = "yellow",
                "4" = "green",
                "5" = "blue",
                "6" = "violet",
                "6R" = "purple")
time_colors <- c("24T" = "#238B45",
                 "24R" = "#74C476",
                 "144R" = "#C7E9C0")

# Create annotations
top_annotation <- HeatmapAnnotation(
  Individual = Individual, 
  Time = Time,
  Treatment = Treatment,
  col = list(
    Individual = ind_colors, 
    Time = time_colors,
    Treatment = tx_colors
  )
)

####ANNOTATED HEATMAPS####
###Spearman Heatmap k=0 ####
heatmap_spmn_k0 <- Heatmap(cor_matrix_spmn_k0,
                           name = "Spearman",
                           top_annotation = top_annotation,
                           show_row_names = TRUE,
                           show_column_names = TRUE,
                           cluster_rows = TRUE,
                           cluster_columns = TRUE,
                           border = TRUE, 
                           column_title = "Filtered Counts no RUVs")

# Draw the heatmap k=0
draw(heatmap_spmn_k0)

####Spearman Heatmap k=1 ####
heatmap_spmn_k1 <- Heatmap(cor_matrix_spmn_k1,
                           name = "Spearman",
                           top_annotation = top_annotation,
                           show_row_names = TRUE,
                           show_column_names = TRUE,
                           cluster_rows = TRUE,
                           cluster_columns = TRUE,
                           border = TRUE, 
                           column_title = "Normalized Counts k=1")

# Draw the heatmap k=1
draw(heatmap_spmn_k1)

####Spearman Heatmap k=2####
heatmap_spmn_k2 <- Heatmap(cor_matrix_spmn_k2,
                           name = "Spearman",
                           top_annotation = top_annotation,
                           show_row_names = TRUE,
                           show_column_names = TRUE,
                           cluster_rows = TRUE,
                           cluster_columns = TRUE,
                           border = TRUE, 
                           column_title = "Normalized Counts k=2")

# Draw the heatmap k=2
draw(heatmap_spmn_k2)

####Spearman Heatmap k=3####
heatmap_spmn_k3 <- Heatmap(cor_matrix_spmn_k3,
                           name = "Spearman",
                           top_annotation = top_annotation,
                           show_row_names = TRUE,
                           show_column_names = TRUE,
                           cluster_rows = TRUE,
                           cluster_columns = TRUE,
                           border = TRUE, 
                           column_title = "Normalized Counts k=3")

# Draw the heatmap k=3
draw(heatmap_spmn_k3)


####Spearman Heatmap k=0 log2cpm####
heatmap_spmn_k0_cpm <- Heatmap(cor_matrix_spmn_k0_cpm,
                           name = "Spearman",
                           top_annotation = top_annotation,
                           show_row_names = TRUE,
                           show_column_names = TRUE,
                           cluster_rows = TRUE,
                           cluster_columns = TRUE,
                           border = TRUE, 
                           column_title = "log2cpm of Filtered Counts no RUVs")

# Draw the heatmap k=0 log2cpm
draw(heatmap_spmn_k0_cpm)

####Spearman Heatmap k=1 log2cpm####
heatmap_spmn_k1_cpm <- Heatmap(cor_matrix_spmn_k1_cpm,
                           name = "Spearman",
                           top_annotation = top_annotation,
                           show_row_names = TRUE,
                           show_column_names = TRUE,
                           cluster_rows = TRUE,
                           cluster_columns = TRUE,
                           border = TRUE, 
                           column_title = "log2cpm of Normalized Counts k=1")

# Draw the heatmap k=1 log2cpm
draw(heatmap_spmn_k1_cpm)

####Spearman Heatmap k=2 log2cpm####
heatmap_spmn_k2_cpm <- Heatmap(cor_matrix_spmn_k2_cpm,
                           name = "Spearman",
                           top_annotation = top_annotation,
                           show_row_names = TRUE,
                           show_column_names = TRUE,
                           cluster_rows = TRUE,
                           cluster_columns = TRUE,
                           border = TRUE, 
                           column_title = "log2cpm of Normalized Counts k=2")

# Draw the heatmap k=2 log2cpm
draw(heatmap_spmn_k2_cpm)

####Spearman Heatmap k=3 log2cpm####
heatmap_spmn_k3_cpm <- Heatmap(cor_matrix_spmn_k3_cpm,
                           name = "Spearman",
                           top_annotation = top_annotation,
                           show_row_names = TRUE,
                           show_column_names = TRUE,
                           cluster_rows = TRUE,
                           cluster_columns = TRUE,
                           border = TRUE, 
                           column_title = "log2cpm of Normalized Counts k=3")

# Draw the heatmap k=3 log2cpm
draw(heatmap_spmn_k3_cpm)


```

```{r DE RUVs k1}
#same DGEList object as before
dge <- readRDS("data/new/dge_matrix.RDS")

#check normalization factors from TMM normalization of LIBRARIES
dge$samples

#read in my covariate information RUV_1 dataframe + remove 6R
RUV_df_rm1 <- readRDS("data/new/RUV_df_rm1.RDS")

#filter out 6R for DE analysis
RUV_1_df_filt <- RUV_df_rm1[!grepl("6R$", rownames(RUV_df_rm1)), , drop = FALSE]

Metadata_2$W_1 <- RUV_1_df_filt$W_1

#now ensure that RUV_1 has the right number of cols after removing rep
length(RUV_1_df_filt$W_1)
#36 

#now make this into a list
RUV_1_DE <-  RUV_1_df_filt$W_1

#saveRDS(RUV_1_DE, "data/new/RUV_1_DE.RDS")

#create my design matrix for DE + RUVs covariate k=1
design1 <- model.matrix(~0 + RUV_1_DE + Metadata_2$Condition)
colnames(design1) <- gsub("Metadata_2\\$Condition", "", colnames(design1))

#take care that the matrix automatically sorts cols alphabetically
##currently DMSO144R, DMSO24R, DMSO24T, DOX144R, DOX24R, DOX24T

#run duplicate correlation for individual effect
corfit1 <- duplicateCorrelation(object = dge$counts, design = design1, block = Metadata_2$Ind)

#voom transformation and plot
v1 <- voom(dge, design1, block = Metadata_2$Ind, correlation = corfit1$consensus.correlation, plot = TRUE)

#fit my linear model
fit1 <- lmFit(v1, design1, block = Metadata_2$Ind, correlation = corfit1$consensus.correlation)

#make my contrast matrix to compare across tx and veh
contrast_matrix_RUV <- makeContrasts(
  V.D24T = DOX_24T - DMSO_24T,
  V.D24R = DOX_24R - DMSO_24R, 
  V.D144R = DOX_144R - DMSO_144R,
  RUV_1_24T = RUV_1_DE - DMSO_24T,
  RUV_1_24R = RUV_1_DE - DMSO_24R,
  RUV_1_144R = RUV_1_DE - DMSO_144R,  
  levels = design1
)

#apply these contrasts to compare DOX to DMSO VEH
fit_RUV <- contrasts.fit(fit1, contrast_matrix_RUV)
fit_RUV <- eBayes(fit_RUV)

#plot the mean-variance trend
plotSA(fit_RUV, main = "Mean-Variance Trend, RUVs k=1")

#look at the summary of your results
##this tells you the number of DEGs in each condition
results_summary1 <- decideTests(fit_RUV, adjust.method = "BH", p.value = 0.05)

summary(results_summary1)
#        V.D24T V.D24R V.D144R RUV_1_24T RUV_1_24R RUV_1_144R
# Down     4866   3727     466     13212     13224      13168
# NotSig   4899   7107   13659      1014      1002       1058
# Up       4554   3485     194        93        93         93

#compare this to my previous DEGs I found
summary(results_summary)
#        V.D24T V.D24R V.D144R
# Down     4723   3593     359
# NotSig   5076   7151   13810
# Up       4520   3575     150


#overall, there are more DEGs found after RUVs k=1 correction 
#this was an expected result as it increases tx effect w/ correction

```

```{r TopTables DE RUV}
# Generate Top Table for Specific Comparisons

Toptable_V.D24T_k1 <- topTable(fit = fit_RUV, coef = "V.D24T", number = nrow(x), adjust.method = "BH", p.value = 1, sort.by = "none")
#write.csv(Toptable_V.D24T_k1, "data/new/DEGs/Toptable_V.D24T_k1.csv")

Toptable_V.D24R_k1 <- topTable(fit = fit_RUV, coef = "V.D24R", number = nrow(x), adjust.method = "BH", p.value = 1, sort.by = "none")
#write.csv(Toptable_V.D24R_k1, "data/new/DEGs/Toptable_V.D24R_k1.csv")

Toptable_V.D144R_k1 <- topTable(fit = fit_RUV, coef = "V.D144R", number = nrow(x), adjust.method = "BH", p.value = 1, sort.by = "none")
#write.csv(Toptable_V.D144R_k1, "data/new/DEGs/Toptable_V.D144R_k1.csv")

# save all of these toptables as R objects
# saveRDS(list(
#   V.D24T_k1 = Toptable_V.D24T_k1,
#   V.D24R_k1 = Toptable_V.D24R_k1,
#   V.D144R_k1 = Toptable_V.D144R_k1
# ), file = "data/new/Toptable_list_RUVk1.RDS")

Toptable_list_RUVk1 <- readRDS("data/new/Toptable_list_RUVk1.RDS")

#################################################################
#this section is commented out since it only needs to run once
#kept the code for posterity

# #I want to add the hgnc symbols to my toptables as well
# ####D24T####
# #load in data
# sample_toptab_24T <- read_csv("data/new/DEGs/Toptable_V.D24T_k1.csv", show_col_types = FALSE)
# # ----------------- Ensure Entrez_ID is Present and in Character Format -----------------
# # Check column names
# print(colnames(sample_toptab_24T))
# # Rename if needed (adjust if the column name is not exactly 'Entrez_ID')
# colnames(sample_toptab_24T)[1] <- "Entrez_ID"
# # Convert Entrez_ID to character
# sample_toptab_24T <- sample_toptab_24T %>%
#   mutate(Entrez_ID = as.character(Entrez_ID))
# # ----------------- Map Entrez_ID to Gene Symbol -----------------
# gene_symbols1 <- AnnotationDbi::select(
#   org.Hs.eg.db,
#   keys = sample_toptab_24T$Entrez_ID,
#   columns = c("SYMBOL"),
#   keytype = "ENTREZID"
# )
# # ----------------- Join Back to Main Data -----------------
# Toptable_RUV_24T <- left_join(sample_toptab_24T, gene_symbols1, by = c("Entrez_ID" = "ENTREZID"))
# Toptable_RUV_24T %>% column_to_rownames(., var = "Entrez_ID")
# # ----------------- Save Annotated Output -----------------
# #write_csv(Toptable_RUV_24T, "data/new/DEGs/Toptable_RUV_24T.csv")
# 
# #now do this again for my other two toptables
# 
# ####24R####
# #load in data
# sample_toptab_24R <- read_csv("data/new/DEGs/Toptable_V.D24R_k1.csv", show_col_types = FALSE)
# # ----------------- Ensure Entrez_ID is Present and in Character Format -----------------
# # Check column names
# print(colnames(sample_toptab_24R))
# # Rename if needed (adjust if the column name is not exactly 'Entrez_ID')
# colnames(sample_toptab_24R)[1] <- "Entrez_ID"
# # Convert Entrez_ID to character
# sample_toptab_24R <- sample_toptab_24R %>%
#   mutate(Entrez_ID = as.character(Entrez_ID))
# # ----------------- Map Entrez_ID to Gene Symbol -----------------
# gene_symbols2 <- AnnotationDbi::select(
#   org.Hs.eg.db,
#   keys = sample_toptab_24R$Entrez_ID,
#   columns = c("SYMBOL"),
#   keytype = "ENTREZID"
# )
# # ----------------- Join Back to Main Data -----------------
# Toptable_RUV_24R <- left_join(sample_toptab_24R, gene_symbols2, by = c("Entrez_ID" = "ENTREZID"))
# Toptable_RUV_24R %>% column_to_rownames(., var = "Entrez_ID")
# # ----------------- Save Annotated Output -----------------
# #I'll make these symbols into rownames later for my volcano plots
# #write_csv(Toptable_RUV_24R, "data/new/DEGs/Toptable_RUV_24R.csv")
# 
# 
# ####D144R####
# #load in data
# sample_toptab_144R <- read_csv("data/new/DEGs/Toptable_V.D144R_k1.csv", show_col_types = FALSE)
# # ----------------- Ensure Entrez_ID is Present and in Character Format -----------------
# # Check column names
# print(colnames(sample_toptab_144R))
# # Rename if needed (adjust if the column name is not exactly 'Entrez_ID')
# colnames(sample_toptab_144R)[1] <- "Entrez_ID"
# # Convert Entrez_ID to character
# sample_toptab_144R <- sample_toptab_144R %>%
#   mutate(Entrez_ID = as.character(Entrez_ID))
# # ----------------- Map Entrez_ID to Gene Symbol -----------------
# gene_symbols3 <- AnnotationDbi::select(
#   org.Hs.eg.db,
#   keys = sample_toptab_144R$Entrez_ID,
#   columns = c("SYMBOL"),
#   keytype = "ENTREZID"
# )
# # ----------------- Join Back to Main Data -----------------
# Toptable_RUV_144R <- left_join(sample_toptab_144R, gene_symbols3, by = c("Entrez_ID" = "ENTREZID"))
# Toptable_RUV_144R %>% column_to_rownames(., var = "Entrez_ID")
# # ----------------- Save Annotated Output -----------------
# #I'll make these symbols into rownames later for my volcano plots
# #write_csv(Toptable_RUV_144R, "data/new/DEGs/Toptable_RUV_144R.csv")

# write.csv(Toptable_RUV_24T, "data/new/DEGs/Toptable_RUV_24T_final.csv")
# write.csv(Toptable_RUV_24R, "data/new/DEGs/Toptable_RUV_24R_final.csv")
# write.csv(Toptable_RUV_144R, "data/new/DEGs/Toptable_RUV_144R_final.csv")

Toptable_RUV_24T <- read.csv("data/new/DEGs/Toptable_RUV_24T_final.csv")
Toptable_RUV_24R <- read.csv("data/new/DEGs/Toptable_RUV_24R_final.csv")
Toptable_RUV_144R <- read.csv("data/new/DEGs/Toptable_RUV_144R_final.csv")



# save all of these toptables as R objects
# saveRDS(list(
#   V.D24T_RUV = Toptable_RUV_24T,
#   V.D24R_RUV = Toptable_RUV_24R,
#   V.D144R_RUV = Toptable_RUV_144R
# ), file = "data/new/Toptable_list_RUVk1_Symbols.RDS")

Toptable_list_RUVk1_symbols <- readRDS("data/new/Toptable_list_RUVk1_Symbols.RDS")

```


```{r Volcano Plots of DEGs Original}
#make a function to generate volcano plots + add gene numbers
generate_volcano_plot <- function(toptable, title) {
  
  #make significance labels
  toptable$Significance <- "Not Significant"
  toptable$Significance[toptable$logFC > 0 & toptable$adj.P.Val < 0.05] <- "Upregulated"
  toptable$Significance[toptable$logFC < 0 & toptable$adj.P.Val < 0.05] <- "Downregulated"
  
  #add number of genes for each significance label
  upgenes <- toptable %>% filter(Significance == "Upregulated") %>% nrow()
  nsgenes <- toptable %>% filter(Significance == "Not Significant") %>% nrow()
  downgenes <- toptable %>% filter(Significance == "Downregulated") %>% nrow()

  #make legend labels for no of genes
  legend_lab <- c(
    str_c("Upregulated: ", upgenes),
    str_c("Not Significant: ", nsgenes),
    str_c("Downregulated: ", downgenes)
  )
  
  #specify the colors for the legend
  legend_col <- c(
    str_c("Upregulated: " = "blue"),
    str_c("Not Significant: " = "gray"),
    str_c("Downregulated: " = "red")
  )

  #generate volcano plot w/ legend
  ggplot(toptable, aes(x = logFC, 
                       y = -log10(P.Value), 
                       color = Significance)) +
    geom_point(alpha = 0.4, size = 2) + 
    scale_color_manual(values = c("Upregulated" = "blue",
                                  "Not Significant" = "gray",
                                  "Downregulated" = "red"), 
                       labels = legend_lab) +
    xlim(-10, 10) +
    labs(title = title, 
         x = expression(x = "log"[2]*"FC"), 
         y = expression(y = "-log"[10]*"P-value")) +
    theme_bw()+
    guides(color = guide_legend(override.aes = list(color = legend_col)))+
    theme(legend.position = "right", 
          plot.title = element_text(size = rel(1.5), hjust = 0.5),
          axis.title = element_text(size = rel(1.25)))
}

#generate volcano plots across each comparison
volcano_plots <- list(
  "V.D24T" = generate_volcano_plot(Toptable_V.D24T, "Volcano Plot DOX 24hr (adj P-val<0.05)"),
  "V.D24R" = generate_volcano_plot(Toptable_V.D24R, "Volcano Plot DOX 24hr Recovery (adj P-val<0.05)"),
  "V.D144R" = generate_volcano_plot(Toptable_V.D144R, "Volcano Plot DOX 144hr Recovery (adj P-val<0.05)")
)

# Display each volcano plot
for (plot_name in names(volcano_plots)) {
  print(volcano_plots[[plot_name]])
}


```

```{r RUV Top5 DEGs}
#use your three toptables so I can pull out top 5 genes from each based on adj. p val

top5_D24T_1 <- Toptable_RUV_24T[order(Toptable_RUV_24T$adj.P.Val), ][1:5,] 
top5_D24R_1 <- Toptable_RUV_24R[order(Toptable_RUV_24R$adj.P.Val), ][1:5,] 
top5_D144R_1 <- Toptable_RUV_144R[order(Toptable_RUV_144R$adj.P.Val), ][1:5,]

#now that I've pulled the top 5 DEGs from each, make a list to pull them from my log2cpm data

boxplot1 <- read.csv("data/new/filcpm_final_matrix.csv") %>% 
  as.data.frame()

#Define gene list
#these are the top 5 genes pulled from my toptables
top5_D24T_geneslist_1 <- c(top5_D24T_1$Entrez_ID)
top5_D24R_geneslist_1 <- c(top5_D24R_1$Entrez_ID)
top5_D144R_geneslist_1 <- c(top5_D144R_1$Entrez_ID)
#Add more gene symbols as needed or add more categories

#now pull these from my log2cpm matrix
top5_D24T_genes_1 <- boxplot1[boxplot1$Entrez_ID %in% top5_D24T_geneslist_1,]
dim(top5_D24T_genes_1)
#5 genes in 44 cols
top5_D24R_genes_1 <- boxplot1[boxplot1$Entrez_ID %in% top5_D24R_geneslist_1,]
dim(top5_D24R_genes_1)
#5 genes in 44 cols
top5_D144R_genes_1 <- boxplot1[boxplot1$Entrez_ID %in% top5_D144R_geneslist_1,]
dim(top5_D144R_genes_1)
#5 genes in 44 cols

#Now put in the function I want to use to generate boxplots of genes
#####D24T#####
process_top5_D24T_1 <- function(gene) {
  gene_data <- top5_D24T_genes_1 %>% filter(Entrez_ID == gene)
  long_data <- gene_data %>%
    pivot_longer(cols = -c(Entrez_ID, SYMBOL), names_to = "Sample", values_to = "log2cpm") %>%
    mutate(
      Drug = case_when(
        grepl("DOX", Sample) ~ "DOX",
        grepl("DMSO", Sample) ~ "DMSO",
        TRUE ~ NA_character_
      ),
      Timepoint = case_when(
        grepl("_24T_", Sample) ~ "24T",
        grepl("_24R_", Sample) ~ "24R",
        grepl("_144R_", Sample) ~ "144R",
        TRUE ~ NA_character_
      ),
      Indv = case_when(
        grepl("Ind1$", Sample) ~ "1",
        grepl("Ind2$", Sample) ~ "2",
        grepl("Ind3$", Sample) ~ "3",
        grepl("Ind4$", Sample) ~ "4",
        grepl("Ind5$", Sample) ~ "5",
        grepl("Ind6$", Sample) ~ "6",
        grepl("Ind6R$", Sample) ~ "6R",
        TRUE ~ NA_character_
      ),
      Condition = paste(Drug, Timepoint, sep = "_")
    )
  long_data$Condition <- factor(
    long_data$Condition,
    levels = c(
      "DOX_24T", 
      "DMSO_24T", 
      "DOX_24R", 
      "DMSO_24R", 
      "DOX_144R", 
      "DMSO_144R"
    )
  )
  return(long_data)
}


#Generate Boxplots from the above function using our gene list above
for (gene in top5_D24T_geneslist_1) {
  gene_data <- process_top5_D24T_1(gene)
  p <- ggplot(gene_data, aes(x = Condition, y = log2cpm, fill = Drug)) +
    geom_boxplot(outlier.shape = NA) +
    geom_point(aes(color = Indv), size = 2, alpha = 0.5, position = position_jitter(width = -1, height = 0)) +
    scale_fill_manual(values = c("DOX" = "#499FBD", "DMSO" = "#BBBBBC")) +
    ggtitle(paste("Log2cpm", gene, "top5DEGs D24T RUVs")) +
    labs(x = "Treatment", y = "log2cpm") +
    theme_bw() +
    theme(
      plot.title = element_text(size = rel(2), hjust = 0.5),
      axis.title = element_text(size = 15, color = "black"),
      axis.text.x = element_text(size = 10, color = "black", angle = 90, hjust = 1)
    )
  print(p)
}

#####D24R#####
process_top5_D24R_1 <- function(gene) {
  gene_data <- top5_D24R_genes_1 %>% filter(Entrez_ID == gene)
  long_data <- gene_data %>%
    pivot_longer(cols = -c(Entrez_ID, SYMBOL), names_to = "Sample", values_to = "log2cpm") %>%
    mutate(
      Drug = case_when(
        grepl("DOX", Sample) ~ "DOX",
        grepl("DMSO", Sample) ~ "DMSO",
        TRUE ~ NA_character_
      ),
      Timepoint = case_when(
        grepl("_24T_", Sample) ~ "24T",
        grepl("_24R_", Sample) ~ "24R",
        grepl("_144R_", Sample) ~ "144R",
        TRUE ~ NA_character_
      ),
      Indv = case_when(
        grepl("Ind1$", Sample) ~ "1",
        grepl("Ind2$", Sample) ~ "2",
        grepl("Ind3$", Sample) ~ "3",
        grepl("Ind4$", Sample) ~ "4",
        grepl("Ind5$", Sample) ~ "5",
        grepl("Ind6$", Sample) ~ "6",
        grepl("Ind6R$", Sample) ~ "6R",
        TRUE ~ NA_character_
      ),
      Condition = paste(Drug, Timepoint, sep = "_")
    )
  long_data$Condition <- factor(
    long_data$Condition,
    levels = c(
      "DOX_24T", 
      "DMSO_24T", 
      "DOX_24R", 
      "DMSO_24R", 
      "DOX_144R", 
      "DMSO_144R"
    )
  )
  return(long_data)
}


#Generate Boxplots from the above function using our gene list above
for (gene in top5_D24R_geneslist_1) {
  gene_data <- process_top5_D24R_1(gene)
  p <- ggplot(gene_data, aes(x = Condition, y = log2cpm, fill = Drug)) +
    geom_boxplot(outlier.shape = NA) +
    geom_point(aes(color = Indv), size = 2, alpha = 0.5, position = position_jitter(width = -1, height = 0)) +
    scale_fill_manual(values = c("DOX" = "#499FBD", "DMSO" = "#BBBBBC")) +
    ggtitle(paste("Log2cpm", gene, "top5DEGs D24R RUVs")) +
    labs(x = "Treatment", y = "log2cpm") +
    theme_bw() +
    theme(
      plot.title = element_text(size = rel(2), hjust = 0.5),
      axis.title = element_text(size = 15, color = "black"),
      axis.text.x = element_text(size = 10, color = "black", angle = 90, hjust = 1)
    )
  print(p)
}

#####D144R#####
process_top5_D144R_1 <- function(gene) {
  gene_data <- top5_D144R_genes_1 %>% filter(Entrez_ID == gene)
  long_data <- gene_data %>%
    pivot_longer(cols = -c(Entrez_ID, SYMBOL), names_to = "Sample", values_to = "log2cpm") %>%
    mutate(
      Drug = case_when(
        grepl("DOX", Sample) ~ "DOX",
        grepl("DMSO", Sample) ~ "DMSO",
        TRUE ~ NA_character_
      ),
      Timepoint = case_when(
        grepl("_24T_", Sample) ~ "24T",
        grepl("_24R_", Sample) ~ "24R",
        grepl("_144R_", Sample) ~ "144R",
        TRUE ~ NA_character_
      ),
      Indv = case_when(
        grepl("Ind1$", Sample) ~ "1",
        grepl("Ind2$", Sample) ~ "2",
        grepl("Ind3$", Sample) ~ "3",
        grepl("Ind4$", Sample) ~ "4",
        grepl("Ind5$", Sample) ~ "5",
        grepl("Ind6$", Sample) ~ "6",
        grepl("Ind6R$", Sample) ~ "6R",
        TRUE ~ NA_character_
      ),
      Condition = paste(Drug, Timepoint, sep = "_")
    )
  long_data$Condition <- factor(
    long_data$Condition,
    levels = c(
      "DOX_24T", 
      "DMSO_24T", 
      "DOX_24R", 
      "DMSO_24R", 
      "DOX_144R", 
      "DMSO_144R"
    )
  )
  return(long_data)
}


#Generate Boxplots from the above function using our gene list above
for (gene in top5_D144R_geneslist_1) {
  gene_data <- process_top5_D144R_1(gene)
  p <- ggplot(gene_data, aes(x = Condition, y = log2cpm, fill = Drug)) +
    geom_boxplot(outlier.shape = NA) +
    geom_point(aes(color = Indv), size = 2, alpha = 0.5, position = position_jitter(width = -1, height = 0)) +
    scale_fill_manual(values = c("DOX" = "#499FBD", "DMSO" = "#BBBBBC")) +
    ggtitle(paste("Log2cpm", gene, "top5DEGs D144R RUVs")) +
    labs(x = "Treatment", y = "log2cpm") +
    theme_bw() +
    theme(
      plot.title = element_text(size = rel(2), hjust = 0.5),
      axis.title = element_text(size = 15, color = "black"),
      axis.text.x = element_text(size = 10, color = "black", angle = 90, hjust = 1)
    )
  print(p)
}


```

```{r RUV logFC DEGs all Conditions}
# Toptable_RUV_24T
# Toptable_RUV_24R
# Toptable_RUV_144R

# Load DEGs Data
DOX_24T_1 <- read.csv("data/new/DEGs/Toptable_RUV_24T_final.csv")
DOX_24R_1 <- read.csv("data/new/DEGs/Toptable_RUV_24R_final.csv")
DOX_144R_1 <- read.csv("data/new/DEGs/Toptable_RUV_144R_final.csv")

#make a list of all of the genes in this set so I can plot the logFC in other sets
D24T_DEGs_1 <- DOX_24T_1$Entrez_ID[DOX_24T_1$adj.P.Val < 0.05]
length(D24T_DEGs_1)
#9243 genes

D24R_DEGs_1 <- DOX_24R_1$Entrez_ID[DOX_24R_1$adj.P.Val < 0.05]
length(D24R_DEGs_1)
#7168 genes

D144R_DEGs_1 <- DOX_144R_1$Entrez_ID[DOX_144R_1$adj.P.Val < 0.05]
length(D144R_DEGs_1)
#509 genes

#plot those full gene sets in logFC
D24T_DEGs_1 <- DOX_24T$Entrez_ID[DOX_24T$adj.P.Val < 0.05]
length(D24T_DEGs)

D24R_DEGs_1 <- DOX_24R$Entrez_ID[DOX_24R$adj.P.Val < 0.05]
length(D24R_DEGs)

D144R_DEGs_1 <- DOX_144R$Entrez_ID[DOX_144R$adj.P.Val < 0.05]
length(D144R_DEGs)
#now that I have the full list of genes, I want to plot the logFC across conditions


#Combine the toptables I have from pairwise analysis into a single dataframe
d24_toptable_dxr_1 <- Toptable_RUV_24T %>% 
  mutate(Time = "24")

d24r_toptable_dxr_1 <- Toptable_RUV_24R %>% 
  mutate(Time = "24R")

d144r_toptable_dxr_1 <- Toptable_RUV_144R %>% 
  mutate(Time = "144R")

combined_toptables_dxr_RUV <- bind_rows(
  d24_toptable_dxr_1,
  d24r_toptable_dxr_1,
  d144r_toptable_dxr_1)

#Filter the data based on each motif
filt_toptable_dxr_RUV <- combined_toptables_dxr_RUV %>% 
  dplyr::filter(Entrez_ID  %in% D24T_DEGs_1) %>% 
  mutate(absFC = abs(logFC)) %>% 
  mutate(time = factor(Time, levels = c("24", "24R", "144R"), labels = c("24hr", "24hr Recovery", "144hr Recovery"))) %>% 
  ggplot(., aes(x = time, y = logFC))+
  geom_boxplot(aes(fill = time))+
  scale_fill_manual(values = time_col)+
  guides(fill = guide_legend(title = "Time"))+
  theme_bw()+
  xlab(" ")+
  ylab("logFC")+
  theme_bw()+
  ggtitle("LogFC D24T DEGs Across Conditions RUVs")+
  theme(plot.title = element_text(size = rel(1.5), hjust = 0.5),
        axis.title = element_text(size = 15, colour = "black"),
        strip.background = element_rect(fill = "#CAD899"),
        axis.text.x = element_text(size = 8, colour = "white", angle = 15),
        strip.text.x = element_text(size = 12, colour = "black", face = "bold"))

#now do the same with the other conditions

filt_toptable_dxr_24r_RUV <- combined_toptables_dxr_RUV %>% 
  dplyr::filter(Entrez_ID  %in% D24R_DEGs_1) %>% 
  mutate(absFC = abs(logFC)) %>% 
  mutate(time = factor(Time, levels = c("24", "24R", "144R"), labels = c("24hr", "24hr Recovery", "144hr Recovery"))) %>% 
  ggplot(., aes(x = time, y = logFC))+
  geom_boxplot(aes(fill = time))+
  scale_fill_manual(values = time_col)+
  guides(fill = guide_legend(title = "Time"))+
  theme_bw()+
  xlab(" ")+
  ylab("logFC")+
  theme_bw()+
  ggtitle("LogFC D24R DEGs Across Conditions RUVs")+
  theme(plot.title = element_text(size = rel(1.5), hjust = 0.5),
        axis.title = element_text(size = 15, colour = "black"),
        strip.background = element_rect(fill = "#CAD899"),
        axis.text.x = element_text(size = 8, colour = "white", angle = 15),
        strip.text.x = element_text(size = 12, colour = "black", face = "bold"))

#D144R

filt_toptable_dxr_144r_RUV <- combined_toptables_dxr_RUV %>% 
  dplyr::filter(Entrez_ID  %in% D144R_DEGs_1) %>% 
  mutate(absFC = abs(logFC)) %>% 
  mutate(time = factor(Time, levels = c("24", "24R", "144R"), labels = c("24hr", "24hr Recovery", "144hr Recovery"))) %>% 
  ggplot(., aes(x = time, y = logFC))+
  geom_boxplot(aes(fill = time))+
  scale_fill_manual(values = time_col)+
  guides(fill = guide_legend(title = "Time"))+
  theme_bw()+
  xlab(" ")+
  ylab("logFC")+
  theme_bw()+
  ggtitle("LogFC D144R DEGs Across Conditions RUVs")+
  theme(plot.title = element_text(size = rel(1.5), hjust = 0.5),
        axis.title = element_text(size = 15, colour = "black"),
        strip.background = element_rect(fill = "#CAD899"),
        axis.text.x = element_text(size = 8, colour = "white", angle = 15),
        strip.text.x = element_text(size = 12, colour = "black", face = "bold"))

#now put the names of these graphs to print them
filt_toptable_dxr_RUV
filt_toptable_dxr_24r_RUV
filt_toptable_dxr_144r_RUV


```

```{r Volcano Plots RUVs Corrected k1}
#make a function to generate volcano plots + add gene numbers
#ensure the gene symbols are in a col so I can plot names of top 15
generate_volcano_plot_RUV <- function(toptable, title) {
  
  #make significance labels
  toptable$Significance <- "Not Significant"
  toptable$Significance[toptable$logFC > 0 & toptable$adj.P.Val < 0.05] <- "Upregulated"
  toptable$Significance[toptable$logFC < 0 & toptable$adj.P.Val < 0.05] <- "Downregulated"
  
  #add number of genes for each significance label
  upgenes <- toptable %>% filter(Significance == "Upregulated") %>% nrow()
  nsgenes <- toptable %>% filter(Significance == "Not Significant") %>% nrow()
  downgenes <- toptable %>% filter(Significance == "Downregulated") %>% nrow()

  #make legend labels for no of genes
  legend_lab <- c(
    str_c("Upregulated: ", upgenes),
    str_c("Not Significant: ", nsgenes),
    str_c("Downregulated: ", downgenes)
  )
  
  #specify the colors for the legend
  legend_col <- c(
    str_c("Upregulated: " = "blue"),
    str_c("Not Significant: " = "gray"),
    str_c("Downregulated: " = "red")
  )
  
  #add the top 15 genes by adj. p value
  top_genes <- toptable %>%
    filter(!is.na(SYMBOL)) %>%
    arrange(adj.P.Val) %>%
    slice_head(n = 15)
  
  #generate volcano plot w/ legend
  ggplot(toptable, aes(x = logFC, 
                       y = -log10(P.Value), 
                       color = Significance)) +
    geom_point(alpha = 0.4, size = 2) + 
    scale_color_manual(values = c("Upregulated" = "blue",
                                  "Not Significant" = "gray",
                                  "Downregulated" = "red"), 
                       labels = legend_lab) +
    xlim(-10, 10) +
    labs(title = title, 
         x = expression(x = "log"[2]*"FC"), 
         y = expression(y = "-log"[10]*"P-value")) +
    theme_bw()+
    guides(color = guide_legend(override.aes = list(color = legend_col)))+
    theme(legend.position = "right", 
          plot.title = element_text(size = rel(1.5), hjust = 0.5),
          axis.title = element_text(size = rel(1.25)))
}

#generate volcano plots across each comparison
volcano_plots_RUV <- list(
  "V.D24T_RUV" = generate_volcano_plot(Toptable_RUV_24T, "DOX 24T RUVs k=1 (adj P-val<0.05)"),
  "V.D24R_RUV" = generate_volcano_plot(Toptable_RUV_24R, "DOX 24R RUVs k=1 (adj P-val<0.05)"),
  "V.D144R_RUV" = generate_volcano_plot(Toptable_RUV_144R, "DOX 144R RUVs k=1 (adj P-val<0.05)")
)

# Display each volcano plot
for (plot_name in names(volcano_plots_RUV)) {
  print(volcano_plots_RUV[[plot_name]])
}


```


```{r DDR Genes logFC, fig.height=14, fig.width=8}
#DDR Gene Expression Heatmap  DOX Over Recovery Time (68 genes, with categories)

# Load libraries
# library(circlize)
# library(grid)
# library(reshape2)

# Load DEG files
load_deg <- function(path) read.csv(path)

DOX_24T <- load_deg("data/new/DEGs/Toptable_V.D24T.csv")
DOX_24R <- load_deg("data/new/DEGs/Toptable_V.D24R.csv")
DOX_144R <- load_deg("data/new/DEGs/Toptable_V.D144R.csv")

# Final Entrez IDs and categories (68 genes)
entrez_category_DDR <- tribble(
  ~ENTREZID, ~Category,
  317, "Apoptosis", 355, "Apoptosis", 581, "Apoptosis", 637, "Apoptosis",
  836, "Apoptosis", 841, "Apoptosis", 842, "Apoptosis", 27113, "Apoptosis",
  5366, "Apoptosis", 54205, "Apoptosis", 55367, "Apoptosis", 8795, "Apoptosis",
  1026, "Cell Cycle / Checkpoint", 1027, "Cell Cycle / Checkpoint", 595, "Cell Cycle / Checkpoint",
  894, "Cell Cycle / Checkpoint", 896, "Cell Cycle / Checkpoint", 898, "Cell Cycle / Checkpoint",
  9133, "Cell Cycle / Checkpoint", 9134, "Cell Cycle / Checkpoint", 891, "Cell Cycle / Checkpoint",
  983, "Cell Cycle / Checkpoint", 1017, "Cell Cycle / Checkpoint", 1019, "Cell Cycle / Checkpoint",
  1020, "Cell Cycle / Checkpoint", 1021, "Cell Cycle / Checkpoint", 993, "Cell Cycle / Checkpoint",
  995, "Cell Cycle / Checkpoint", 1869, "Cell Cycle / Checkpoint", 4609, "Cell Cycle / Checkpoint",
  5925, "Cell Cycle / Checkpoint", 9874, "Cell Cycle / Checkpoint", 11011, "Cell Cycle / Checkpoint",
  1385, "Cell Cycle / Checkpoint",
  472, "Damage Sensors / Signal Transducers", 545, "Damage Sensors / Signal Transducers",
  5591, "Damage Sensors / Signal Transducers", 5810, "Damage Sensors / Signal Transducers",
  5883, "Damage Sensors / Signal Transducers", 5884, "Damage Sensors / Signal Transducers",
  6118, "Damage Sensors / Signal Transducers", 4361, "Damage Sensors / Signal Transducers",
  10111, "Damage Sensors / Signal Transducers", 4683, "Damage Sensors / Signal Transducers",
  84126, "Damage Sensors / Signal Transducers", 3014, "Damage Sensors / Signal Transducers",
  672, "DNA Repair", 2177, "DNA Repair", 5888, "DNA Repair", 5893, "DNA Repair",
  1647, "DNA Repair", 4616, "DNA Repair", 10912, "DNA Repair", 1111, "DNA Repair",
  11200, "DNA Repair", 1643, "DNA Repair", 8243, "DNA Repair", 5981, "DNA Repair",
  7157, "p53 Regulators / Targets", 4193, "p53 Regulators / Targets", 5371, "p53 Regulators / Targets",
  27244, "p53 Regulators / Targets", 50484, "p53 Regulators / Targets",
  5916, "DOX Cardiotoxicity", 7799, "DOX Cardiotoxicity", 4292, "DOX Cardiotoxicity",
  207, "Miscellaneous / Broad", 25, "Miscellaneous / Broad"
)

entrez_ids_DDR <- entrez_category_DDR$ENTREZID

# Extract relevant DEG values
extract_data_DDR <- function(df, name) {
  df %>%
    filter(Entrez_ID %in% entrez_ids_DDR) %>%
    mutate(
      Gene = mapIds(org.Hs.eg.db, as.character(Entrez_ID),
                    column = "SYMBOL", keytype = "ENTREZID", multiVals = "first"),
      Condition = name,
      Signif = ifelse(adj.P.Val < 0.05, "*", "")
    )
}

# DEG list
deg_list <- list("DOX_24T" = DOX_24T, 
                 "DOX_24R" = DOX_24R, 
                 "DOX_144R" = DOX_144R
)

# Combine all DEGs and annotate
all_data_DDR <- bind_rows(mapply(extract_data_DDR, deg_list, names(deg_list), SIMPLIFY = FALSE)) %>%
  left_join(entrez_category_DDR, by = c("Entrez_ID" = "ENTREZID"))

# Create matrices
logFC_matddr <- acast(all_data_DDR, Gene ~ Condition, value.var = "logFC")
signif_matddr <- acast(all_data_DDR, Gene ~ Condition, value.var = "Signif")

# Set desired order
desired_order <- c("DOX_24T",
                   "DOX_24R",
                   "DOX_144R")

logFC_mat_DDR <- logFC_matddr[, desired_order, drop = FALSE]
signif_mat_DDR <- signif_matddr[, desired_order, drop = FALSE]

# Column annotation
meta_DDR <- str_split_fixed(colnames(logFC_mat_DDR), "_", 2)
col_annot <- HeatmapAnnotation(
  Drug = meta_DDR[, 1],
  Time = meta_DDR[, 2],
  col = list(
    Drug = c("DOX" = "#499FBD"),
    Time = c("24T" = "#238B45", 
             "24R" = "#74C476", 
             "144R" = "#C7E9C0")
  ),
  annotation_height = unit(c(1, 1, 1), "cm")
)

# Row annotation
gene_order_df_DDR <- all_data_DDR %>%
  distinct(Gene, Category) %>%
  arrange(factor(Category, levels = sort(unique(entrez_category_DDR$Category))), Gene)

ordered_genes_DDR <- gene_order_df_DDR$Gene
logFC_mat_DDR <- logFC_mat_DDR[ordered_genes_DDR, ]
signif_mat_DDR <- signif_mat_DDR[ordered_genes_DDR, ]

category_colors_DDR <- structure(
  c("darkorange", "steelblue", "darkgreen", "firebrick", "gold", "mediumpurple", "gray60"),
  names = sort(unique(entrez_category_DDR$Category))
)

ha_left_DDR <- rowAnnotation(
  Category = gene_order_df_DDR$Category,
  col = list(Category = category_colors_DDR),
  annotation_name_side = "top"
)

# Final Heatmap
Heatmap(logFC_mat_DDR,
        name = "logFC",
        top_annotation = col_annot,
        left_annotation = ha_left_DDR,
        cluster_columns = FALSE,
        cluster_rows = FALSE,
        show_row_names = TRUE,
        show_column_names = FALSE,
        row_names_gp = gpar(fontsize = 10),
        column_title = "DDR Gene Expression Response (n = 68)\n DOX Recovery",
        column_title_gp = gpar(fontsize = 14, fontface = "bold"),
        cell_fun = function(j, i, x, y, width, height, fill) {
          grid.text(signif_mat_DDR[i, j], x, y, gp = gpar(fontsize = 9))
        }
)
```

```{r DIC Genes logFC HM noRUVs}
#plot a list of 29 functionally validated DIC genes
# Load DEG files
load_deg <- function(path) read.csv(path)

DOX_24T <- load_deg("data/new/DEGs/Toptable_V.D24T.csv")
DOX_24R <- load_deg("data/new/DEGs/Toptable_V.D24R.csv")
DOX_144R <- load_deg("data/new/DEGs/Toptable_V.D144R.csv")

#the data I have is in hgnc_symbols, I want to convert this to entrez_id like my df
DIC_genes <- tribble(
  ~SYMBOL, ~Category,
  "CAT", "ROS Generation / Handling",
  "CBR1", "ROS Generation / Handling",
  "CBR3", "ROS Generation / Handling",
  "ERBB2", "ROS Generation / Handling",
  "GPX3", "ROS Generation / Handling",
  "GSTM1", "ROS Generation / Handling",
  "GSTP", "ROS Generation / Handling",
  "HAS3", "ROS Generation / Handling",
  "NOS3", "ROS Generation / Handling",
  "PLCE1", "ROS Generation / Handling",
  "RAC2", "ROS Generation / Handling",
  "SPG7", "ROS Generation / Handling",
  "PRDM2", "DNA Damage", 
  "MLH1", "DNA Damage",
  "RARG", "DNA Damage",
  "HFE", "Iron Uptake & Homeostasis",
  "SLC22A17", "DOX Uptake",
  "SLC28A1", "DOX Uptake",
  "SLC28A3", "DOX Uptake",
  "ABCB4", "DOX Efflux",
  "ABCC2", "DOX Efflux",
  "ABCC5", "DOX Efflux", 
  "ABCC9", "DOX Efflux",
  "ABCC10", "DOX Efflux",
  "CELF4", "Calcium Handling",
  "MYH7", "Calcium Handling",
  "CYP2J2", "Cardiac Electrical Activity",
  "RIN3", "Cardiac Electrical Activity",
  "ZFN521", "Cardiac Electrical Activity")

gene_df_DIC <- tibble(HGNC = DIC_genes)

gene_df_DIC <- gene_df_DIC %>% 
  mutate(Entrez_ID = mapIds(org.Hs.eg.db,
                            keys = DIC_genes$SYMBOL,
                            column = "ENTREZID", 
                            keytype = "SYMBOL", 
                            multiVals = "first")) %>% 
  unnest_wider(HGNC) %>% 
  mutate(Entrez_ID = as.character(Entrez_ID))

#now I've put together a dataframe with the HGNC, Category, and Entrez_ID
#plus I've ensured that Entrez_ID is a character for later joining

entrez_ids_DIC <- gene_df_DIC$Entrez_ID

# Extract relevant DEG values
extract_data_DIC <- function(df, name) {
  df %>%
    filter(Entrez_ID %in% entrez_ids_DIC) %>%
    mutate(
      Gene = mapIds(org.Hs.eg.db, as.character(Entrez_ID),
                    column = "SYMBOL", keytype = "ENTREZID", multiVals = "first"),
      Condition = name,
      Signif = ifelse(adj.P.Val < 0.05, "*", "")
    )
}

# DEG list
deg_list <- list("DOX_24T" = DOX_24T, 
                 "DOX_24R" = DOX_24R, 
                 "DOX_144R" = DOX_144R
)

# Combine all DEGs and annotate
all_data_DIC <- bind_rows(mapply(extract_data_DIC, 
                             deg_list, 
                             names(deg_list), 
                             SIMPLIFY = FALSE)) %>%
  mutate(Entrez_ID = as.character(Entrez_ID)) %>% 
  left_join(gene_df_DIC, 
            by = "Entrez_ID")
#I've also made sure here that Entrez_ID is a character and not an integer

# Create matrices
logFC_matdic <- acast(all_data_DIC, Gene ~ Condition, value.var = "logFC")
signif_matdic <- acast(all_data_DIC, Gene ~ Condition, value.var = "Signif")

# Set desired order
desired_order <- c("DOX_24T",
                   "DOX_24R",
                   "DOX_144R")

logFC_mat_DIC <- logFC_matdic[, desired_order, drop = FALSE]
signif_mat_DIC <- signif_matdic[, desired_order, drop = FALSE]

# Column annotation
meta_DIC <- str_split_fixed(colnames(logFC_mat_DIC), "_", 3)
meta_DIC <- str_split_fixed(colnames(logFC_mat_DIC), "_", 2)
col_annot <- HeatmapAnnotation(
  Drug = meta_DIC[, 1],
  Time = meta_DIC[, 2],
  col = list(
    Drug = c("DOX" = "#499FBD"),
    Time = c("24T" = "#238B45", 
             "24R" = "#74C476", 
             "144R" = "#C7E9C0")
  ),
  annotation_height = unit(c(2, 2, 2), "cm")
)
#for this I can leave off the DMSO as it's already from a pairwise comparison

#make an extra object with my category order as well
category_order_DIC <- c(
  "ROS Generation / Handling",
  "DNA Damage",
  "Calcium Handling",
  "DOX Uptake",
  "Iron Uptake & Homeostasis",
  "DOX Efflux",
  "Cardiac Electrical Activity"
)

# Row annotation
gene_order_df_DIC <- all_data_DIC %>%
  distinct(Gene, Category) %>%
  mutate(Category = factor(Category, levels = category_order_DIC)) %>% 
  arrange(Category, Gene)

ordered_genes_DIC <- gene_order_df_DIC$Gene
logFC_mat_DIC <- logFC_mat_DIC[ordered_genes_DIC, ]
signif_mat_DIC <- signif_mat_DIC[ordered_genes_DIC, ]

#add in your colors for each category
 category_colors_DIC <- structure(
  c("darkorange", "steelblue", "darkgreen", "firebrick", "gold", "mediumpurple", "gray60"),
  names = category_order_DIC
)

ha_left_DIC <- rowAnnotation(
  Category = gene_order_df_DIC$Category,
  col = list(Category = category_colors_DIC),
  annotation_name_side = "top"
)

# Draw heatmap
Heatmap(logFC_mat_DIC,
        name = "logFC",
        top_annotation = col_annot,
        left_annotation = ha_left_DIC,
        cluster_columns = FALSE,
        cluster_rows = FALSE,
        show_row_names = TRUE,
        show_column_names = FALSE,
        cell_fun = function(j, i, x, y, width, height, fill) {
          grid.text(signif_mat_DIC[i, j], x, y, gp = gpar(fontsize = 9))
        },
        column_title = "DIC Genes Expression (n=29)\nDOX Recovery",
        column_title_gp = gpar(fontsize = 14, fontface = "bold")
)


```

```{r p53 Target Genes logFC HM, fig.height=12, fig.width=10}
# Load libraries
library(tidyverse)
library(ComplexHeatmap)
library(circlize)
library(grid)
library(org.Hs.eg.db)
library(reshape2)

# Load DEG files
load_deg <- function(path) read.csv(path)

DOX_24T <- load_deg("data/new/DEGs/Toptable_V.D24T.csv")
DOX_24R <- load_deg("data/new/DEGs/Toptable_V.D24R.csv")
DOX_144R <- load_deg("data/new/DEGs/Toptable_V.D144R.csv")

#P53 target Entrez_ID
entrez_ids_p53 <- c(1026,50484,4193,9766,9518,7832,1643,1647,1263,57103,51065,8795,51499,64393,581,
                5228,5429,8493,55959,7508,64782,282991,355,53836,4814,10769,9050,27244,9540,94241,
                26154,57763,900,26999,55332,26263,23479,23612,29950,9618,10346,8824,134147,55294,
                22824,4254,6560,467,27113,60492,8444,60401,1969,220965,2232,3976,55191,84284,93129,
                5564,7803,83667,7779,132671,7039,51768,137695,93134,7633,10973,340485,307,27350,
                23245,3732,29965,1363,1435,196513,8507,8061,2517,51278,53354,54858,23228,5366,5912,
                6236,51222,26152,59,1907,50650,91012,780,9249,11072,144455,64787,116151,27165,2876,
                57822,55733,57722,121457,375449,85377,4851,5875,127544,29901,84958,8797,8793,441631,
                220001,54541,5889,5054,25816,25987,5111,98,317,598,604,10904,1294,80315,53944,
                1606,2770,3628,3675,3985,4035,4163,84552,29085,55367,5371,5791,54884,5980,8794,
                1462,50808,220,583,694,1056,9076,10978,54677,1612,55040,114907,2274,127707,4000,
                8079,4646,4747,27445,5143,80055,79156,5360,5364,23654,5565,5613,5625,10076,56963,
                6004,390,255488,6326,6330,23513,7869,283130,204962,83959,6548,6774,9263,10228,
                22954,10475,85363,494514,10142,79714,1006,8446,9648,79828,5507,55240,63874,25841,
                9289,84883,154810,51321,421,8553,655,119032,84280,10950,824,839,57828,857,8812,
                8837,94027,113189,22837,132864,10898,3300,81704,1847,1849,1947,9538,24139,5168,
                147965,115548,9873,23768,2632,2817,3280,3265,23308,3490,51477,182,3856,8844,144811,
                9404,4043,9848,2872,23041,740,343263,4638,26509,4792,22861,57523,55214,80025,164091,
                57060,64065,51090,5453,8496,333926,55671,5900,55544,23179,8601,389,6223,55800,6385,
                4088,6643,122809,257397,285343,7011,54790,374618,55362,51754,7157,9537,22906,7205,
                80705,219699,55245,83719,7748,25946,118738)

# Function to extract relevant data
extract_data_p53 <- function(df, name) {
  df %>%
    filter(Entrez_ID %in% entrez_ids_p53) %>%
    mutate(Gene = mapIds(org.Hs.eg.db, as.character(Entrez_ID),
                         column = "SYMBOL", keytype = "ENTREZID", multiVals = "first"),
           Condition = name,
           Signif = ifelse(adj.P.Val < 0.05, "*", ""))
}

# Collect all data
# DEG list
deg_list <- list("DOX_24T" = DOX_24T, 
                 "DOX_24R" = DOX_24R, 
                 "DOX_144R" = DOX_144R
)

# Combine all DEGs and annotate
all_data_p53 <- bind_rows(mapply(extract_data_p53, deg_list, names(deg_list), SIMPLIFY = FALSE)) 
#unnecessary to join again as there are not categories on this list of entrezids
# %>%
#   left_join(entrez_ids, by = c("Entrez_ID" = "ENTREZID"))

# Create matrices
logFC_mat53 <- acast(all_data_p53, Gene ~ Condition, value.var = "logFC")
signif_mat53 <- acast(all_data_p53, Gene ~ Condition, value.var = "Signif")

# Desired column order
desired_order <- c("DOX_24T",
                   "DOX_24R",
                   "DOX_144R")

logFC_mat_p53 <- logFC_mat53[, desired_order]
signif_mat_p53 <- signif_mat53[, desired_order]

# Column annotation
meta_p53 <- str_split_fixed(colnames(logFC_mat_p53), "_", 3)
meta_p53 <- str_split_fixed(colnames(logFC_mat_p53), "_", 2)
col_annot <- HeatmapAnnotation(
  Drug = meta_p53[, 1],
  Time = meta_p53[, 2],
  col = list(
    Drug = c("DOX" = "#499FBD"),
    Time = c("24T" = "#238B45", 
             "24R" = "#74C476", 
             "144R" = "#C7E9C0")
  ),
  annotation_height = unit(c(1, 1, 1), "cm")
)

# Draw heatmap
Heatmap(logFC_mat_p53,
        name = "logFC",
        top_annotation = col_annot,
        cluster_columns = FALSE,
        cluster_rows = TRUE,
        show_row_names = TRUE,
        show_column_names = FALSE,
        layer_fun = function(j, i, x, y, width, height, fill) {
          grid.text(signif_mat_p53[cbind(i, j)], x, y, gp = gpar(fontsize = 9))
        },
        column_title = "P53 Target Genes Expression\nDOX Recovery",
        column_title_gp = gpar(fontsize = 14, fontface = "bold")
)

```


```{r AIC LogFC Plots, fig.height=14, fig.width=8}
# #load in the appropriate files
# deg_files <- list(
#   "DOX_24T" = "data/new/DEGs/Toptable_V.D24T.csv",
#   "DOX_24R" = "data/new/DEGs/Toptable_V.D24R.csv",
#   "DOX_144R" = "data/new/DEGs/Toptable_V.D144R.csv"
# )
# 
# 
# # ----------------- AC Cardiotoxicity Entrez IDs -----------------
# entrez_ids <- c(
#   6272, 8029, 11128, 79899, 54477, 121665, 5095, 22863, 57161, 4692,
#   8214, 23151, 56606, 108, 22999, 56895, 9603, 3181, 4023, 10499,
#   92949, 4363, 10057, 5243, 5244, 5880, 1535, 2950, 847, 5447,
#   3038, 3077, 4846, 3958, 23327, 29899, 23155, 80856, 55020, 78996,
#   23262, 150383, 9620, 79730, 344595, 5066, 6251, 3482, 9588, 339416,
#   7292, 55157, 87769, 23409, 720, 3107, 54535, 1590, 80059, 7991,
#   57110, 8803, 323, 54826, 5916, 23371, 283337, 64078, 80010, 1933,
#   10818, 51020
# ) %>% as.character()
# 
# #load in my DE genes and filter them by the entrez id
# 
# ac_data_list <- map2_dfr(deg_files, names(deg_files), function(file, label) {
#   read_csv(file, show_col_types = FALSE) %>%
#     mutate(
#       Entrez_ID = as.character(Entrez_ID),
#       Condition = label,
#       Condition = ifelse(str_detect(label, "DOX"), "CX.5461", "DOX")
#     ) %>%
#     filter(Entrez_ID %in% entrez_ids)
# })
# 
# #create full gene  condition table
# all_conditions <- names(deg_files)
# all_combos <- crossing(
#   Entrez_ID = entrez_ids %>% as.character(),
#   Condition = all_conditions
# ) %>%
#   mutate(
#     Drug = ifelse(str_detect(Condition, "CX"), "CX.5461", "DOX")
#   )
# 
# # ----------------- Merge and Fill Missing Values -----------------
# complete_ac <- all_combos %>%
#   left_join(ac_data_list, by = c("Entrez_ID", "Condition", "Drug")) %>%
#   mutate(
#     logFC = ifelse(is.na(logFC), 0, logFC),
#     adj.P.Val = ifelse(is.na(adj.P.Val), 1, adj.P.Val)
#   )
# 
# # ----------------- Annotate Gene Symbols -----------------
# complete_ac <- complete_ac %>%
#   mutate(
#     Gene = mapIds(org.Hs.eg.db, keys = Entrez_ID,
#                   column = "SYMBOL", keytype = "ENTREZID", multiVals = "first")
#   )
# 
# # ----------------- Order Conditions -----------------
# complete_ac$Condition <- factor(complete_ac$Condition, levels = c(
#   "CX_0.1_3", "CX_0.1_24", "CX_0.1_48",
#   "CX_0.5_3", "CX_0.5_24", "CX_0.5_48",
#   "DOX_0.1_3", "DOX_0.1_24", "DOX_0.1_48",
#   "DOX_0.5_3", "DOX_0.5_24", "DOX_0.5_48"
# ))
# 
# # ----------------- Wilcoxon Test: CX vs DOX (paired by condition) -----------------
# condition_pairs <- tibble(
#   cx = c("CX_0.1_3", "CX_0.1_24", "CX_0.1_48", "CX_0.5_3", "CX_0.5_24", "CX_0.5_48"),
#   dox = c("DOX_0.1_3", "DOX_0.1_24", "DOX_0.1_48", "DOX_0.5_3", "DOX_0.5_24", "DOX_0.5_48")
# )
# 
# wilcox_results <- map2_dfr(condition_pairs$cx, condition_pairs$dox, function(cx_label, dox_label) {
#   cx_vals <- complete_ac %>% filter(Condition == cx_label) %>% pull(logFC)
#   dox_vals <- complete_ac %>% filter(Condition == dox_label) %>% pull(logFC)
#   
#   test <- tryCatch(wilcox.test(cx_vals, dox_vals), error = function(e) NULL)
#   pval <- if (!is.null(test)) test$p.value else NA
#   
#   tibble(
#     Condition = dox_label,
#     p_value = signif(pval, 3),
#     label = case_when(
#       pval < 0.001 ~ "***",
#       pval < 0.01  ~ "**",
#       pval < 0.05  ~ "*",
#       TRUE         ~ ""
#     ),
#     y_pos = max(c(cx_vals, dox_vals), na.rm = TRUE) + 0.5
#   )
# })
# 
# # ----------------- Plot Boxplot with Wilcoxon Stars -----------------
# ggplot(complete_ac, aes(x = Condition, y = logFC, fill = Drug)) +
#   geom_boxplot(outlier.size = 0.6) +
#   geom_text(data = wilcox_results,
#             aes(x = Condition, y = y_pos, label = label),
#             inherit.aes = FALSE,
#             size = 4, vjust = 0) +
#   scale_fill_manual(values = c("CX.5461" = "blue", "DOX" = "red")) +
#   labs(
#     title = "LogFC of AC Cardiotoxicity Genes",
#     x = "Condition",
#     y = "logFC",
#     fill = "Drug"
#   ) +
#   theme_bw(base_size = 14) +
#   theme(
#     plot.title = element_text(size = rel(1.5), hjust = 0.5),
#     axis.title = element_text(size = 14),
#     axis.text.x = element_text(angle = 45, hjust = 1, size = 10),
#     legend.title = element_text(size = 14),
#     legend.text = element_text(size = 12)
#   )

```

```{r Overlap of DEGs Original}
#plot a venn diagram with all of your conditions from your toptables

# Load DEGs Data
DOX_24T <- read.csv("data/new/DEGs/Toptable_V.D24T.csv")
DOX_24R <- read.csv("data/new/DEGs/Toptable_V.D24R.csv")
DOX_144R <- read.csv("data/new/DEGs/Toptable_V.D144R.csv")

# Extract Significant DEGs
DEG1 <- DOX_24T$Entrez_ID[DOX_24T$adj.P.Val < 0.05]
DEG2 <- DOX_24R$Entrez_ID[DOX_24R$adj.P.Val < 0.05]
DEG3 <- DOX_144R$Entrez_ID[DOX_144R$adj.P.Val < 0.05]


venntest <- list(DEG1, DEG2, DEG3)
ggVennDiagram(
  venntest,
  category.names = c("DOX_24T", "DOX_24R", "DOX_144R")
) + ggtitle("DXR Specific and Shared DEGs")+
  theme(
    plot.title = element_text(size = 16, face = "bold"),  # Increase title size
    text = element_text(size = 16)  # Increase text size globally
  )

#Now that I've made my venn diagram, I want to compare these DEGs
#set 1 : 4362 DOX24T specific genes
#set2 : 4362 + 4550 + 50 + 272 genes shared across DOX24T (all genes)
#how many of these are downregulated and how many are upregulated?

# Extract Significant DEGs
# Create a list of DEGs for each sample

# Example gene sets

DEG1 <- DOX_24T$Entrez_ID[DOX_24T$adj.P.Val < 0.05]
DEG2 <- DOX_24R$Entrez_ID[DOX_24R$adj.P.Val < 0.05]
DEG3 <- DOX_144R$Entrez_ID[DOX_144R$adj.P.Val < 0.05]

#try and use the VennDetail package to extract the genes from each condition
#Set 1 - DOX_24T only genes
#Set 2 - DOX_24T shared genes
plot.new()
venn_test <- venndetail(venntest)
plot(venn_test)
detail(venn_test)
#now that I have the genes subsetted by condition, I can pull out the genes I want to look at

venn_DOX_24T <- getSet(object = venn_test, subset = c("Group 1"))
dim(venn_DOX_24T)
#4362 genes in DOX_24T only

venn_DOX_shared <- getSet(object = venn_test, subset = c("Shared", "Group 1", "Group 1_Group 2", "Group 1_Group 3"))
dim(venn_DOX_shared)
#total of 9243 genes:
  #4559 DOX_24T only 
  #272 shared all
  #50 DOX_24T + DOX_144R
  #4362 DOX_24T + DOX_24R

venn_DOX144R_shared <- getSet(object = venn_test, subset = c("Shared", "Group 3", "Group 2_Group 3", "Group 1_Group 3"))
dim(venn_DOX144R_shared)
#total of 509 genes:
 #272 shared all
 #32 DOX144R Specific
 #50 DOX24T + DOX144R
 #155 DOX24R + DOX144R

#now I can look at these sets to see which ones are up and down regulated in each
#after that, run GO analysis
venn_shared_DEGs <- venn_DOX_shared %>% 
  as.data.frame() %>% 
  column_to_rownames(., var = "Detail")

venn_sharedD144R_DEGs <- venn_DOX144R_shared %>% 
  as.data.frame() %>% 
  column_to_rownames(., var = "Detail")

venn_DOX24T_DEGs <- venn_DOX_24T %>% 
  as.data.frame() %>% 
  column_to_rownames(., var = "Detail")


#pull these genes out of my DEG matrix with logFC
DOX_24T_DEGs <- Toptable_list$V.D24T[row.names(venn_DOX24T_DEGs),]
DOX_24T_shared_DEGs <- Toptable_list$V.D24T[row.names(venn_shared_DEGs),]
DOX_144R_shared_DEGs <- Toptable_list$V.D144R[row.names(venn_sharedD144R_DEGs),]
#I want to go ahead and do this for every condition so I can see the genes in there
#I also want to filter these by their logFC being up or down for GO/KEGG

DOX24T_DEGs_GO <- DOX_24T_DEGs %>% 
  dplyr::filter(., adj.P.Val < 0.05)

DOX24T_DEGs_GO_up <- DOX24T_DEGs_GO %>% 
  dplyr::filter(., logFC > 0)  %>% 
  rownames_to_column(., var = "entrezgene_ID") %>% 
  dplyr::select("entrezgene_ID")
#has 4029 genes

DOX24T_DEGs_GO_down <- DOX24T_DEGs_GO %>% 
  dplyr::filter(., logFC < 0)  %>% 
  rownames_to_column(., var = "entrezgene_ID") %>% 
  dplyr::select("entrezgene_ID")
#has 4305 genes

#shared genes venn diagram
DOX24Tshare_DEGs_GO <- DOX_24T_shared_DEGs %>% 
  dplyr::filter(., adj.P.Val < 0.05) 

DOX24T_share_DEGs_GO_plot <- DOX24Tshare_DEGs_GO %>% 
  rownames_to_column(., var = "Entrez_ID") %>% 
  dplyr::select("Entrez_ID")

DOX24Tshare_DEGs_GO_up <- DOX24Tshare_DEGs_GO %>% 
  dplyr::filter(., logFC > 0)  %>% 
  rownames_to_column(., var = "entrezgene_ID") %>% 
  dplyr::select("entrezgene_ID")
#has 4731 genes

DOX24Tshare_DEGs_GO_down <- DOX24Tshare_DEGs_GO %>% 
  dplyr::filter(., logFC < 0)  %>% 
  rownames_to_column(., var = "entrezgene_ID") %>% 
  dplyr::select("entrezgene_ID")

DOX144Rshare_DEGs_GO <- DOX_144R_shared_DEGs %>% 
  dplyr::filter(., adj.P.Val < 0.05)

DOX144Rshare_DEGs_GO_plot <- DOX144Rshare_DEGs_GO %>% 
  rownames_to_column(., var = "Entrez_ID") %>% 
  dplyr::select("Entrez_ID")


#now go ahead and do this for each condition as well

#DOX24T
venn_DOX_24T <- getSet(object = venn_test, subset = c("Group 1"))
dim(venn_DOX_24T)
#4362 genes in DOX_24T only

venn_DOX24T_DEGs <- venn_DOX_24T %>% 
  as.data.frame() %>% 
  column_to_rownames(., var = "Detail")

#pull these genes out of my DEG matrix with logFC
DOX_24T_DEGs <- Toptable_list$V.D24T[row.names(venn_DOX24T_DEGs),]

DOX24T_DEGs_GO <- DOX_24T_DEGs %>% 
  rownames_to_column(., var = "Entrez_ID") %>% 
  dplyr::filter(., adj.P.Val < 0.05) %>% 
  dplyr::select("Entrez_ID")

#DOX24R
venn_DOX_24R <- getSet(object = venn_test, subset = c("Group 2"))
dim(venn_DOX_24R)
#2182 genes in DOX_24R only

venn_DOX24R_DEGs <- venn_DOX_24R %>% 
  as.data.frame() %>% 
  column_to_rownames(., var = "Detail")

#pull these genes out of my DEG matrix with logFC
DOX_24R_DEGs <- Toptable_list$V.D24R[row.names(venn_DOX24R_DEGs),]

DOX24R_DEGs_GO <- DOX_24R_DEGs %>% 
  rownames_to_column(., var = "Entrez_ID") %>% 
  dplyr::filter(., adj.P.Val < 0.05) %>% 
  dplyr::select("Entrez_ID")


#DOX144R
venn_DOX_144R <- getSet(object = venn_test, subset = c("Group 3"))
dim(venn_DOX_144R)
#32 genes in DOX_144R only

venn_DOX144R_DEGs <- venn_DOX_144R %>% 
  as.data.frame() %>% 
  column_to_rownames(., var = "Detail")

#pull these genes out of my DEG matrix with logFC
DOX_144R_DEGs <- Toptable_list$V.D144R[row.names(venn_DOX144R_DEGs),]

DOX144R_DEGs_GO <- DOX_144R_DEGs %>% 
  rownames_to_column(., var = "Entrez_ID") %>% 
  dplyr::filter(., adj.P.Val < 0.05) %>% 
  dplyr::select("Entrez_ID")

#this set doesn't yield a GO/KEGG plot as there are too few genes
#instead, I pulled all genes associated with DOX144R

```


```{r RUVs Overlap of DEGs}
#plot a venn diagram with all of your conditions from your toptables

# Load DEGs Data
DOX_24T_1 <- read.csv("data/new/DEGs/TTBL_RUV_24T_OLD.csv")
DOX_24R_1 <- read.csv("data/new/DEGs/TTBL_RUV_24R_OLD.csv")
DOX_144R_1 <- read.csv("data/new/DEGs/TTBL_RUV_144R_OLD.csv")

# Extract Significant DEGs
DEG1_RUV <- DOX_24T_1$Entrez_ID[DOX_24T_1$adj.P.Val < 0.05]
DEG2_RUV <- DOX_24R_1$Entrez_ID[DOX_24R_1$adj.P.Val < 0.05]
DEG3_RUV <- DOX_144R_1$Entrez_ID[DOX_144R_1$adj.P.Val < 0.05]

venntest_RUV <- list(DEG1_RUV, DEG2_RUV, DEG3_RUV)
ggVennDiagram(
  venntest_RUV,
  category.names = c("DOX_24T", "DOX_24R", "DOX_144R")
) + ggtitle("DXR Specific and Shared DEGs RUVs")+
  theme(
    plot.title = element_text(size = 16, face = "bold"),  # Increase title size
    text = element_text(size = 16)  # Increase text size globally
  )

#try and use the VennDetail package to extract the genes from each condition
#Set 1 - DOX_24T only genes
#Set 2 - DOX_24T shared genes
#Set 3 - DOX_144R shared genes
plot.new()
venn_test_RUV <- venndetail(venntest_RUV)
plot(venn_test_RUV)
detail(venn_test_RUV)
#now that I have the genes subsetted by condition, I can pull out the genes I want to look at

venn_DOX_24T_RUV <- getSet(object = venn_test_RUV, subset = c("Group 1"))
dim(venn_DOX_24T_RUV)
#4411 genes in DOX_24T only

venn_DOX_shared_RUV <- getSet(object = venn_test_RUV, subset = c("Shared", "Group 1_Group 2", "Group 1_Group 3"))
dim(venn_DOX_shared_RUV)
#total of 5009 genes in this set which does not include D24T specific genes

venn_DOX144R_shared_RUV <- getSet(object = venn_test_RUV, subset = c("Shared", "Group 3", "Group 2_Group 3", "Group 1_Group 3"))
dim(venn_DOX144R_shared_RUV)
#total of 660 genes: (original 509)
 #342 shared all
 #32 DOX144R Specific
 #85 DOX24T + DOX144R
 #181 DOX24R + DOX144R

#after that, run GO analysis
venn_shared_DEGs_RUV <- venn_DOX_shared_RUV %>% 
  as.data.frame() %>% 
  column_to_rownames(., var = "Detail")

venn_DOX24T_DEGs_RUV <- venn_DOX_24T_RUV %>% 
  as.data.frame() %>% 
  column_to_rownames(., var = "Detail")

venn_sharedD144R_DEGs_RUV <- venn_DOX144R_shared_RUV %>% 
  as.data.frame() %>% 
  column_to_rownames(., var = "Detail")

#pull these genes out of my DEG matrix with logFC
DOX_24T_DEGs_RUV <-
  Toptable_list_RUVk1_symbols$V.D24T_RUV[row.names(venn_DOX24T_DEGs_RUV),]
DOX_24T_shared_DEGs_RUV <- 
  Toptable_list_RUVk1_symbols$V.D24T_RUV[row.names(venn_shared_DEGs_RUV),]
DOX_144R_shared_DEGs_RUV <- 
  Toptable_list_RUVk1_symbols$V.D144R_RUV[row.names(venn_sharedD144R_DEGs_RUV),]

#next, make the vectors that I need for plotting after cutting off by adj. p value < 0.05
DOX24T_DEGs_GO_RUV <- DOX_24T_DEGs_RUV %>% 
  dplyr::filter(., adj.P.Val < 0.05)

#shared D24T genes venn diagram
DOX24Tshare_DEGs_GO_RUV <- DOX_24T_shared_DEGs_RUV %>% 
  dplyr::filter(., adj.P.Val < 0.05) 

DOX24T_share_DEGs_GO_plot_RUV <- DOX24Tshare_DEGs_GO_RUV %>% 
  dplyr::select("Entrez_ID")

#shared D144R genes venn diagram

DOX144Rshare_DEGs_GO_RUV <- DOX_144R_shared_DEGs_RUV %>% 
  dplyr::filter(., adj.P.Val < 0.05)

DOX144Rshare_DEGs_GO_plot_RUV <- DOX144Rshare_DEGs_GO_RUV %>% 
  dplyr::select("Entrez_ID")

#now go ahead and do this for each condition as well

#DOX24T
venn_DOX_24T_RUV <- getSet(object = venn_test_RUV, subset = c("Group 1"))
dim(venn_DOX_24T_RUV)
#4411 genes in DOX_24T only

venn_DOX24T_DEGs_RUV <- venn_DOX_24T_RUV %>% 
  as.data.frame() %>% 
  column_to_rownames(., var = "Detail")

#pull these genes out of my DEG matrix with logFC
DOX_24T_DEGs_RUV <- Toptable_list_RUVk1_symbols$V.D24T_RUV[row.names(venn_DOX24T_DEGs_RUV),]

DOX24T_DEGs_GO_RUV <- DOX_24T_DEGs_RUV %>% 
  dplyr::filter(., adj.P.Val < 0.05) %>% 
  dplyr::select("Entrez_ID")

#DOX24R
venn_DOX_24R_RUV <- getSet(object = venn_test_RUV, subset = c("Group 2"))
dim(venn_DOX_24R_RUV)
#2107 genes in DOX_24R only

venn_DOX24R_DEGs_RUV <- venn_DOX_24R_RUV %>% 
  as.data.frame() %>% 
  column_to_rownames(., var = "Detail")

#pull these genes out of my DEG matrix with logFC
DOX_24R_DEGs_RUV <- Toptable_list_RUVk1_symbols$V.D24R_RUV[row.names(venn_DOX24R_DEGs_RUV),]

DOX24R_DEGs_GO_RUV <- DOX_24R_DEGs_RUV %>% 
  dplyr::filter(., adj.P.Val < 0.05) %>% 
  dplyr::select("Entrez_ID")


#DOX144R
venn_DOX_144R_RUV <- getSet(object = venn_test_RUV, subset = c("Group 3"))
dim(venn_DOX_144R_RUV)
#52 genes in DOX_144R only

venn_DOX144R_DEGs_RUV <- venn_DOX_144R_RUV %>% 
  as.data.frame() %>% 
  column_to_rownames(., var = "Detail")

#pull these genes out of my DEG matrix with logFC
DOX_144R_DEGs_RUV <- 
  Toptable_list_RUVk1_symbols$V.D144R_RUV[row.names(venn_DOX144R_DEGs_RUV),]

DOX144R_DEGs_GO_RUV <- DOX_144R_DEGs_RUV %>% 
  dplyr::filter(., adj.P.Val < 0.05) %>% 
  dplyr::select("Entrez_ID")
```

```{r GO KEGG Overlap DEGs Original}
#####DOX24 Genes#####
library(gprofiler2)

D24_DEGs_mat <- as.matrix(DOX24T_DEGs_GO)

DOX_24_dxr_gene <- gost(query = D24_DEGs_mat,
                      organism = "hsapiens",
                      ordered_query = FALSE,
                      measure_underrepresentation = FALSE,
                      evcodes = FALSE,
                      user_threshold = 0.05,
                      correction_method = c("fdr"),
                      sources = c("GO:BP", "KEGG"))

DOX_24_gost_genes <- gostplot(DOX_24_dxr_gene, capped = FALSE, interactive = TRUE)
DOX_24_gost_genes

table_DOX24_genes <- DOX_24_dxr_gene$result %>% 
  dplyr::select(c(source, term_id, term_name, intersection_size, term_size, p_value))

table_DOX24_genes %>% 
  mutate_at(.vars = 6, .funs = scales::label_scientific(digits=4)) %>% 
  kableExtra::kable(.,) %>% 
  kableExtra::kable_paper("striped", full_width = FALSE) %>% 
  kableExtra::kable_styling(full_width = FALSE, position = "left", bootstrap_options = c("striped", "hover")) %>% 
  kableExtra::scroll_box(width = "100%", height = "400px")

write.csv(table_DOX24_genes, "output/table_DOX24_genes.csv")

#GO:BP
table_DOX24_genes_GOBP <- table_DOX24_genes %>% 
  dplyr::filter(source=="GO:BP") %>% 
  dplyr::select(p_value, term_name, intersection_size) %>% 
  dplyr::slice_min(., n=10, order_by=p_value) %>% 
  mutate(log_val = -log10(p_value))


table_DOX24_genes_GOBP %>% ggplot(., aes(x = log_val, y = reorder(term_name, p_value), col= intersection_size)) +
  geom_point(aes(size = intersection_size)) +
  ggtitle("DOX24T Specific DEGs Enriched GO:BP Terms")+
  xlab(expression("-log"[10]~"p-value"))+
  guides(col="none", size= guide_legend(title = "# of intersected \n terms"))+
  ylab("GO:BP term")+
  scale_y_discrete(labels = scales::label_wrap(30))+
  theme_bw()+
  theme(plot.title = element_text(size = rel(1.5), hjust = 0.5),
        axis.title = element_text(size = 15, colour = "black"),
        axis.ticks = element_line(linewidth = 1.5),
        axis.line = element_line(linewidth = 1.5),
        axis.text = element_text(size = 10, colour = "black", angle = 0),
        strip.text = element_text(size = 15, colour = "black", face = "bold"))

#KEGG
table_DOX24_genes_KEGG <- table_DOX24_genes %>% 
  dplyr::filter(source=="KEGG") %>% 
  dplyr::select(p_value, term_name, intersection_size) %>% 
  dplyr::slice_min(., n=10, order_by=p_value) %>% 
  mutate(log_val = -log10(p_value))

table_DOX24_genes_KEGG %>% ggplot(., aes(x = log_val, y = reorder(term_name, p_value), col= intersection_size)) +
  geom_point(aes(size = intersection_size)) +
  ggtitle("DOX24T Specific DEGs Enriched KEGG Terms")+
  xlab(expression("-log"[10]~"p-value"))+
  guides(col="none", size= guide_legend(title = "# of intersected \n terms"))+
  ylab("KEGG term")+
  scale_y_discrete(labels = scales::label_wrap(30))+
  theme_bw()+
  theme(plot.title = element_text(size = rel(1.5), hjust = 0.5),
        axis.title = element_text(size = 15, colour = "black"),
        axis.ticks = element_line(linewidth = 1.5),
        axis.line = element_line(linewidth = 1.5),
        axis.text = element_text(size = 10, colour = "black", angle = 0),
        strip.text = element_text(size = 15, colour = "black", face = "bold"))


#####DOX24T shared DEGs GO KEGG#####
D24Tshare_DEGs_mat <- as.matrix(DOX24T_share_DEGs_GO_plot)

DOX_24Tshare_dxr_gene <- gost(query = D24Tshare_DEGs_mat,
                      organism = "hsapiens",
                      ordered_query = FALSE,
                      measure_underrepresentation = FALSE,
                      evcodes = FALSE,
                      user_threshold = 0.05,
                      correction_method = c("fdr"),
                      sources = c("GO:BP", "KEGG"))

DOX_24Tshare_gost_genes <- gostplot(DOX_24Tshare_dxr_gene, capped = FALSE, interactive = TRUE)
DOX_24Tshare_gost_genes

table_DOX24Tshare_genes <- DOX_24Tshare_dxr_gene$result %>% 
  dplyr::select(c(source, term_id, term_name, intersection_size, term_size, p_value))

table_DOX24Tshare_genes %>% 
  mutate_at(.vars = 6, .funs = scales::label_scientific(digits=4)) %>% 
  kableExtra::kable(.,) %>% 
  kableExtra::kable_paper("striped", full_width = FALSE) %>% 
  kableExtra::kable_styling(full_width = FALSE, position = "left", bootstrap_options = c("striped", "hover")) %>% 
  kableExtra::scroll_box(width = "100%", height = "400px")

#GO:BP
table_DOX24Tshare_genes_GOBP <- table_DOX24Tshare_genes %>% 
  dplyr::filter(source=="GO:BP") %>% 
  dplyr::select(p_value, term_name, intersection_size) %>% 
  dplyr::slice_min(., n=10, order_by=p_value) %>% 
  mutate(log_val = -log10(p_value))

table_DOX24Tshare_genes_GOBP %>% ggplot(., aes(x = log_val, y = reorder(term_name, p_value), col= intersection_size)) +
  geom_point(aes(size = intersection_size)) +
  ggtitle("DOX24T Shared DEGs Enriched GO:BP Terms")+
  xlab(expression("-log"[10]~"p-value"))+
  guides(col="none", size= guide_legend(title = "# of intersected \n terms"))+
  ylab("GO:BP term")+
  scale_y_discrete(labels = scales::label_wrap(30))+
  theme_bw()+
  theme(plot.title = element_text(size = rel(1.5), hjust = 0.5),
        axis.title = element_text(size = 15, colour = "black"),
        axis.ticks = element_line(linewidth = 1.5),
        axis.line = element_line(linewidth = 1.5),
        axis.text = element_text(size = 10, colour = "black", angle = 0),
        strip.text = element_text(size = 15, colour = "black", face = "bold"))

#KEGG
table_DOX24Tshare_genes_KEGG <- table_DOX24Tshare_genes %>% 
  dplyr::filter(source=="KEGG") %>% 
  dplyr::select(p_value, term_name, intersection_size) %>% 
  dplyr::slice_min(., n=10, order_by=p_value) %>% 
  mutate(log_val = -log10(p_value))

table_DOX24Tshare_genes_KEGG %>% ggplot(., aes(x = log_val, y = reorder(term_name, p_value), col= intersection_size)) +
  geom_point(aes(size = intersection_size)) +
  ggtitle("DOX24T Shared DEGs Enriched KEGG Terms")+
  xlab(expression("-log"[10]~"p-value"))+
  guides(col="none", size= guide_legend(title = "# of intersected \n terms"))+
  ylab("KEGG term")+
  scale_y_discrete(labels = scales::label_wrap(30))+
  theme_bw()+
  theme(plot.title = element_text(size = rel(1.5), hjust = 0.5),
        axis.title = element_text(size = 15, colour = "black"),
        axis.ticks = element_line(linewidth = 1.5),
        axis.line = element_line(linewidth = 1.5),
        axis.text = element_text(size = 10, colour = "black", angle = 0),
        strip.text = element_text(size = 15, colour = "black", face = "bold"))

#####DOX24R DEGs GO KEGG#####
D24R_DEGs_mat <- as.matrix(DOX24R_DEGs_GO)

DOX_24R_dxr_gene <- gost(query = D24R_DEGs_mat,
                      organism = "hsapiens",
                      ordered_query = FALSE,
                      measure_underrepresentation = FALSE,
                      evcodes = FALSE,
                      user_threshold = 0.05,
                      correction_method = c("fdr"),
                      sources = c("GO:BP", "KEGG"))

DOX_24R_gost_genes <- gostplot(DOX_24R_dxr_gene, capped = FALSE, interactive = TRUE)
DOX_24R_gost_genes

table_DOX24R_genes <- DOX_24R_dxr_gene$result %>% 
  dplyr::select(c(source, term_id, term_name, intersection_size, term_size, p_value))

table_DOX24R_genes %>% 
  mutate_at(.vars = 6, .funs = scales::label_scientific(digits=4)) %>% 
  kableExtra::kable(.,) %>% 
  kableExtra::kable_paper("striped", full_width = FALSE) %>% 
  kableExtra::kable_styling(full_width = FALSE, position = "left", bootstrap_options = c("striped", "hover")) %>% 
  kableExtra::scroll_box(width = "100%", height = "400px")

#GO:BP
table_DOX24R_genes_GOBP <- table_DOX24R_genes %>% 
  dplyr::filter(source=="GO:BP") %>% 
  dplyr::select(p_value, term_name, intersection_size) %>% 
  dplyr::slice_min(., n=10, order_by=p_value) %>% 
  mutate(log_val = -log10(p_value))

table_DOX24R_genes_GOBP %>% ggplot(., aes(x = log_val, y = reorder(term_name, p_value), col= intersection_size)) +
  geom_point(aes(size = intersection_size)) +
  ggtitle("DOX24R Specific DEGs Enriched GO:BP Terms")+
  xlab(expression("-log"[10]~"p-value"))+
  guides(col="none", size= guide_legend(title = "# of intersected \n terms"))+
  ylab("GO:BP term")+
  scale_y_discrete(labels = scales::label_wrap(30))+
  theme_bw()+
  theme(plot.title = element_text(size = rel(1.5), hjust = 0.5),
        axis.title = element_text(size = 15, colour = "black"),
        axis.ticks = element_line(linewidth = 1.5),
        axis.line = element_line(linewidth = 1.5),
        axis.text = element_text(size = 10, colour = "black", angle = 0),
        strip.text = element_text(size = 15, colour = "black", face = "bold"))

#KEGG
table_DOX24R_genes_KEGG <- table_DOX24R_genes %>% 
  dplyr::filter(source=="KEGG") %>% 
  dplyr::select(p_value, term_name, intersection_size) %>% 
  dplyr::slice_min(., n=10, order_by=p_value) %>% 
  mutate(log_val = -log10(p_value))

table_DOX24R_genes_KEGG %>% ggplot(., aes(x = log_val, y = reorder(term_name, p_value), col= intersection_size)) +
  geom_point(aes(size = intersection_size)) +
  ggtitle("DOX24R DEGs Enriched KEGG Terms")+
  xlab(expression("-log"[10]~"p-value"))+
  guides(col="none", size= guide_legend(title = "# of intersected \n terms"))+
  ylab("KEGG term")+
  scale_y_discrete(labels = scales::label_wrap(30))+
  theme_bw()+
  theme(plot.title = element_text(size = rel(1.5), hjust = 0.5),
        axis.title = element_text(size = 15, colour = "black"),
        axis.ticks = element_line(linewidth = 1.5),
        axis.line = element_line(linewidth = 1.5),
        axis.text = element_text(size = 10, colour = "black", angle = 0),
        strip.text = element_text(size = 15, colour = "black", face = "bold"))

#####DOX144R DEGs GO KEGG#####
# D144R_DEGs_mat <- as.matrix(DOX144R_DEGs_GO)
# 
# DOX_144R_dxr_gene <- gost(query = D144R_DEGs_mat,
#                       organism = "hsapiens",
#                       ordered_query = FALSE,
#                       measure_underrepresentation = FALSE,
#                       evcodes = FALSE,
#                       user_threshold = 0.05,
#                       correction_method = c("fdr"),
#                       sources = c("GO:BP", "KEGG"))
# 
# DOX_144R_gost_genes <- gostplot(DOX_144R_dxr_gene, capped = FALSE, interactive = TRUE)
# DOX_144R_gost_genes
# 
# table_DOX144R_genes <- DOX_144R_dxr_gene$result %>% 
#   dplyr::select(c(source, term_id, term_name, intersection_size, term_size, p_value))
# 
# table_DOX144R_genes %>% 
#   mutate_at(.vars = 6, .funs = scales::label_scientific(digits=4)) %>% 
#   kableExtra::kable(.,) %>% 
#   kableExtra::kable_paper("striped", full_width = FALSE) %>% 
#   kableExtra::kable_styling(full_width = FALSE, position = "left", bootstrap_options = c("striped", "hover")) %>% 
#   kableExtra::scroll_box(width = "100%", height = "400px")
# 
# #GO:BP
# table_DOX144R_genes_GOBP <- table_DOX144R_genes %>% 
#   dplyr::filter(source=="GO:BP") %>% 
#   dplyr::select(p_value, term_name, intersection_size) %>% 
#   dplyr::slice_min(., n=10, order_by=p_value) %>% 
#   mutate(log_val = -log10(p_value))
# 
# table_DOX144R_genes_GOBP %>% ggplot(., aes(x = log_val, y = reorder(term_name, p_value), col= intersection_size)) +
#   geom_point(aes(size = intersection_size)) +
#   ggtitle("DOX144R Specific DEGs Enriched GO:BP Terms")+
#   xlab(expression("-log"[10]~"p-value"))+
#   guides(col="none", size= guide_legend(title = "# of intersected \n terms"))+
#   ylab("GO:BP term")+
#   scale_y_discrete(labels = scales::label_wrap(30))+
#   theme_bw()+
#   theme(plot.title = element_text(size = rel(1.5), hjust = 0.5),
#         axis.title = element_text(size = 15, colour = "black"),
#         axis.ticks = element_line(linewidth = 1.5),
#         axis.line = element_line(linewidth = 1.5),
#         axis.text = element_text(size = 10, colour = "black", angle = 0),
#         strip.text = element_text(size = 15, colour = "black", face = "bold"))
# 
# #KEGG
# table_DOX144R_genes_KEGG <- table_DOX144R_genes %>% 
#   dplyr::filter(source=="KEGG") %>% 
#   dplyr::select(p_value, term_name, intersection_size) %>% 
#   dplyr::slice_min(., n=10, order_by=p_value) %>% 
#   mutate(log_val = -log10(p_value))
# 
# table_DOX144R_genes_KEGG %>% ggplot(., aes(x = log_val, y = reorder(term_name, p_value), col= intersection_size)) +
#   geom_point(aes(size = intersection_size)) +
#   ggtitle("DOX144R DEGs Enriched KEGG Terms")+
#   xlab(expression("-log"[10]~"p-value"))+
#   guides(col="none", size= guide_legend(title = "# of intersected \n terms"))+
#   ylab("KEGG term")+
#   scale_y_discrete(labels = scales::label_wrap(30))+
#   theme_bw()+
#   theme(plot.title = element_text(size = rel(1.5), hjust = 0.5),
#         axis.title = element_text(size = 15, colour = "black"),
#         axis.ticks = element_line(linewidth = 1.5),
#         axis.line = element_line(linewidth = 1.5),
#         axis.text = element_text(size = 10, colour = "black", angle = 0),
#         strip.text = element_text(size = 15, colour = "black", face = "bold"))

#####DOX144R shared DEGs GO KEGG#####
D144Rshare_DEGs_mat <- as.matrix(DOX144Rshare_DEGs_GO_plot)

DOX_144Rshare_dxr_gene <- gost(query = D144Rshare_DEGs_mat,
                      organism = "hsapiens",
                      ordered_query = FALSE,
                      measure_underrepresentation = FALSE,
                      evcodes = FALSE,
                      user_threshold = 0.05,
                      correction_method = c("fdr"),
                      sources = c("GO:BP", "KEGG"))

DOX_144Rshare_gost_genes <- gostplot(DOX_144Rshare_dxr_gene, capped = FALSE, interactive = TRUE)
DOX_144Rshare_gost_genes

table_DOX144Rshare_genes <- DOX_144Rshare_dxr_gene$result %>% 
  dplyr::select(c(source, term_id, term_name, intersection_size, term_size, p_value))

table_DOX144Rshare_genes %>% 
  mutate_at(.vars = 6, .funs = scales::label_scientific(digits=4)) %>% 
  kableExtra::kable(.,) %>% 
  kableExtra::kable_paper("striped", full_width = FALSE) %>% 
  kableExtra::kable_styling(full_width = FALSE, position = "left", bootstrap_options = c("striped", "hover")) %>% 
  kableExtra::scroll_box(width = "100%", height = "400px")

#GO:BP
table_DOX144Rshare_genes_GOBP <- table_DOX144Rshare_genes %>% 
  dplyr::filter(source=="GO:BP") %>% 
  dplyr::select(p_value, term_name, intersection_size) %>% 
  dplyr::slice_min(., n=10, order_by=p_value) %>% 
  mutate(log_val = -log10(p_value))

table_DOX144Rshare_genes_GOBP %>% ggplot(., aes(x = log_val, y = reorder(term_name, p_value), col= intersection_size)) +
  geom_point(aes(size = intersection_size)) +
  ggtitle("DOX144R Shared DEGs Enriched GO:BP Terms")+
  xlab(expression("-log"[10]~"p-value"))+
  guides(col="none", size= guide_legend(title = "# of intersected \n terms"))+
  ylab("GO:BP term")+
  scale_y_discrete(labels = scales::label_wrap(30))+
  theme_bw()+
  theme(plot.title = element_text(size = rel(1.5), hjust = 0.5),
        axis.title = element_text(size = 15, colour = "black"),
        axis.ticks = element_line(linewidth = 1.5),
        axis.line = element_line(linewidth = 1.5),
        axis.text = element_text(size = 10, colour = "black", angle = 0),
        strip.text = element_text(size = 15, colour = "black", face = "bold"))

#KEGG
table_DOX144Rshare_genes_KEGG <- table_DOX144Rshare_genes %>% 
  dplyr::filter(source=="KEGG") %>% 
  dplyr::select(p_value, term_name, intersection_size) %>% 
  dplyr::slice_min(., n=10, order_by=p_value) %>% 
  mutate(log_val = -log10(p_value))

table_DOX144Rshare_genes_KEGG %>% ggplot(., aes(x = log_val, y = reorder(term_name, p_value), col= intersection_size)) +
  geom_point(aes(size = intersection_size)) +
  ggtitle("DOX144R Shared DEGs Enriched KEGG Terms")+
  xlab(expression("-log"[10]~"p-value"))+
  guides(col="none", size= guide_legend(title = "# of intersected \n terms"))+
  ylab("KEGG term")+
  scale_y_discrete(labels = scales::label_wrap(30))+
  theme_bw()+
  theme(plot.title = element_text(size = rel(1.5), hjust = 0.5),
        axis.title = element_text(size = 15, colour = "black"),
        axis.ticks = element_line(linewidth = 1.5),
        axis.line = element_line(linewidth = 1.5),
        axis.text = element_text(size = 10, colour = "black", angle = 0),
        strip.text = element_text(size = 15, colour = "black", face = "bold"))

```


```{r GO KEGG Overlap DEGs Up/Down}
# library(gprofiler2)
#####DOX24 Upregulated Genes#####
D24_DEGs_up_mat <- as.matrix(DOX24T_DEGs_GO_up)

DOX_24_up_dxr_gene <- gost(query = D24_DEGs_up_mat,
                      organism = "hsapiens",
                      ordered_query = FALSE,
                      measure_underrepresentation = FALSE,
                      evcodes = FALSE,
                      user_threshold = 0.05,
                      correction_method = c("fdr"),
                      sources = c("GO:BP", "KEGG"))

DOX_24_up_gost_genes <- gostplot(DOX_24_up_dxr_gene, capped = FALSE, interactive = TRUE)
DOX_24_up_gost_genes

table_DOX24_up_genes <- DOX_24_up_dxr_gene$result %>% 
  dplyr::select(c(source, term_id, term_name, intersection_size, term_size, p_value))

table_DOX24_up_genes %>% 
  mutate_at(.vars = 6, .funs = scales::label_scientific(digits=4)) %>% 
  kableExtra::kable(.,) %>% 
  kableExtra::kable_paper("striped", full_width = FALSE) %>% 
  kableExtra::kable_styling(full_width = FALSE, position = "left", bootstrap_options = c("striped", "hover")) %>% 
  kableExtra::scroll_box(width = "100%", height = "400px")

#write.csv(table_DOX24_up_genes, "output/table_DOX24_upreg_genes.csv")

#GO:BP
table_DOX24_up_genes_GOBP <- table_DOX24_up_genes %>% 
  dplyr::filter(source=="GO:BP") %>% 
  dplyr::select(p_value, term_name, intersection_size) %>% 
  dplyr::slice_min(., n=10, order_by=p_value) %>% 
  mutate(log_val = -log10(p_value))

#saveRDS(table_motif1_GOBP_d, "data/table_motif1_GOBP_d.RDS")

table_DOX24_up_genes_GOBP %>% ggplot(., aes(x = log_val, y = reorder(term_name, p_value), col= intersection_size)) +
  geom_point(aes(size = intersection_size)) +
  ggtitle("DOX24T Specific Up DEGs Enriched GO:BP Terms")+
  xlab(expression("-log"[10]~"p-value"))+
  guides(col="none", size= guide_legend(title = "# of intersected \n terms"))+
  ylab("GO:BP term")+
  scale_y_discrete(labels = scales::label_wrap(30))+
  theme_bw()+
  theme(plot.title = element_text(size = rel(1.5), hjust = 0.5),
        axis.title = element_text(size = 15, colour = "black"),
        axis.ticks = element_line(linewidth = 1.5),
        axis.line = element_line(linewidth = 1.5),
        axis.text = element_text(size = 10, colour = "black", angle = 0),
        strip.text = element_text(size = 15, colour = "black", face = "bold"))

#KEGG
table_DOX24_up_genes_KEGG <- table_DOX24_up_genes %>% 
  dplyr::filter(source=="KEGG") %>% 
  dplyr::select(p_value, term_name, intersection_size) %>% 
  dplyr::slice_min(., n=10, order_by=p_value) %>% 
  mutate(log_val = -log10(p_value))

table_DOX24_up_genes_KEGG %>% ggplot(., aes(x = log_val, y = reorder(term_name, p_value), col= intersection_size)) +
  geom_point(aes(size = intersection_size)) +
  ggtitle("DOX24T Specific Up DEGs Enriched KEGG Terms")+
  xlab(expression("-log"[10]~"p-value"))+
  guides(col="none", size= guide_legend(title = "# of intersected \n terms"))+
  ylab("KEGG term")+
  scale_y_discrete(labels = scales::label_wrap(30))+
  theme_bw()+
  theme(plot.title = element_text(size = rel(1.5), hjust = 0.5),
        axis.title = element_text(size = 15, colour = "black"),
        axis.ticks = element_line(linewidth = 1.5),
        axis.line = element_line(linewidth = 1.5),
        axis.text = element_text(size = 10, colour = "black", angle = 0),
        strip.text = element_text(size = 15, colour = "black", face = "bold"))

#####DOX24 Downregulated Genes#####
D24_DEGs_down_mat <- as.matrix(DOX24T_DEGs_GO_down)

DOX_24_down_dxr_gene <- gost(query = D24_DEGs_down_mat,
                      organism = "hsapiens",
                      ordered_query = FALSE,
                      measure_underrepresentation = FALSE,
                      evcodes = FALSE,
                      user_threshold = 0.05,
                      correction_method = c("fdr"),
                      sources = c("GO:BP", "KEGG"))

DOX_24_down_gost_genes <- gostplot(DOX_24_down_dxr_gene, capped = FALSE, interactive = TRUE)
DOX_24_down_gost_genes

table_DOX24_down_genes <- DOX_24_down_dxr_gene$result %>% 
  dplyr::select(c(source, term_id, term_name, intersection_size, term_size, p_value))

table_DOX24_down_genes %>% 
  mutate_at(.vars = 6, .funs = scales::label_scientific(digits=4)) %>% 
  kableExtra::kable(.,) %>% 
  kableExtra::kable_paper("striped", full_width = FALSE) %>% 
  kableExtra::kable_styling(full_width = FALSE, position = "left", bootstrap_options = c("striped", "hover")) %>% 
  kableExtra::scroll_box(width = "100%", height = "400px")

#write.csv(table_DOX24_down_genes, "output/table_DOX24_downreg_genes.csv")

#GO:BP
table_DOX24_down_genes_GOBP <- table_DOX24_down_genes %>% 
  dplyr::filter(source=="GO:BP") %>% 
  dplyr::select(p_value, term_name, intersection_size) %>% 
  dplyr::slice_min(., n=10, order_by=p_value) %>% 
  mutate(log_val = -log10(p_value))

#saveRDS(table_motif1_GOBP_d, "data/table_motif1_GOBP_d.RDS")

table_DOX24_down_genes_GOBP %>% ggplot(., aes(x = log_val, y = reorder(term_name, p_value), col= intersection_size)) +
  geom_point(aes(size = intersection_size)) +
  ggtitle("DOX24T Specific Down DEGs Enriched GO:BP Terms")+
  xlab(expression("-log"[10]~"p-value"))+
  guides(col="none", size= guide_legend(title = "# of intersected \n terms"))+
  ylab("GO:BP term")+
  scale_y_discrete(labels = scales::label_wrap(30))+
  theme_bw()+
  theme(plot.title = element_text(size = rel(1.5), hjust = 0.5),
        axis.title = element_text(size = 15, colour = "black"),
        axis.ticks = element_line(linewidth = 1.5),
        axis.line = element_line(linewidth = 1.5),
        axis.text = element_text(size = 10, colour = "black", angle = 0),
        strip.text = element_text(size = 15, colour = "black", face = "bold"))

#KEGG
table_DOX24_down_genes_KEGG <- table_DOX24_down_genes %>% 
  dplyr::filter(source=="KEGG") %>% 
  dplyr::select(p_value, term_name, intersection_size) %>% 
  dplyr::slice_min(., n=10, order_by=p_value) %>% 
  mutate(log_val = -log10(p_value))

table_DOX24_down_genes_KEGG %>% ggplot(., aes(x = log_val, y = reorder(term_name, p_value), col= intersection_size)) +
  geom_point(aes(size = intersection_size)) +
  ggtitle("DOX24T Specific Down DEGs Enriched KEGG Terms")+
  xlab(expression("-log"[10]~"p-value"))+
  guides(col="none", size= guide_legend(title = "# of intersected \n terms"))+
  ylab("KEGG term")+
  scale_y_discrete(labels = scales::label_wrap(30))+
  theme_bw()+
  theme(plot.title = element_text(size = rel(1.5), hjust = 0.5),
        axis.title = element_text(size = 15, colour = "black"),
        axis.ticks = element_line(linewidth = 1.5),
        axis.line = element_line(linewidth = 1.5),
        axis.text = element_text(size = 10, colour = "black", angle = 0),
        strip.text = element_text(size = 15, colour = "black", face = "bold"))


#####DOX24T share Upregulated DEGs GO KEGG#####
D24Tshare_DEGs_up_mat <- as.matrix(DOX24Tshare_DEGs_GO_up)

DOX_24Tshare_up_dxr_gene <- gost(query = D24Tshare_DEGs_up_mat,
                      organism = "hsapiens",
                      ordered_query = FALSE,
                      measure_underrepresentation = FALSE,
                      evcodes = FALSE,
                      user_threshold = 0.05,
                      correction_method = c("fdr"),
                      sources = c("GO:BP", "KEGG"))

DOX_24Tshare_up_gost_genes <- gostplot(DOX_24Tshare_up_dxr_gene, capped = FALSE, interactive = TRUE)
DOX_24Tshare_up_gost_genes

table_DOX24Tshare_up_genes <- DOX_24Tshare_up_dxr_gene$result %>% 
  dplyr::select(c(source, term_id, term_name, intersection_size, term_size, p_value))

table_DOX24Tshare_up_genes %>% 
  mutate_at(.vars = 6, .funs = scales::label_scientific(digits=4)) %>% 
  kableExtra::kable(.,) %>% 
  kableExtra::kable_paper("striped", full_width = FALSE) %>% 
  kableExtra::kable_styling(full_width = FALSE, position = "left", bootstrap_options = c("striped", "hover")) %>% 
  kableExtra::scroll_box(width = "100%", height = "400px")

#write.csv(table_DOX24R_up_genes, "output/table_DOX24R_upreg_genes.csv")

#GO:BP
table_DOX24Tshare_up_genes_GOBP <- table_DOX24Tshare_up_genes %>% 
  dplyr::filter(source=="GO:BP") %>% 
  dplyr::select(p_value, term_name, intersection_size) %>% 
  dplyr::slice_min(., n=10, order_by=p_value) %>% 
  mutate(log_val = -log10(p_value))

#saveRDS(table_motif1_GOBP_d, "data/table_motif1_GOBP_d.RDS")

table_DOX24Tshare_up_genes_GOBP %>% ggplot(., aes(x = log_val, y = reorder(term_name, p_value), col= intersection_size)) +
  geom_point(aes(size = intersection_size)) +
  ggtitle("DOX24T Shared Up DEGs Enriched GO:BP Terms")+
  xlab(expression("-log"[10]~"p-value"))+
  guides(col="none", size= guide_legend(title = "# of intersected \n terms"))+
  ylab("GO:BP term")+
  scale_y_discrete(labels = scales::label_wrap(30))+
  theme_bw()+
  theme(plot.title = element_text(size = rel(1.5), hjust = 0.5),
        axis.title = element_text(size = 15, colour = "black"),
        axis.ticks = element_line(linewidth = 1.5),
        axis.line = element_line(linewidth = 1.5),
        axis.text = element_text(size = 10, colour = "black", angle = 0),
        strip.text = element_text(size = 15, colour = "black", face = "bold"))

#KEGG
table_DOX24Tshare_up_genes_KEGG <- table_DOX24Tshare_up_genes %>% 
  dplyr::filter(source=="KEGG") %>% 
  dplyr::select(p_value, term_name, intersection_size) %>% 
  dplyr::slice_min(., n=10, order_by=p_value) %>% 
  mutate(log_val = -log10(p_value))

table_DOX24Tshare_up_genes_KEGG %>% ggplot(., aes(x = log_val, y = reorder(term_name, p_value), col= intersection_size)) +
  geom_point(aes(size = intersection_size)) +
  ggtitle("DOX24T Shared Up DEGs Enriched KEGG Terms")+
  xlab(expression("-log"[10]~"p-value"))+
  guides(col="none", size= guide_legend(title = "# of intersected \n terms"))+
  ylab("KEGG term")+
  scale_y_discrete(labels = scales::label_wrap(30))+
  theme_bw()+
  theme(plot.title = element_text(size = rel(1.5), hjust = 0.5),
        axis.title = element_text(size = 15, colour = "black"),
        axis.ticks = element_line(linewidth = 1.5),
        axis.line = element_line(linewidth = 1.5),
        axis.text = element_text(size = 10, colour = "black", angle = 0),
        strip.text = element_text(size = 15, colour = "black", face = "bold"))

#####DOX24R Downregulated DEGs GO KEGG#####
D24Tshare_DEGs_down_mat <- as.matrix(DOX24Tshare_DEGs_GO_down)

DOX_24Tshare_down_dxr_gene <- gost(query = D24Tshare_DEGs_down_mat,
                      organism = "hsapiens",
                      ordered_query = FALSE,
                      measure_underrepresentation = FALSE,
                      evcodes = FALSE,
                      user_threshold = 0.05,
                      correction_method = c("fdr"),
                      sources = c("GO:BP", "KEGG"))

DOX_24Tshare_down_gost_genes <- gostplot(DOX_24Tshare_down_dxr_gene, capped = FALSE, interactive = TRUE)
DOX_24Tshare_down_gost_genes

table_DOX24Tshare_down_genes <- DOX_24Tshare_down_dxr_gene$result %>% 
  dplyr::select(c(source, term_id, term_name, intersection_size, term_size, p_value))

table_DOX24Tshare_down_genes %>% 
  mutate_at(.vars = 6, .funs = scales::label_scientific(digits=4)) %>% 
  kableExtra::kable(.,) %>% 
  kableExtra::kable_paper("striped", full_width = FALSE) %>% 
  kableExtra::kable_styling(full_width = FALSE, position = "left", bootstrap_options = c("striped", "hover")) %>% 
  kableExtra::scroll_box(width = "100%", height = "400px")

#write.csv(table_DOX24R_down_genes, "output/table_DOX24R_downreg_genes.csv")

#GO:BP
table_DOX24Tshare_down_genes_GOBP <- table_DOX24Tshare_down_genes %>% 
  dplyr::filter(source=="GO:BP") %>% 
  dplyr::select(p_value, term_name, intersection_size) %>% 
  dplyr::slice_min(., n=10, order_by=p_value) %>% 
  mutate(log_val = -log10(p_value))

#saveRDS(table_motif1_GOBP_d, "data/table_motif1_GOBP_d.RDS")

table_DOX24Tshare_down_genes_GOBP %>% ggplot(., aes(x = log_val, y = reorder(term_name, p_value), col= intersection_size)) +
  geom_point(aes(size = intersection_size)) +
  ggtitle("DOX24T Shared Down DEGs Enriched GO:BP Terms")+
  xlab(expression("-log"[10]~"p-value"))+
  guides(col="none", size= guide_legend(title = "# of intersected \n terms"))+
  ylab("GO:BP term")+
  scale_y_discrete(labels = scales::label_wrap(30))+
  theme_bw()+
  theme(plot.title = element_text(size = rel(1.5), hjust = 0.5),
        axis.title = element_text(size = 15, colour = "black"),
        axis.ticks = element_line(linewidth = 1.5),
        axis.line = element_line(linewidth = 1.5),
        axis.text = element_text(size = 10, colour = "black", angle = 0),
        strip.text = element_text(size = 15, colour = "black", face = "bold"))

#KEGG
table_DOX24Tshare_down_genes_KEGG <- table_DOX24Tshare_down_genes %>% 
  dplyr::filter(source=="KEGG") %>% 
  dplyr::select(p_value, term_name, intersection_size) %>% 
  dplyr::slice_min(., n=10, order_by=p_value) %>% 
  mutate(log_val = -log10(p_value))

table_DOX24Tshare_down_genes_KEGG %>% ggplot(., aes(x = log_val, y = reorder(term_name, p_value), col= intersection_size)) +
  geom_point(aes(size = intersection_size)) +
  ggtitle("DOX24T Shared Down DEGs Enriched KEGG Terms")+
  xlab(expression("-log"[10]~"p-value"))+
  guides(col="none", size= guide_legend(title = "# of intersected \n terms"))+
  ylab("KEGG term")+
  scale_y_discrete(labels = scales::label_wrap(30))+
  theme_bw()+
  theme(plot.title = element_text(size = rel(1.5), hjust = 0.5),
        axis.title = element_text(size = 15, colour = "black"),
        axis.ticks = element_line(linewidth = 1.5),
        axis.line = element_line(linewidth = 1.5),
        axis.text = element_text(size = 10, colour = "black", angle = 0),
        strip.text = element_text(size = 15, colour = "black", face = "bold"))
```

```{r RUVs GO KEGG}
#####DOX24 Genes Specific#####
D24_DEGs_mat_RUV <- as.matrix(DOX24T_DEGs_GO_RUV)
D24_DEGs_vec_RUV <- as.character(DOX24T_DEGs_GO_RUV$Entrez_ID)

#saveRDS(D24_DEGs_mat_RUV, "data/new/RUV/D24_DEGs_mat_RUV.RDS")

DOX_24_dxr_gene_RUV <- gost(query = D24_DEGs_vec_RUV,
                      organism = "hsapiens",
                      ordered_query = FALSE,
                      measure_underrepresentation = FALSE,
                      evcodes = FALSE,
                      user_threshold = 0.05,
                      correction_method = c("fdr"),
                      sources = c("GO:BP", "KEGG"))

#check if there are any KEGG terms popping up
unique(DOX_24_dxr_gene_RUV$result$source)
#only GO:BP appearing

DOX_24_gost_genes_RUV <- gostplot(DOX_24_dxr_gene_RUV, capped = FALSE, interactive = TRUE)
DOX_24_gost_genes_RUV

table_DOX24_genes_RUV <- DOX_24_dxr_gene_RUV$result %>% 
  dplyr::select(c(source, term_id, term_name, intersection_size, term_size, p_value))

table_DOX24_genes_RUV %>% 
  mutate_at(.vars = 6, .funs = scales::label_scientific(digits=4)) %>% 
  kableExtra::kable(.,) %>% 
  kableExtra::kable_paper("striped", full_width = FALSE) %>% 
  kableExtra::kable_styling(full_width = FALSE, position = "left", bootstrap_options = c("striped", "hover")) %>% 
  kableExtra::scroll_box(width = "100%", height = "400px")


#GO:BP
table_DOX24_genes_GOBP_RUV <- table_DOX24_genes_RUV %>% 
  dplyr::filter(source=="GO:BP") %>% 
  dplyr::select(p_value, term_name, intersection_size) %>% 
  dplyr::slice_min(., n=10, order_by=p_value) %>% 
  mutate(log_val = -log10(p_value))


table_DOX24_genes_GOBP_RUV %>% ggplot(., aes(x = log_val, y = reorder(term_name, p_value), col= intersection_size)) +
  geom_point(aes(size = intersection_size)) +
  ggtitle("DOX24T Specific DEGs Enriched GO:BP Terms RUVs")+
  xlab(expression("-log"[10]~"p-value"))+
  guides(col="none", size= guide_legend(title = "# of intersected \n terms"))+
  ylab("GO:BP term")+
  scale_y_discrete(labels = scales::label_wrap(30))+
  theme_bw()+
  theme(plot.title = element_text(size = rel(1.5), hjust = 0.5),
        axis.title = element_text(size = 15, colour = "black"),
        axis.ticks = element_line(linewidth = 1.5),
        axis.line = element_line(linewidth = 1.5),
        axis.text = element_text(size = 10, colour = "black", angle = 0),
        strip.text = element_text(size = 15, colour = "black", face = "bold"))

# #KEGG - no KEGG terms popped up for this one?
# table_DOX24_genes_KEGG_RUV <- table_DOX24_genes_RUV %>% 
#   dplyr::filter(source=="KEGG") %>% 
#   dplyr::select(p_value, term_name, intersection_size) %>% 
#   dplyr::slice_min(., n=10, order_by=p_value) %>% 
#   mutate(log_val = -log10(p_value))
# 
# table_DOX24_genes_KEGG_RUV %>% ggplot(., aes(x = log_val, y = reorder(term_name, p_value), col= intersection_size)) +
#   geom_point(aes(size = intersection_size)) +
#   ggtitle("DOX24T Specific DEGs Enriched KEGG Terms RUVs")+
#   xlab(expression("-log"[10]~"p-value"))+
#   guides(col="none", size= guide_legend(title = "# of intersected \n terms"))+
#   ylab("KEGG term")+
#   scale_y_discrete(labels = scales::label_wrap(30))+
#   theme_bw()+
#   theme(plot.title = element_text(size = rel(1.5), hjust = 0.5),
#         axis.title = element_text(size = 15, colour = "black"),
#         axis.ticks = element_line(linewidth = 1.5),
#         axis.line = element_line(linewidth = 1.5),
#         axis.text = element_text(size = 10, colour = "black", angle = 0),
#         strip.text = element_text(size = 15, colour = "black", face = "bold"))


#####DOX24T shared DEGs GO KEGG#####
D24Tshare_DEGs_mat_RUV <- as.matrix(DOX24T_share_DEGs_GO_plot_RUV)

DOX_24Tshare_dxr_gene_RUV <- gost(query = D24Tshare_DEGs_mat_RUV,
                      organism = "hsapiens",
                      ordered_query = FALSE,
                      measure_underrepresentation = FALSE,
                      evcodes = FALSE,
                      user_threshold = 0.05,
                      correction_method = c("fdr"),
                      sources = c("GO:BP", "KEGG"))

#check if there are any KEGG terms popping up
unique(DOX_24Tshare_dxr_gene_RUV$result$source)
#only GO:BP appearing

DOX_24Tshare_gost_genes_RUV <- 
  gostplot(DOX_24Tshare_dxr_gene_RUV, capped = FALSE, interactive = TRUE)
DOX_24Tshare_gost_genes_RUV

table_DOX24Tshare_genes_RUV <- DOX_24Tshare_dxr_gene_RUV$result %>% 
  dplyr::select(c(source, term_id, term_name, intersection_size, term_size, p_value))

table_DOX24Tshare_genes_RUV %>% 
  mutate_at(.vars = 6, .funs = scales::label_scientific(digits=4)) %>% 
  kableExtra::kable(.,) %>% 
  kableExtra::kable_paper("striped", full_width = FALSE) %>% 
  kableExtra::kable_styling(full_width = FALSE, position = "left", bootstrap_options = c("striped", "hover")) %>% 
  kableExtra::scroll_box(width = "100%", height = "400px")

#GO:BP
table_DOX24Tshare_genes_GOBP_RUV <- table_DOX24Tshare_genes_RUV %>% 
  dplyr::filter(source=="GO:BP") %>% 
  dplyr::select(p_value, term_name, intersection_size) %>% 
  dplyr::slice_min(., n=10, order_by=p_value) %>% 
  mutate(log_val = -log10(p_value))

table_DOX24Tshare_genes_GOBP_RUV %>% ggplot(., aes(x = log_val, y = reorder(term_name, p_value), col= intersection_size)) +
  geom_point(aes(size = intersection_size)) +
  ggtitle("DOX24T Shared DEGs Enriched GO:BP Terms RUVs")+
  xlab(expression("-log"[10]~"p-value"))+
  guides(col="none", size= guide_legend(title = "# of intersected \n terms"))+
  ylab("GO:BP term")+
  scale_y_discrete(labels = scales::label_wrap(30))+
  theme_bw()+
  theme(plot.title = element_text(size = rel(1.5), hjust = 0.5),
        axis.title = element_text(size = 15, colour = "black"),
        axis.ticks = element_line(linewidth = 1.5),
        axis.line = element_line(linewidth = 1.5),
        axis.text = element_text(size = 10, colour = "black", angle = 0),
        strip.text = element_text(size = 15, colour = "black", face = "bold"))

# #KEGG
# table_DOX24Tshare_genes_KEGG_RUV <- table_DOX24Tshare_genes_RUV %>% 
#   dplyr::filter(source=="KEGG") %>% 
#   dplyr::select(p_value, term_name, intersection_size) %>% 
#   dplyr::slice_min(., n=10, order_by=p_value) %>% 
#   mutate(log_val = -log10(p_value))
# 
# table_DOX24Tshare_genes_KEGG_RUV %>% ggplot(., aes(x = log_val, y = reorder(term_name, p_value), col= intersection_size)) +
#   geom_point(aes(size = intersection_size)) +
#   ggtitle("DOX24T Shared DEGs Enriched KEGG Terms RUVs")+
#   xlab(expression("-log"[10]~"p-value"))+
#   guides(col="none", size= guide_legend(title = "# of intersected \n terms"))+
#   ylab("KEGG term")+
#   scale_y_discrete(labels = scales::label_wrap(30))+
#   theme_bw()+
#   theme(plot.title = element_text(size = rel(1.5), hjust = 0.5),
#         axis.title = element_text(size = 15, colour = "black"),
#         axis.ticks = element_line(linewidth = 1.5),
#         axis.line = element_line(linewidth = 1.5),
#         axis.text = element_text(size = 10, colour = "black", angle = 0),
#         strip.text = element_text(size = 15, colour = "black", face = "bold"))

#####DOX24R DEGs GO KEGG#####
D24R_DEGs_mat_RUV <- as.matrix(DOX24R_DEGs_GO_RUV)

DOX_24R_dxr_gene_RUV <- gost(query = D24R_DEGs_mat_RUV,
                      organism = "hsapiens",
                      ordered_query = FALSE,
                      measure_underrepresentation = FALSE,
                      evcodes = FALSE,
                      user_threshold = 0.05,
                      correction_method = c("fdr"),
                      sources = c("GO:BP", "KEGG"))

#check if there are any KEGG terms popping up
unique(DOX_24R_dxr_gene_RUV$result$source)
#only GO:BP appearing

DOX_24R_gost_genes_RUV <- 
  gostplot(DOX_24R_dxr_gene_RUV, capped = FALSE, interactive = TRUE)
DOX_24R_gost_genes_RUV

table_DOX24R_genes_RUV <- DOX_24R_dxr_gene_RUV$result %>% 
  dplyr::select(c(source, term_id, term_name, intersection_size, term_size, p_value))

table_DOX24R_genes_RUV %>% 
  mutate_at(.vars = 6, .funs = scales::label_scientific(digits=4)) %>% 
  kableExtra::kable(.,) %>% 
  kableExtra::kable_paper("striped", full_width = FALSE) %>% 
  kableExtra::kable_styling(full_width = FALSE, position = "left", bootstrap_options = c("striped", "hover")) %>% 
  kableExtra::scroll_box(width = "100%", height = "400px")

#GO:BP
table_DOX24R_genes_GOBP_RUV <- table_DOX24R_genes_RUV %>% 
  dplyr::filter(source=="GO:BP") %>% 
  dplyr::select(p_value, term_name, intersection_size) %>% 
  dplyr::slice_min(., n=10, order_by=p_value) %>% 
  mutate(log_val = -log10(p_value))

table_DOX24R_genes_GOBP_RUV %>% ggplot(., aes(x = log_val, y = reorder(term_name, p_value), col= intersection_size)) +
  geom_point(aes(size = intersection_size)) +
  ggtitle("DOX24R Specific DEGs Enriched GO:BP Terms RUVs")+
  xlab(expression("-log"[10]~"p-value"))+
  guides(col="none", size= guide_legend(title = "# of intersected \n terms"))+
  ylab("GO:BP term")+
  scale_y_discrete(labels = scales::label_wrap(30))+
  theme_bw()+
  theme(plot.title = element_text(size = rel(1.5), hjust = 0.5),
        axis.title = element_text(size = 15, colour = "black"),
        axis.ticks = element_line(linewidth = 1.5),
        axis.line = element_line(linewidth = 1.5),
        axis.text = element_text(size = 10, colour = "black", angle = 0),
        strip.text = element_text(size = 15, colour = "black", face = "bold"))

# #KEGG
# table_DOX24R_genes_KEGG_RUV <- table_DOX24R_genes_RUV %>% 
#   dplyr::filter(source=="KEGG") %>% 
#   dplyr::select(p_value, term_name, intersection_size) %>% 
#   dplyr::slice_min(., n=10, order_by=p_value) %>% 
#   mutate(log_val = -log10(p_value))
# 
# table_DOX24R_genes_KEGG_RUV %>% ggplot(., aes(x = log_val, y = reorder(term_name, p_value), col= intersection_size)) +
#   geom_point(aes(size = intersection_size)) +
#   ggtitle("DOX24R DEGs Enriched KEGG Terms RUVs")+
#   xlab(expression("-log"[10]~"p-value"))+
#   guides(col="none", size= guide_legend(title = "# of intersected \n terms"))+
#   ylab("KEGG term")+
#   scale_y_discrete(labels = scales::label_wrap(30))+
#   theme_bw()+
#   theme(plot.title = element_text(size = rel(1.5), hjust = 0.5),
#         axis.title = element_text(size = 15, colour = "black"),
#         axis.ticks = element_line(linewidth = 1.5),
#         axis.line = element_line(linewidth = 1.5),
#         axis.text = element_text(size = 10, colour = "black", angle = 0),
#         strip.text = element_text(size = 15, colour = "black", face = "bold"))

####DOX144R DEGs GO KEGG#####
D144R_DEGs_mat_RUV <- as.matrix(DOX144R_DEGs_GO_RUV)

DOX_144R_dxr_gene_RUV <- gost(query = D144R_DEGs_mat_RUV,
                      organism = "hsapiens",
                      ordered_query = FALSE,
                      measure_underrepresentation = FALSE,
                      evcodes = FALSE,
                      user_threshold = 0.05,
                      correction_method = c("fdr"),
                      sources = c("GO:BP", "KEGG"))

#check if there are any KEGG terms popping up
unique(DOX_144R_dxr_gene_RUV$result$source)
#GO:BP and KEGG appearing here

DOX_144R_gost_genes_RUV <- 
  gostplot(DOX_144R_dxr_gene_RUV, capped = FALSE, interactive = TRUE)
DOX_144R_gost_genes_RUV

table_DOX144R_genes_RUV <- DOX_144R_dxr_gene_RUV$result %>%
  dplyr::select(c(source, term_id, term_name, intersection_size, term_size, p_value))

table_DOX144R_genes_RUV %>%
  mutate_at(.vars = 6, .funs = scales::label_scientific(digits=4)) %>%
  kableExtra::kable(.,) %>%
  kableExtra::kable_paper("striped", full_width = FALSE) %>%
  kableExtra::kable_styling(full_width = FALSE, position = "left", bootstrap_options = c("striped", "hover")) %>%
  kableExtra::scroll_box(width = "100%", height = "400px")

#GO:BP
table_DOX144R_genes_GOBP_RUV <- table_DOX144R_genes_RUV %>%
  dplyr::filter(source=="GO:BP") %>%
  dplyr::select(p_value, term_name, intersection_size) %>%
  dplyr::slice_min(., n=10, order_by=p_value) %>%
  mutate(log_val = -log10(p_value))

table_DOX144R_genes_GOBP_RUV %>% ggplot(., aes(x = log_val, y = reorder(term_name, p_value), col= intersection_size)) +
  geom_point(aes(size = intersection_size)) +
  ggtitle("DOX144R Specific DEGs Enriched GO:BP Terms RUVs")+
  xlab(expression("-log"[10]~"p-value"))+
  guides(col="none", size= guide_legend(title = "# of intersected \n terms"))+
  ylab("GO:BP term")+
  scale_y_discrete(labels = scales::label_wrap(30))+
  theme_bw()+
  theme(plot.title = element_text(size = rel(1.5), hjust = 0.5),
        axis.title = element_text(size = 15, colour = "black"),
        axis.ticks = element_line(linewidth = 1.5),
        axis.line = element_line(linewidth = 1.5),
        axis.text = element_text(size = 10, colour = "black", angle = 0),
        strip.text = element_text(size = 15, colour = "black", face = "bold"))

#KEGG
table_DOX144R_genes_KEGG_RUV <- table_DOX144R_genes_RUV %>%
  dplyr::filter(source=="KEGG") %>%
  dplyr::select(p_value, term_name, intersection_size) %>%
  dplyr::slice_min(., n=10, order_by=p_value) %>%
  mutate(log_val = -log10(p_value))

table_DOX144R_genes_KEGG_RUV %>% ggplot(., aes(x = log_val, y = reorder(term_name, p_value), col= intersection_size)) +
  geom_point(aes(size = intersection_size)) +
  ggtitle("DOX144R DEGs Enriched KEGG Terms RUVs")+
  xlab(expression("-log"[10]~"p-value"))+
  guides(col="none", size= guide_legend(title = "# of intersected \n terms"))+
  ylab("KEGG term")+
  scale_y_discrete(labels = scales::label_wrap(30))+
  theme_bw()+
  theme(plot.title = element_text(size = rel(1.5), hjust = 0.5),
        axis.title = element_text(size = 15, colour = "black"),
        axis.ticks = element_line(linewidth = 1.5),
        axis.line = element_line(linewidth = 1.5),
        axis.text = element_text(size = 10, colour = "black", angle = 0),
        strip.text = element_text(size = 15, colour = "black", face = "bold"))

#####DOX144R shared DEGs GO KEGG#####
D144Rshare_DEGs_mat_RUV <- as.matrix(DOX144Rshare_DEGs_GO_plot_RUV)

DOX_144Rshare_dxr_gene_RUV <- gost(query = D144Rshare_DEGs_mat_RUV,
                      organism = "hsapiens",
                      ordered_query = FALSE,
                      measure_underrepresentation = FALSE,
                      evcodes = FALSE,
                      user_threshold = 0.05,
                      correction_method = c("fdr"),
                      sources = c("GO:BP", "KEGG"))

#check if any KEGG terms are appearing
unique(DOX_144Rshare_dxr_gene_RUV$result$source)
#only GO:BP appearing here

DOX_144Rshare_gost_genes_RUV <- 
  gostplot(DOX_144Rshare_dxr_gene_RUV, capped = FALSE, interactive = TRUE)
DOX_144Rshare_gost_genes_RUV

table_DOX144Rshare_genes_RUV <- DOX_144Rshare_dxr_gene_RUV$result %>% 
  dplyr::select(c(source, term_id, term_name, intersection_size, term_size, p_value))

table_DOX144Rshare_genes_RUV %>% 
  mutate_at(.vars = 6, .funs = scales::label_scientific(digits=4)) %>% 
  kableExtra::kable(.,) %>% 
  kableExtra::kable_paper("striped", full_width = FALSE) %>% 
  kableExtra::kable_styling(full_width = FALSE, position = "left", bootstrap_options = c("striped", "hover")) %>% 
  kableExtra::scroll_box(width = "100%", height = "400px")

#GO:BP
table_DOX144Rshare_genes_GOBP_RUV <- table_DOX144Rshare_genes_RUV %>% 
  dplyr::filter(source=="GO:BP") %>% 
  dplyr::select(p_value, term_name, intersection_size) %>% 
  dplyr::slice_min(., n=10, order_by=p_value) %>% 
  mutate(log_val = -log10(p_value))

table_DOX144Rshare_genes_GOBP_RUV %>% ggplot(., aes(x = log_val, y = reorder(term_name, p_value), col= intersection_size)) +
  geom_point(aes(size = intersection_size)) +
  ggtitle("DOX144R Shared DEGs Enriched GO:BP Terms RUVs")+
  xlab(expression("-log"[10]~"p-value"))+
  guides(col="none", size= guide_legend(title = "# of intersected \n terms"))+
  ylab("GO:BP term")+
  scale_y_discrete(labels = scales::label_wrap(30))+
  theme_bw()+
  theme(plot.title = element_text(size = rel(1.5), hjust = 0.5),
        axis.title = element_text(size = 15, colour = "black"),
        axis.ticks = element_line(linewidth = 1.5),
        axis.line = element_line(linewidth = 1.5),
        axis.text = element_text(size = 10, colour = "black", angle = 0),
        strip.text = element_text(size = 15, colour = "black", face = "bold"))

# #KEGG
# table_DOX144Rshare_genes_KEGG_RUV <- table_DOX144Rshare_genes_RUV %>% 
#   dplyr::filter(source=="KEGG") %>% 
#   dplyr::select(p_value, term_name, intersection_size) %>% 
#   dplyr::slice_min(., n=10, order_by=p_value) %>% 
#   mutate(log_val = -log10(p_value))
# 
# table_DOX144Rshare_genes_KEGG_RUV %>% ggplot(., aes(x = log_val, y = reorder(term_name, p_value), col= intersection_size)) +
#   geom_point(aes(size = intersection_size)) +
#   ggtitle("DOX144R Shared DEGs Enriched KEGG Terms RUVs")+
#   xlab(expression("-log"[10]~"p-value"))+
#   guides(col="none", size= guide_legend(title = "# of intersected \n terms"))+
#   ylab("KEGG term")+
#   scale_y_discrete(labels = scales::label_wrap(30))+
#   theme_bw()+
#   theme(plot.title = element_text(size = rel(1.5), hjust = 0.5),
#         axis.title = element_text(size = 15, colour = "black"),
#         axis.ticks = element_line(linewidth = 1.5),
#         axis.line = element_line(linewidth = 1.5),
#         axis.text = element_text(size = 10, colour = "black", angle = 0),
#         strip.text = element_text(size = 15, colour = "black", face = "bold"))
```

```{r RUVs DDR Genes logFC, fig.height=14, fig.width=8}
#DDR Gene Expression Heatmap  DOX Over Recovery Time (68 genes, with categories)
#now add in the RUV corrected data and see if this makes a difference at all!

# Load libraries
# library(circlize)
# library(grid)
# library(reshape2)

# Load DEG files
load_deg <- function(path) read.csv(path)

DOX_24T_R <- load_deg("data/new/DEGs/Toptable_RUV_24T_final.csv")
DOX_24R_R <- load_deg("data/new/DEGs/Toptable_RUV_24R_final.csv")
DOX_144R_R <- load_deg("data/new/DEGs/Toptable_RUV_144R_final.csv")

# Final Entrez IDs and categories (68 genes)
#no need to change the name of this as it's the same
entrez_category_DDR <- tribble(
  ~ENTREZID, ~Category,
  317, "Apoptosis", 355, "Apoptosis", 581, "Apoptosis", 637, "Apoptosis",
  836, "Apoptosis", 841, "Apoptosis", 842, "Apoptosis", 27113, "Apoptosis",
  5366, "Apoptosis", 54205, "Apoptosis", 55367, "Apoptosis", 8795, "Apoptosis",
  1026, "Cell Cycle / Checkpoint", 1027, "Cell Cycle / Checkpoint", 595, "Cell Cycle / Checkpoint",
  894, "Cell Cycle / Checkpoint", 896, "Cell Cycle / Checkpoint", 898, "Cell Cycle / Checkpoint",
  9133, "Cell Cycle / Checkpoint", 9134, "Cell Cycle / Checkpoint", 891, "Cell Cycle / Checkpoint",
  983, "Cell Cycle / Checkpoint", 1017, "Cell Cycle / Checkpoint", 1019, "Cell Cycle / Checkpoint",
  1020, "Cell Cycle / Checkpoint", 1021, "Cell Cycle / Checkpoint", 993, "Cell Cycle / Checkpoint",
  995, "Cell Cycle / Checkpoint", 1869, "Cell Cycle / Checkpoint", 4609, "Cell Cycle / Checkpoint",
  5925, "Cell Cycle / Checkpoint", 9874, "Cell Cycle / Checkpoint", 11011, "Cell Cycle / Checkpoint",
  1385, "Cell Cycle / Checkpoint",
  472, "Damage Sensors / Signal Transducers", 545, "Damage Sensors / Signal Transducers",
  5591, "Damage Sensors / Signal Transducers", 5810, "Damage Sensors / Signal Transducers",
  5883, "Damage Sensors / Signal Transducers", 5884, "Damage Sensors / Signal Transducers",
  6118, "Damage Sensors / Signal Transducers", 4361, "Damage Sensors / Signal Transducers",
  10111, "Damage Sensors / Signal Transducers", 4683, "Damage Sensors / Signal Transducers",
  84126, "Damage Sensors / Signal Transducers", 3014, "Damage Sensors / Signal Transducers",
  672, "DNA Repair", 2177, "DNA Repair", 5888, "DNA Repair", 5893, "DNA Repair",
  1647, "DNA Repair", 4616, "DNA Repair", 10912, "DNA Repair", 1111, "DNA Repair",
  11200, "DNA Repair", 1643, "DNA Repair", 8243, "DNA Repair", 5981, "DNA Repair",
  7157, "p53 Regulators / Targets", 4193, "p53 Regulators / Targets", 5371, "p53 Regulators / Targets",
  27244, "p53 Regulators / Targets", 50484, "p53 Regulators / Targets",
  5916, "DOX Cardiotoxicity", 7799, "DOX Cardiotoxicity", 4292, "DOX Cardiotoxicity",
  207, "Miscellaneous / Broad", 25, "Miscellaneous / Broad"
)

entrez_ids_DDR_R <- entrez_category_DDR$ENTREZID

# Extract relevant DEG values
extract_data_DDR_R <- function(df, name) {
  df %>%
    filter(Entrez_ID %in% entrez_ids_DDR_R) %>%
    mutate(
      Gene = mapIds(org.Hs.eg.db, as.character(Entrez_ID),
                    column = "SYMBOL", keytype = "ENTREZID", multiVals = "first"),
      Condition = name,
      Signif = ifelse(adj.P.Val < 0.05, "*", "")
    )
}

# DEG list
deg_list_RUV <- list("DOX_24T" = DOX_24T_R, 
                 "DOX_24R" = DOX_24R_R, 
                 "DOX_144R" = DOX_144R_R
)

# Combine all DEGs and annotate
all_data_DDR_RUV <- bind_rows(mapply(extract_data_DDR_R, deg_list_RUV, names(deg_list_RUV), SIMPLIFY = FALSE)) %>%
  left_join(entrez_category_DDR, by = c("Entrez_ID" = "ENTREZID"))

# DDR_genesymbols_list_RUV <- all_data_DDR_RUV$Gene
# write.csv(DDR_genesymbols_list_RUV, "data/new/RUV/DDR_Genes_list_RUV.csv")

# Create matrices
logFC_matddr_R <- acast(all_data_DDR_RUV, Gene ~ Condition, value.var = "logFC")
signif_matddr_R <- acast(all_data_DDR_RUV, Gene ~ Condition, value.var = "Signif")

# Set desired order
desired_order <- c("DOX_24T",
                   "DOX_24R",
                   "DOX_144R")

logFC_mat_DDR_RUV <- logFC_matddr_R[, desired_order, drop = FALSE]
signif_mat_DDR_RUV <- signif_matddr_R[, desired_order, drop = FALSE]

# Column annotation
meta_DDR_R <- str_split_fixed(colnames(logFC_mat_DDR_RUV), "_", 2)
col_annot <- HeatmapAnnotation(
  Drug = meta_DDR_R[, 1],
  Time = meta_DDR_R[, 2],
  col = list(
    Drug = c("DOX" = "#499FBD"),
    Time = c("24T" = "#238B45", 
             "24R" = "#74C476", 
             "144R" = "#C7E9C0")
  ),
  annotation_height = unit(c(1, 1, 1), "cm")
)

# Row annotation
gene_order_df_DDR_RUV <- all_data_DDR_RUV %>%
  distinct(Gene, Category) %>%
  arrange(factor(Category, levels = sort(unique(entrez_category_DDR$Category))), Gene)

ordered_genes_DDR_RUV <- gene_order_df_DDR_RUV$Gene
logFC_mat_DDR_RUV <- logFC_mat_DDR_RUV[ordered_genes_DDR_RUV, ]
signif_mat_DDR_RUV <- signif_mat_DDR_RUV[ordered_genes_DDR_RUV, ]

category_colors_DDR <- structure(
  c("darkorange", "steelblue", "darkgreen", "firebrick", "gold", "mediumpurple", "gray60"),
  names = sort(unique(entrez_category_DDR$Category))
)

ha_left_DDR_RUV <- rowAnnotation(
  Category = gene_order_df_DDR_RUV$Category,
  col = list(Category = category_colors_DDR),
  annotation_name_side = "top"
)

# Final Heatmap
Heatmap(logFC_mat_DDR_RUV,
        name = "logFC",
        top_annotation = col_annot,
        left_annotation = ha_left_DDR_RUV,
        cluster_columns = FALSE,
        cluster_rows = FALSE,
        show_row_names = TRUE,
        show_column_names = FALSE,
        row_names_gp = gpar(fontsize = 10),
        column_title = "DDR Gene Expression Response (n = 68)\n DOX Recovery (RUVs Corrected)",
        column_title_gp = gpar(fontsize = 14, fontface = "bold"),
        cell_fun = function(j, i, x, y, width, height, fill) {
          grid.text(signif_mat_DDR[i, j], x, y, gp = gpar(fontsize = 9))
        }
)
```


```{r logFC DDR Boxplots RUVs Genes}
library(car)

#get an overall idea of the response occurring in all genes with logFC across time
#start with the logFC and then do the abs logFC

####data setup####
#Read DNA Damage Response Gene List

#this had an extra column that was unncessesary
# DNA_damage <- read.csv("data/new/RUV/DDR_Genes_list_RUV.csv", stringsAsFactors = FALSE) %>% 
#   dplyr::select(-(X))
#   
# names(DNA_damage)[names(DNA_damage) == "x"] <- "Symbol"
#   
#saveRDS(DNA_damage, "data/new/RUV/DNA_damage_genesymbols.RDS")

#this is the final processed version with a single list of symbols with col name
DNA_damage <- readRDS("data/new/RUV/DNA_damage_genesymbols.RDS")

#Convert gene symbols to Entrez IDs
DNA_damage <- DNA_damage %>%
  mutate(Entrez_ID = mapIds(org.Hs.eg.db,
                            keys = Symbol,
                            column = "ENTREZID",
                            keytype = "SYMBOL",
                            multiVals = "first"))

DNA_damage_genes <- na.omit(DNA_damage$Entrez_ID)

time_colors <- c("24T" = "#238B45",
                 "24R" = "#74C476",
                 "144R" = "#C7E9C0")

#load in my DEGs which I'll use to create a combined toptable
load_deg <- function(path) read.csv(path)

DOX_24T_R <- load_deg("data/new/DEGs/Toptable_RUV_24T_final.csv")
DOX_24R_R <- load_deg("data/new/DEGs/Toptable_RUV_24R_final.csv")
DOX_144R_R <- load_deg("data/new/DEGs/Toptable_RUV_144R_final.csv")

all_toptables_RUV <- bind_rows(
  DOX_24T_R %>% mutate(Drug = "DOX", Timepoint = "24T"),
  DOX_24R_R %>% mutate(Drug = "DOX", Timepoint = "24R"),
  DOX_144R_R %>% mutate(Drug = "DOX", Timepoint = "144R"),
)


filtered_toptables_RUV <- all_toptables_RUV %>%
  filter(Entrez_ID %in% DNA_damage_genes)

filtered_toptables_RUV <- filtered_toptables_RUV %>%
  mutate(
    Drug = factor(Drug, levels = c("DOX")),
    Timepoint = factor(Timepoint, levels = c("24T", "24R", "144R"), 
                       labels = c("Timepoint: 24T", "Timepoint: 24R", "Timepoint: 144R"))
  )

levene_results_RUV <- filtered_toptables_RUV %>%
  group_by(Timepoint) %>%
  summarise(p_value = leveneTest(logFC ~ Timepoint, data = .)$`Pr(>F)`[1], .groups = "drop") %>%
  mutate(significance = ifelse(p_value < 0.05, "*", ""))  # Use p < 0.05 threshold for stars

# ** Determine Y-axis position for Stars**
star_positions <- filtered_toptables_RUV %>%
  group_by(Timepoint,Drug) %>%
  summarise(y_pos = max(logFC, na.rm = TRUE) + 0.5, .groups = "drop") %>%
  group_by(Timepoint) %>%
  summarise(y_pos = max(y_pos), .groups = "drop")

# ** Merge Levene test results with Y positions**
levene_results_plot_RUV <- levene_results_RUV %>%
  left_join(star_positions, by = c("Timepoint")) %>%
  mutate(x_position = 1.5)

ggplot(filtered_toptables_RUV, aes(x = Drug, y = logFC, fill = Timepoint)) +
  geom_violin(trim = FALSE, alpha = 0.5) +  # Violin plot for logFC
  geom_boxplot(width = 0.1, outlier.shape = NA, color = "black", alpha = 0.5) +  # Add boxplot inside violin
  scale_fill_manual(values = c(
    "Timepoint: 24T" = "#238B45",
    "Timepoint: 24R" = "#74C476",
    "Timepoint: 144R" = "#C7E9C0")) +  
  facet_grid(Drug ~ Timepoint) +  
  geom_text(
    data = levene_results_plot_RUV %>% filter(significance == "*"),  # Only plot significant comparisons
    aes(x = x_position, y = y_pos, label = significance), 
    size = 6, fontface = "bold", color = "black", inherit.aes = FALSE
  ) +
  theme_bw() +
  xlab("") +
  ylab("Log Fold Change") +  
  ggtitle("LogFC Distribution for DDR Genes") +
  theme(
    plot.title = element_text(size = rel(1.5), hjust = 0.5),
    axis.title = element_text(size = 15, color = "black"),
    axis.line = element_line(linewidth = 1.5),
    strip.background = element_rect(fill = "gray"),  
    strip.text = element_text(size = 12, color = "black", face = "bold"),  
    axis.text.x = element_text(size = 8, color = "black", angle = 0)
  )

```
```{r DDR RUVs Genes Proportion}
# Read DNA Damage Genes List
# DNA_damage
# 
# # Convert gene symbols to Entrez IDs
# DNA_damage <- DNA_damage %>%
#   mutate(Entrez_ID = mapIds(org.Hs.eg.db,
#                             keys = Symbol,
#                             column = "ENTREZID",
#                             keytype = "SYMBOL",
#                             multiVals = "first"))
# 
# # Extract DNA damage gene Entrez IDs
# DNA_damage_genes <- na.omit(DNA_damage$Entrez_ID)
# total_DNA_damage_genes <- length(DNA_damage_genes)  # Total number of DNA damage genes
# 
# # Define DEG lists (with significant ones only)
# DOX_DEGs <- list(
#   "DOX_24T" = DEG1_RUV, "DOX_24R" = DEG2_RUV, "DOX_144R" = DEG3_RUV
# )
# 
# # Function to calculate the presence of DNA damage genes in DEGs 
# calculate_proportion_DDR <- function(deg_list, drug_name) {
#   data.frame(
#     Sample = names(deg_list),
#     Drug = drug_name,
#     DNA_Damage_DEGs = sapply(deg_list, function(ids) sum(ids %in% DNA_damage_genes)),  # DEGs present in DNA damage set
#     Non_DNA_Damage_DEGs = sapply(deg_list, function(ids) total_DNA_damage_genes - sum(ids %in% DNA_damage_genes))  # Remaining DNA damage genes
#   ) %>%
#     mutate(
#       Yes_Proportion = (DNA_Damage_DEGs / total_DNA_damage_genes) * 100,  # Percentage of DEGs in DNA damage genes
#       No_Proportion = (Non_DNA_Damage_DEGs / total_DNA_damage_genes) * 100  # Remaining DNA damage genes as No
#     )
# }
# 
# # Calculate proportions for CX-5461 and DOX
# DOX_proportion <- calculate_proportion_DDR(DOX_DEGs, "DOX")
# 
# # Convert to long format for stacked bar plot
# proportion_long <- DOX_proportion %>%
#   dplyr::select(Sample, Drug, Yes_Proportion, No_Proportion) %>%
#   pivot_longer(cols = c(Yes_Proportion, No_Proportion), names_to = "Category", values_to = "Percentage") %>%
#   mutate(Category = ifelse(Category == "Yes_Proportion", "Yes", "No"))
# 
# # **Ensure correct order of samples on X-axis**
# sample_order <- c(
#   "DOX_24T", "DOX_24R", "DOX_144R"
# )
# proportion_long$Sample <- factor(proportion_long$Sample, levels = sample_order, ordered = TRUE)
# 
# # **Fix: Ensure "Yes" is on top and "No" is at the bottom in stacked bars**
# proportion_long$Category <- factor(proportion_long$Category, levels = c("Yes", "No"))  # Ensures "Yes" on top, "No" at bottom
# 
# # **Perform Chi-Square Test for DOX across timepoints**
# chi_square_results <- data.frame(Sample = character(), P_Value = numeric())
# 
# for (i in seq(1, 6)) {  #comparing across timepoints
#   tx24_sample <- sample_order[i] #DOX24T
#   rec24_sample <- sample_order[i + 6]   #DOX24R
#   rec144_sample <- sample_order[i + 12] #DOX144R
#   
#   tx24_data <- filter(DOX_proportion, Sample == tx24_sample)
#   rec24_data <- filter(DOX_proportion, Sample == rec24_sample)
#   rec144_data <- filter(DOX_proportion, Sample == rec144_sample)
#   
#   # Construct contingency table for Chi-Square test
#   contingency_table <- matrix(
#     c(tx24_data$DNA_Damage_DEGs, tx24_data$Non_DNA_Damage_DEGs,
#       rec24_data$DNA_Damage_DEGs, rec24_data$Non_DNA_Damage_DEGs,
#       rec144_data$DNA_Damage_DEGs, rec144_data$Non_DNA_Damage_DEGs),
#     nrow = 3, byrow = TRUE
#   )
#   
#   # Run Chi-Square Test
#   test_result <- chisq.test(contingency_table)
#   p_value <- test_result$p.value
#   
#   # Store results
#   chi_square_results <- rbind(chi_square_results, data.frame(Sample = tx24_sample, P_Value = p_value))
# }
# 
# # Add significance stars
# chi_square_results$Significant <- ifelse(chi_square_results$P_Value < 0.05, "*", "")
# 
# # Merge Chi-Square results
# proportion_long <- left_join(proportion_long, chi_square_results, by = "Sample")
# 
# # **Save output**
# write.csv(proportion_long, "C:/Work/Postdoc_UTMB/CX-5461 Project/Transcriptome literatures/lit2/Proportion_Stacked_DNA_Damage_DEGs_with_ChiSquare.csv", row.names = FALSE)
# 
# 
# # Define correct factor orders for samples
# sample_order <- c(
#   "CX_0.1_3", "CX_0.1_24", "CX_0.1_48", "CX_0.5_3", "CX_0.5_24", "CX_0.5_48",
#   "DOX_0.1_3", "DOX_0.1_24", "DOX_0.1_48", "DOX_0.5_3", "DOX_0.5_24", "DOX_0.5_48"
# )
# 
# # Reapply factor levels for correct order in both proportion_data and proportion_long
# proportion_data$Sample <- factor(proportion_data$Sample, levels = sample_order, ordered = TRUE)
# proportion_long$Sample <- factor(proportion_long$Sample, levels = sample_order, ordered = TRUE)
# 
# # **Fix: Ensure "Yes" is on top and "No" is at the bottom in stacked bars**
# proportion_long$Category <- factor(proportion_long$Category, levels = c("Yes", "No")
```

```{r logFC DDR Genes RUVs Across Timepoints}
library(rstatix)
# Read DNA Damage Response Gene List
# DNA_damage as above

# Convert gene symbols to Entrez IDs
# DNA_damage <- DNA_damage %>%
#   mutate(Entrez_ID = mapIds(org.Hs.eg.db,
#                             keys = Symbol,
#                             column = "ENTREZID",
#                             keytype = "SYMBOL",
#                             multiVals = "first"))

# DNA_damage_genes <- na.omit(DNA_damage$Entrez_ID)

# saveRDS(DNA_damage_genes, "data/new/RUV/DNA_damage_genes_symbolentrez.RDS")

DNA_damage_genes <- readRDS("data/new/RUV/DNA_damage_genes_symbolentrez.RDS")

all_toptables_RUV <- bind_rows(
  DOX_24T_R %>% mutate(Drug = "DOX", Timepoint = "24T"),
  DOX_24R_R %>% mutate(Drug = "DOX", Timepoint = "24R"),
  DOX_144R_R %>% mutate(Drug = "DOX", Timepoint = "144R"),
)

filtered_toptables_RUV <- all_toptables_RUV %>%
  filter(Entrez_ID %in% DNA_damage_genes) %>%
  mutate(abs_logFC = abs(logFC))

filtered_toptables_RUV <- filtered_toptables_RUV %>%
  mutate(
    Drug = factor(Drug, levels = c("DOX")),
    Timepoint = factor(Timepoint, levels = c("24T", "24R", "144R"), 
                       labels = c("Timepoint: 24T", "Timepoint: 24R", "Timepoint: 144R"))
  )

wilcox_results <- filtered_toptables_RUV %>%
  wilcox_test(abs_logFC ~ Timepoint) %>%
  adjust_pvalue(method = "bonferroni") %>%
  mutate(significance = ifelse(p < 0.05, "*", ""))

#make a little thing of your timepoint comparisons
pairs <- wilcox_results %>% 
  dplyr::select(group1, group2) %>% 
  distinct()

max_per_timepoint <- filtered_toptables_RUV %>% 
  group_by(Timepoint) %>% 
  summarise(max_logFC = max(abs_logFC, na.rm = TRUE), .groups = "drop")
  
#Join max values for group1
star_positions <- pairs %>%
  left_join(max_per_timepoint, by = c("group1" = "Timepoint"))
names(star_positions)[names(star_positions) == "max_logFC"] <- "max1"

#Join max values for group2, with suffixes to avoid name conflict
star_positions <- star_positions %>%
  left_join(max_per_timepoint, by = c("group2" = "Timepoint"), suffix = c(".group1", ".group2"))
names(star_positions)[names(star_positions) == "max_logFC"] <- "max2"

star_positions <- star_positions %>% 
  mutate(y_pos = pmax(max1, max2, na.rm = TRUE) + 0.2)

#now star positions has the same group1 and group2 as wilcoxon

wilcox_results_plot <- wilcox_results %>%
  left_join(star_positions, by = c("group1", "group2")) %>%
  mutate(x_position = 1.5)  

wilcox_results_plot <- wilcox_results_plot %>% 
  mutate(group1 = gsub("Timepoint: ", "", group1),
         group2 = gsub("Timepoint: ", "", group2))

wilcox_results_plot <- wilcox_results_plot %>%
  mutate(x_position = case_when(
    group1 == "24T" & group2 == "24R" ~ 1.5,
    group1 == "24T" & group2 == "144R" ~ 2,
    group1 == "24R" & group2 == "144R" ~ 2.5
  ))

ggplot(filtered_toptables_RUV, aes(x = Timepoint, y = logFC, fill = Timepoint)) +
  geom_boxplot() +
  scale_fill_manual(values = c(
    "Timepoint: 24T" = "#238B45",
    "Timepoint: 24R" = "#74C476",
    "Timepoint: 144R" = "#C7E9C0")) +  
  facet_wrap(~ Drug) +  
  geom_text(
    data = wilcox_results_plot, 
    aes(x = x_position, y = y_pos, label = significance), 
    size = 6, fontface = "bold", color = "black", inherit.aes = FALSE
  ) +
  theme_bw() +
  xlab("") +
  ylab("Log Fold Change") +  
  ggtitle("Log Fold Change for DDR Genes") +
  theme(
    plot.title = element_text(size = rel(1.5), hjust = 0.5),
    axis.title = element_text(size = 15, color = "black"),
    axis.line = element_line(linewidth = 1.5),
    strip.background = element_rect(fill = "gray"),  
    strip.text = element_text(size = 12, color = "black", face = "bold"),  
    axis.text.x = element_text(size = 8, color = "black", angle = 0)
  )
```



```{r RUVs DIC Genes logFC HM}
#plot a list of 29 functionally validated DIC genes
# Load DEG files
load_deg <- function(path) read.csv(path)

DOX_24T_R <- load_deg("data/new/DEGs/Toptable_RUV_24T_final.csv")
DOX_24R_R <- load_deg("data/new/DEGs/Toptable_RUV_24R_final.csv")
DOX_144R_R <- load_deg("data/new/DEGs/Toptable_RUV_144R_final.csv")

#the data I have is in hgnc_symbols, I want to convert this to entrez_id like my df
DIC_genes <- tribble(
  ~SYMBOL, ~Category,
  "CAT", "ROS Generation / Handling",
  "CBR1", "ROS Generation / Handling",
  "CBR3", "ROS Generation / Handling",
  "ERBB2", "ROS Generation / Handling",
  "GPX3", "ROS Generation / Handling",
  "GSTM1", "ROS Generation / Handling",
  "GSTP", "ROS Generation / Handling",
  "HAS3", "ROS Generation / Handling",
  "NOS3", "ROS Generation / Handling",
  "PLCE1", "ROS Generation / Handling",
  "RAC2", "ROS Generation / Handling",
  "SPG7", "ROS Generation / Handling",
  "PRDM2", "DNA Damage", 
  "MLH1", "DNA Damage",
  "RARG", "DNA Damage",
  "HFE", "Iron Uptake & Homeostasis",
  "SLC22A17", "DOX Uptake",
  "SLC28A1", "DOX Uptake",
  "SLC28A3", "DOX Uptake",
  "ABCB4", "DOX Efflux",
  "ABCC2", "DOX Efflux",
  "ABCC5", "DOX Efflux", 
  "ABCC9", "DOX Efflux",
  "ABCC10", "DOX Efflux",
  "CELF4", "Calcium Handling",
  "MYH7", "Calcium Handling",
  "CYP2J2", "Cardiac Electrical Activity",
  "RIN3", "Cardiac Electrical Activity",
  "ZFN521", "Cardiac Electrical Activity")

gene_df_DIC_RUV <- tibble(HGNC = DIC_genes)

gene_df_DIC_RUV <- gene_df_DIC_RUV %>% 
  mutate(Entrez_ID = mapIds(org.Hs.eg.db,
                            keys = DIC_genes$SYMBOL,
                            column = "ENTREZID", 
                            keytype = "SYMBOL", 
                            multiVals = "first")) %>% 
  unnest_wider(HGNC) %>% 
  mutate(Entrez_ID = as.character(Entrez_ID))

#now I've put together a dataframe with the HGNC, Category, and Entrez_ID
#plus I've ensured that Entrez_ID is a character for later joining

entrez_ids_DIC_RUV <- gene_df_DIC_RUV$Entrez_ID

# Extract relevant DEG values
extract_data_DIC_RUV <- function(df, name) {
  df %>%
    filter(Entrez_ID %in% entrez_ids_DIC_RUV) %>%
    mutate(
      Gene = mapIds(org.Hs.eg.db, as.character(Entrez_ID),
                    column = "SYMBOL", keytype = "ENTREZID", multiVals = "first"),
      Condition = name,
      Signif = ifelse(adj.P.Val < 0.05, "*", "")
    )
}

# DEG list
deg_list_RUV <- list("DOX_24T" = DOX_24T_R, 
                 "DOX_24R" = DOX_24R_R, 
                 "DOX_144R" = DOX_144R_R
)

# Combine all DEGs and annotate
all_data_DIC_RUV <- bind_rows(mapply(extract_data_DIC_RUV, 
                             deg_list_RUV, 
                             names(deg_list_RUV), 
                             SIMPLIFY = FALSE)) %>%
  mutate(Entrez_ID = as.character(Entrez_ID)) %>% 
  left_join(gene_df_DIC_RUV, 
            by = "Entrez_ID")
#I've also made sure here that Entrez_ID is a character and not an integer

# Create matrices
logFC_matdic_RUV <- acast(all_data_DIC_RUV, Gene ~ Condition, value.var = "logFC")
signif_matdic_RUV <- acast(all_data_DIC_RUV, Gene ~ Condition, value.var = "Signif")

# Set desired order
desired_order <- c("DOX_24T",
                   "DOX_24R",
                   "DOX_144R")

logFC_mat_DIC_RUV <- logFC_matdic_RUV[, desired_order, drop = FALSE]
signif_mat_DIC_RUV <- signif_matdic_RUV[, desired_order, drop = FALSE]

# Column annotation
meta_DIC_R <- str_split_fixed(colnames(logFC_mat_DIC_RUV), "_", 3)
meta_DIC_R <- str_split_fixed(colnames(logFC_mat_DIC_RUV), "_", 2)
col_annot_RUV <- HeatmapAnnotation(
  Drug = meta_DIC_R[, 1],
  Time = meta_DIC_R[, 2],
  col = list(
    Drug = c("DOX" = "#499FBD"),
    Time = c("24T" = "#238B45", 
             "24R" = "#74C476", 
             "144R" = "#C7E9C0")
  ),
  annotation_height = unit(c(2, 2, 2), "cm")
)
#for this I can leave off the DMSO as it's already from a pairwise comparison

#make an extra object with my category order as well
category_order_DIC <- c(
  "ROS Generation / Handling",
  "DNA Damage",
  "Calcium Handling",
  "DOX Uptake",
  "Iron Uptake & Homeostasis",
  "DOX Efflux",
  "Cardiac Electrical Activity"
)

# Row annotation
gene_order_df_DIC_RUV <- all_data_DIC_RUV %>%
  distinct(Gene, Category) %>%
  mutate(Category = factor(Category, levels = category_order_DIC)) %>% 
  arrange(Category, Gene)

ordered_genes_DIC_RUV <- gene_order_df_DIC_RUV$Gene
logFC_mat_DIC_RUV <- logFC_mat_DIC_RUV[ordered_genes_DIC_RUV, ]
signif_mat_DIC_RUV <- signif_mat_DIC_RUV[ordered_genes_DIC_RUV, ]

#add in your colors for each category
 category_colors_DIC <- structure(
  c("darkorange", "steelblue", "darkgreen", "firebrick", "gold", "mediumpurple", "gray60"),
  names = category_order_DIC
)

ha_left_DIC_RUV <- rowAnnotation(
  Category = gene_order_df_DIC_RUV$Category,
  col = list(Category = category_colors_DIC),
  annotation_name_side = "top"
)

# Draw heatmap
Heatmap(logFC_mat_DIC_RUV,
        name = "logFC",
        top_annotation = col_annot,
        left_annotation = ha_left_DIC_RUV,
        cluster_columns = FALSE,
        cluster_rows = FALSE,
        show_row_names = TRUE,
        show_column_names = FALSE,
        cell_fun = function(j, i, x, y, width, height, fill) {
          grid.text(signif_mat_DIC[i, j], x, y, gp = gpar(fontsize = 9))
        },
        column_title = "DIC Genes Expression (n=29)\nDOX Recovery (RUVs Corrected)",
        column_title_gp = gpar(fontsize = 14, fontface = "bold")
)
```

```{r logFC Boxplots DIC RUVs Genes}
#get an overall idea of the logFC of these genes over timepoints

```


```{r RUVs p53 Target Genes logFC HM, fig.height=50, fig.width=10}
# Load libraries

# Load DEG files
load_deg <- function(path) read.csv(path)

DOX_24T_R <- load_deg("data/new/DEGs/Toptable_RUV_24T_final.csv")
DOX_24R_R <- load_deg("data/new/DEGs/Toptable_RUV_24R_final.csv")
DOX_144R_R <- load_deg("data/new/DEGs/Toptable_RUV_144R_final.csv")


#P53 target Entrez_ID
entrez_ids_p53 <- c(1026,50484,4193,9766,9518,7832,1643,1647,1263,57103,51065,8795,51499,64393,581,
                5228,5429,8493,55959,7508,64782,282991,355,53836,4814,10769,9050,27244,9540,94241,
                26154,57763,900,26999,55332,26263,23479,23612,29950,9618,10346,8824,134147,55294,
                22824,4254,6560,467,27113,60492,8444,60401,1969,220965,2232,3976,55191,84284,93129,
                5564,7803,83667,7779,132671,7039,51768,137695,93134,7633,10973,340485,307,27350,
                23245,3732,29965,1363,1435,196513,8507,8061,2517,51278,53354,54858,23228,5366,5912,
                6236,51222,26152,59,1907,50650,91012,780,9249,11072,144455,64787,116151,27165,2876,
                57822,55733,57722,121457,375449,85377,4851,5875,127544,29901,84958,8797,8793,441631,
                220001,54541,5889,5054,25816,25987,5111,98,317,598,604,10904,1294,80315,53944,
                1606,2770,3628,3675,3985,4035,4163,84552,29085,55367,5371,5791,54884,5980,8794,
                1462,50808,220,583,694,1056,9076,10978,54677,1612,55040,114907,2274,127707,4000,
                8079,4646,4747,27445,5143,80055,79156,5360,5364,23654,5565,5613,5625,10076,56963,
                6004,390,255488,6326,6330,23513,7869,283130,204962,83959,6548,6774,9263,10228,
                22954,10475,85363,494514,10142,79714,1006,8446,9648,79828,5507,55240,63874,25841,
                9289,84883,154810,51321,421,8553,655,119032,84280,10950,824,839,57828,857,8812,
                8837,94027,113189,22837,132864,10898,3300,81704,1847,1849,1947,9538,24139,5168,
                147965,115548,9873,23768,2632,2817,3280,3265,23308,3490,51477,182,3856,8844,144811,
                9404,4043,9848,2872,23041,740,343263,4638,26509,4792,22861,57523,55214,80025,164091,
                57060,64065,51090,5453,8496,333926,55671,5900,55544,23179,8601,389,6223,55800,6385,
                4088,6643,122809,257397,285343,7011,54790,374618,55362,51754,7157,9537,22906,7205,
                80705,219699,55245,83719,7748,25946,118738)

# Function to extract relevant data
extract_data_p53_RUV <- function(df, name) {
  df %>%
    filter(Entrez_ID %in% entrez_ids_p53) %>%
    mutate(Gene = mapIds(org.Hs.eg.db, as.character(Entrez_ID),
                         column = "SYMBOL", keytype = "ENTREZID", multiVals = "first"),
           Condition = name,
           Signif = ifelse(adj.P.Val < 0.05, "*", ""))
}

# Collect all data
# DEG list
deg_list_RUV <- list("DOX_24T" = DOX_24T_R, 
                 "DOX_24R" = DOX_24R_R, 
                 "DOX_144R" = DOX_144R_R
)

# Combine all DEGs and annotate
all_data_p53_RUV <- bind_rows(mapply(extract_data_p53_RUV, deg_list_RUV, names(deg_list_RUV), SIMPLIFY = FALSE)) 
#unnecessary to join again as there are not categories on this list of entrezids
# %>%
#   left_join(entrez_ids, by = c("Entrez_ID" = "ENTREZID"))

# Create matrices
logFC_mat53_RUV <- acast(all_data_p53_RUV, Gene ~ Condition, value.var = "logFC")
signif_mat53_RUV <- acast(all_data_p53_RUV, Gene ~ Condition, value.var = "Signif")

# Desired column order
desired_order <- c("DOX_24T",
                   "DOX_24R",
                   "DOX_144R")

logFC_mat_p53_RUV <- logFC_mat53_RUV[, desired_order]
signif_mat_p53_RUV <- signif_mat53_RUV[, desired_order]

# Column annotation
meta_p53_RUV <- str_split_fixed(colnames(logFC_mat_p53_RUV), "_", 3)
meta_p53_RUV <- str_split_fixed(colnames(logFC_mat_p53_RUV), "_", 2)
col_annot_p53_RUV <- HeatmapAnnotation(
  Drug = meta_p53_RUV[, 1],
  Time = meta_p53_RUV[, 2],
  col = list(
    Drug = c("DOX" = "#499FBD"),
    Time = c("24T" = "#238B45", 
             "24R" = "#74C476", 
             "144R" = "#C7E9C0")
  ),
  annotation_height = unit(c(1, 1, 1), "cm")
)

# Draw heatmap
Heatmap(logFC_mat_p53_RUV,
        name = "logFC",
        top_annotation = col_annot,
        cluster_columns = FALSE,
        cluster_rows = TRUE,
        show_row_names = TRUE,
        show_column_names = FALSE,
        layer_fun = function(j, i, x, y, width, height, fill) {
          grid.text(signif_mat_p53_RUV[cbind(i, j)], x, y, gp = gpar(fontsize = 9))
        },
        column_title = "P53 Target Genes Expression\nDOX Recovery (RUVs Corrected)",
        column_title_gp = gpar(fontsize = 14, fontface = "bold")
)

```


```{r Read and Process DEGs Data}
#read in boxplot1 for my log2cpm data
boxplot1 <- read.csv("data/new/filcpm_final_matrix.csv") %>% 
  as.data.frame()
#this dataframe is unchanged

# Load Toptables
deg_files_ruv <- list.files("data/new/DEGs", pattern = "Toptable_RUV.*\\.csv", full.names = TRUE)
deg_list_ruv <- lapply(deg_files_ruv, read.csv)
names(deg_list_ruv) <- gsub("data/DEGs/Toptable_|\\.csv", "", deg_files_ruv)  

# Function to check significance based on **Entrez_ID in the correct sample**
is_significant <- function(gene, drug, conc, timepoint) {
  condition <- paste(drug, conc, timepoint, sep = "_")
  if (!condition %in% names(deg_list_ruv)) return(FALSE)
  
  toptable <- deg_list[[condition]]
  gene_entrez <- boxplot1$ENTREZID[boxplot1$SYMBOL == gene]
  
  if (length(gene_entrez) == 0) return(FALSE)
  
  return(any(gene_entrez %in% toptable$Entrez_ID[toptable$adj.P.Val < 0.05]))
}

```

```{r Process Data for Plotting RUVs logFC Boxplots}

process_gene_data_DDR_RUVs_boxplots <- function(gene) {
  gene_data_boxplots_RUVs <- boxplot1 %>% filter(SYMBOL == gene)
  # Reshape data
  long_data_RUV_DDR <- gene_data_boxplots_RUVs %>%
    pivot_longer(cols = -c(Entrez_ID, SYMBOL), names_to = "Sample", values_to = "log2CPM") %>%
    mutate(
      Drug = case_when(
        grepl("DOX", Sample) ~ "DOX",
        grepl("DMSO", Sample) ~ "DMSO",
        TRUE ~ NA_character_
      ),
      Timepoint = case_when(
        grepl("_24T_", Sample) ~ "24T",
        grepl("_24R_", Sample) ~ "24R",
        grepl("_144R_", Sample) ~ "144R",
        TRUE ~ NA_character_
      ),
      Indv = case_when(
        grepl("Ind1$", Sample) ~ "1",
        grepl("Ind2$", Sample) ~ "2",
        grepl("Ind3$", Sample) ~ "3",
        grepl("Ind4$", Sample) ~ "4",
        grepl("Ind5$", Sample) ~ "5",
        grepl("Ind6$", Sample) ~ "6",
        grepl("Ind6R$", Sample) ~ "6R",
        TRUE ~ NA_character_
      ),
      Condition = paste(Drug, Timepoint, Indv, sep = "_")
    )
  long_data$Condition <- factor(
    long_data$Condition,
    levels = c(
      "DOX_24T", 
      "DMSO_24T", 
      "DOX_24R", 
      "DMSO_24R", 
      "DOX_144R", 
      "DMSO_144R"
    )
  )
    # Identify significant conditions **per Drug, Conc, and Timepoint**
  significance_labels <- long_data_RUV_DDR %>%
    distinct(Drug, Timepoint, Indv) %>%
    rowwise() %>%
    mutate(
      max_log2CPM = max(long_data_RUV_DDR$log2CPM[long_data_RUV_DDR$Condition == Condition], na.rm = TRUE),
      Significance = ifelse(is_significant(gene, Drug, Timepoint, Indv), "*", "")
    ) %>%
    filter(Significance != "") %>% ungroup()
  
  list(long_data_RUV_DDR = long_data_RUV_DDR, significance_labels = significance_labels)
}

#####now I can go ahead and generate boxplots as requested
#want one for DDR, one for DIC, and one for p53

#genelists:
DDR_genes_ruv <- all_data_DDR_RUV$Gene
DIC_genes_ruv <- all_data_DIC_RUV$Gene
p53_genes_ruv <- all_data_p53_RUV$Gene

# #Generate Boxplots from the above function using our gene lists above
# for (gene in boxplot1) {
#   gene_data_boxplots_RUVs <- process_top5_D24R_1(gene)
#   p <- ggplot(gene_data_boxplots_RUVs, aes(x = Condition, y = log2cpm, fill = Drug)) +
#     geom_boxplot(outlier.shape = NA) +
#     geom_point(aes(color = Indv), size = 2, alpha = 0.5, position = position_jitter(width = -1, height = 0)) +
#     scale_fill_manual(values = c("DOX" = "#499FBD", "DMSO" = "#BBBBBC")) +
#     ggtitle(paste("Log2cpm", gene, "top5DEGs D24R RUVs")) +
#     labs(x = "Treatment", y = "log2cpm") +
#     theme_bw() +
#     theme(
#       plot.title = element_text(size = rel(2), hjust = 0.5),
#       axis.title = element_text(size = 15, color = "black"),
#       axis.text.x = element_text(size = 10, color = "black", angle = 90, hjust = 1)
#     )
#   print(p)
# }

```


```{r Cormotif Function}
## Fit limma model using code as it is found in the original cormotif code. It has
## only been modified to add names to the matrix of t values, as well as the
## limma fits

limmafit.default <- function(exprs,groupid,compid) {
  limmafits  <- list()
  compnum    <- nrow(compid)
  genenum    <- nrow(exprs)
  limmat     <- matrix(0,genenum,compnum)
  limmas2    <- rep(0,compnum)
  limmadf    <- rep(0,compnum)
  limmav0    <- rep(0,compnum)
  limmag1num <- rep(0,compnum)
  limmag2num <- rep(0,compnum)

  rownames(limmat)  <- rownames(exprs)
  colnames(limmat)  <- rownames(compid)
  names(limmas2)    <- rownames(compid)
  names(limmadf)    <- rownames(compid)
  names(limmav0)    <- rownames(compid)
  names(limmag1num) <- rownames(compid)
  names(limmag2num) <- rownames(compid)

  for(i in 1:compnum) {
    selid1 <- which(groupid == compid[i,1])
    selid2 <- which(groupid == compid[i,2])
    eset   <- new("ExpressionSet", exprs=cbind(exprs[,selid1],exprs[,selid2]))
    g1num  <- length(selid1)
    g2num  <- length(selid2)
    designmat <- cbind(base=rep(1,(g1num+g2num)), delta=c(rep(0,g1num),rep(1,g2num)))
    fit <- lmFit(eset,designmat)
    fit <- eBayes(fit)
    limmat[,i] <- fit$t[,2]
    limmas2[i] <- fit$s2.prior
    limmadf[i] <- fit$df.prior
    limmav0[i] <- fit$var.prior[2]
    limmag1num[i] <- g1num
    limmag2num[i] <- g2num
    limmafits[[i]] <- fit

    # log odds
    # w<-sqrt(1+fit$var.prior[2]/(1/g1num+1/g2num))
    # log(0.99)+dt(fit$t[1,2],g1num+g2num-2+fit$df.prior,log=TRUE)-log(0.01)-dt(fit$t[1,2]/w, g1num+g2num-2+fit$df.prior, log=TRUE)+log(w)
  }
  names(limmafits) <- rownames(compid)
  limmacompnum<-nrow(compid)
  result<-list(t       = limmat,
               v0      = limmav0,
               df0     = limmadf,
               s20     = limmas2,
               g1num   = limmag1num,
               g2num   = limmag2num,
               compnum = limmacompnum,
               fits    = limmafits)
}

limmafit.counts <-
  function (exprs, groupid, compid, norm.factor.method = "TMM", voom.normalize.method = "none")
  {
    limmafits  <- list()
    compnum    <- nrow(compid)
    genenum    <- nrow(exprs)
    limmat     <- matrix(NA,genenum,compnum)
    limmas2    <- rep(0,compnum)
    limmadf    <- rep(0,compnum)
    limmav0    <- rep(0,compnum)
    limmag1num <- rep(0,compnum)
    limmag2num <- rep(0,compnum)

    rownames(limmat)  <- rownames(exprs)
    colnames(limmat)  <- rownames(compid)
    names(limmas2)    <- rownames(compid)
    names(limmadf)    <- rownames(compid)
    names(limmav0)    <- rownames(compid)
    names(limmag1num) <- rownames(compid)
    names(limmag2num) <- rownames(compid)

    for (i in 1:compnum) {
      message(paste("Running limma for comparision",i,"/",compnum))
      selid1 <- which(groupid == compid[i, 1])
      selid2 <- which(groupid == compid[i, 2])
      # make a new count data frame
      counts <- cbind(exprs[, selid1], exprs[, selid2])

      # remove NAs
      not.nas <- which(apply(counts, 1, function(x) !any(is.na(x))) == TRUE)

      # runn voom/limma
      d <- DGEList(counts[not.nas,])
      d <- calcNormFactors(d, method = norm.factor.method)
      g1num <- length(selid1)
      g2num <- length(selid2)
      designmat <- cbind(base = rep(1, (g1num + g2num)), delta = c(rep(0,
                                                                       g1num), rep(1, g2num)))

      y <- voom(d, designmat, normalize.method = voom.normalize.method)
      fit <- lmFit(y, designmat)
      fit <- eBayes(fit)

      limmafits[[i]] <- fit
      limmat[not.nas, i] <- fit$t[, 2]
      limmas2[i] <- fit$s2.prior
      limmadf[i] <- fit$df.prior
      limmav0[i] <- fit$var.prior[2]
      limmag1num[i] <- g1num
      limmag2num[i] <- g2num
    }
    limmacompnum <- nrow(compid)
    names(limmafits) <- rownames(compid)
    result <- list(t       = limmat,
                   v0      = limmav0,
                   df0     = limmadf,
                   s20     = limmas2,
                   g1num   = limmag1num,
                   g2num   = limmag2num,
                   compnum = limmacompnum,
                   fits    = limmafits)
  }

limmafit.list <-
  function (fitlist, cmp.idx=2)
  {
    compnum    <- length(fitlist)

    genes <- c()
    for (i in 1:compnum) genes <- unique(c(genes, rownames(fitlist[[i]])))

    genenum    <- length(genes)
    limmat     <- matrix(NA,genenum,compnum)
    limmas2    <- rep(0,compnum)
    limmadf    <- rep(0,compnum)
    limmav0    <- rep(0,compnum)
    limmag1num <- rep(0,compnum)
    limmag2num <- rep(0,compnum)

    rownames(limmat)  <- genes
    colnames(limmat)  <- names(fitlist)
    names(limmas2)    <- names(fitlist)
    names(limmadf)    <- names(fitlist)
    names(limmav0)    <- names(fitlist)
    names(limmag1num) <- names(fitlist)
    names(limmag2num) <- names(fitlist)

    for (i in 1:compnum) {
      this.t <- fitlist[[i]]$t[,cmp.idx]
      limmat[names(this.t),i] <- this.t

      limmas2[i]    <- fitlist[[i]]$s2.prior
      limmadf[i]    <- fitlist[[i]]$df.prior
      limmav0[i]    <- fitlist[[i]]$var.prior[cmp.idx]
      limmag1num[i] <- sum(fitlist[[i]]$design[,cmp.idx]==0)
      limmag2num[i] <- sum(fitlist[[i]]$design[,cmp.idx]==1)
    }

    limmacompnum <- compnum
    result <- list(t       = limmat,
                   v0      = limmav0,
                   df0     = limmadf,
                   s20     = limmas2,
                   g1num   = limmag1num,
                   g2num   = limmag2num,
                   compnum = limmacompnum,
                   fits    = limmafits)

  }

## Rank genes based on statistics
generank<-function(x) {
  xcol<-ncol(x)
  xrow<-nrow(x)
  result<-matrix(0,xrow,xcol)
  z<-(1:1:xrow)
  for(i in 1:xcol) {
    y<-sort(x[,i],decreasing=TRUE,na.last=TRUE)
    result[,i]<-match(x[,i],y)
    result[,i]<-order(result[,i])
  }
  result
}

## Log-likelihood for moderated t under H0
modt.f0.loglike<-function(x,df) {
  a<-dt(x, df, log=TRUE)
  result<-as.vector(a)
  flag<-which(is.na(result)==TRUE)
  result[flag]<-0
  result
}

## Log-likelihood for moderated t under H1
## param=c(df,g1num,g2num,v0)
modt.f1.loglike<-function(x,param) {
  df<-param[1]
  g1num<-param[2]
  g2num<-param[3]
  v0<-param[4]
  w<-sqrt(1+v0/(1/g1num+1/g2num))
  dt(x/w, df, log=TRUE)-log(w)
  a<-dt(x/w, df, log=TRUE)-log(w)
  result<-as.vector(a)
  flag<-which(is.na(result)==TRUE)
  result[flag]<-0
  result
}

## Correlation Motif Fit
cmfit.X<-function(x, type, K=1, tol=1e-3, max.iter=100) {
  ## initialize
  xrow <- nrow(x)
  xcol <- ncol(x)
  loglike0 <- list()
  loglike1 <- list()
  p <- rep(1, K)/K
  q <- matrix(runif(K * xcol), K, xcol)
  q[1, ] <- rep(0.01, xcol)
  for (i in 1:xcol) {
    f0 <- type[[i]][[1]]
    f0param <- type[[i]][[2]]
    f1 <- type[[i]][[3]]
    f1param <- type[[i]][[4]]
    loglike0[[i]] <- f0(x[, i], f0param)
    loglike1[[i]] <- f1(x[, i], f1param)
  }
  condlike <- list()
  for (i in 1:xcol) {
    condlike[[i]] <- matrix(0, xrow, K)
  }
  loglike.old <- -1e+10
  for (i.iter in 1:max.iter) {
    if ((i.iter%%50) == 0) {
      print(paste("We have run the first ", i.iter, " iterations for K=",
                  K, sep = ""))
    }
    err <- tol + 1
    clustlike <- matrix(0, xrow, K)
    #templike <- matrix(0, xrow, 2)
    templike1 <- rep(0, xrow)
    templike2 <- rep(0, xrow)
    for (j in 1:K) {
      for (i in 1:xcol) {
        templike1 <- log(q[j, i]) + loglike1[[i]]
        templike2 <- log(1 - q[j, i]) + loglike0[[i]]
        tempmax <- Rfast::Pmax(templike1, templike2)

        templike1 <- exp(templike1 - tempmax)
        templike2 <- exp(templike2 - tempmax)

        tempsum <- templike1 + templike2
        clustlike[, j] <- clustlike[, j] + tempmax +
          log(tempsum)
        condlike[[i]][, j] <- templike1/tempsum
      }
      clustlike[, j] <- clustlike[, j] + log(p[j])
    }
    #tempmax <- apply(clustlike, 1, max)
    tempmax <- Rfast::rowMaxs(clustlike, value=TRUE)
    for (j in 1:K) {
      clustlike[, j] <- exp(clustlike[, j] - tempmax)
    }
    #tempsum <- apply(clustlike, 1, sum)
    tempsum <- Rfast::rowsums(clustlike)
    for (j in 1:K) {
      clustlike[, j] <- clustlike[, j]/tempsum
    }
    #p.new <- (apply(clustlike, 2, sum) + 1)/(xrow + K)
    p.new <- (Rfast::colsums(clustlike) + 1)/(xrow + K)
    q.new <- matrix(0, K, xcol)
    for (j in 1:K) {
      clustpsum <- sum(clustlike[, j])
      for (i in 1:xcol) {
        q.new[j, i] <- (sum(clustlike[, j] * condlike[[i]][,
                                                           j]) + 1)/(clustpsum + 2)
      }
    }
    err.p <- max(abs(p.new - p)/p)
    err.q <- max(abs(q.new - q)/q)
    err <- max(err.p, err.q)
    loglike.new <- (sum(tempmax + log(tempsum)) + sum(log(p.new)) +
                      sum(log(q.new) + log(1 - q.new)))/xrow
    p <- p.new
    q <- q.new
    loglike.old <- loglike.new
    if (err < tol) {
      break
    }
  }
  clustlike <- matrix(0, xrow, K)
  for (j in 1:K) {
    for (i in 1:xcol) {
      templike1 <- log(q[j, i]) + loglike1[[i]]
      templike2 <- log(1 - q[j, i]) + loglike0[[i]]
      tempmax <- Rfast::Pmax(templike1, templike2)

      templike1 <- exp(templike1 - tempmax)
      templike2 <- exp(templike2 - tempmax)

      tempsum <- templike1 + templike2
      clustlike[, j] <- clustlike[, j] + tempmax + log(tempsum)
      condlike[[i]][, j] <- templike1/tempsum
    }
    clustlike[, j] <- clustlike[, j] + log(p[j])
  }
  #tempmax <- apply(clustlike, 1, max)
  tempmax <- Rfast::rowMaxs(clustlike, value=TRUE)
  for (j in 1:K) {
    clustlike[, j] <- exp(clustlike[, j] - tempmax)
  }
  #tempsum <- apply(clustlike, 1, sum)
  tempsum <- Rfast::rowsums(clustlike)
  for (j in 1:K) {
    clustlike[, j] <- clustlike[, j]/tempsum
  }
  p.post <- matrix(0, xrow, xcol)
  for (j in 1:K) {
    for (i in 1:xcol) {
      p.post[, i] <- p.post[, i] + clustlike[, j] * condlike[[i]][,
                                                                  j]
    }
  }
  loglike.old <- loglike.old - (sum(log(p)) + sum(log(q) +
                                                    log(1 - q)))/xrow
  loglike.old <- loglike.old * xrow
  result <- list(p.post = p.post, motif.prior = p, motif.q = q,
                 loglike = loglike.old, clustlike=clustlike, condlike=condlike)
}

## Fit using (0,0,...,0) and (1,1,...,1)
cmfitall<-function(x, type, tol=1e-3, max.iter=100) {
  ## initialize
  xrow<-nrow(x)
  xcol<-ncol(x)
  loglike0<-list()
  loglike1<-list()
  p<-0.01

  ## compute loglikelihood
  L0<-matrix(0,xrow,1)
  L1<-matrix(0,xrow,1)
  for(i in 1:xcol) {
    f0<-type[[i]][[1]]
    f0param<-type[[i]][[2]]
    f1<-type[[i]][[3]]
    f1param<-type[[i]][[4]]
    loglike0[[i]]<-f0(x[,i],f0param)
    loglike1[[i]]<-f1(x[,i],f1param)
    L0<-L0+loglike0[[i]]
    L1<-L1+loglike1[[i]]
  }


  ## EM algorithm to get MLE of p and q
  loglike.old <- -1e10
  for(i.iter in 1:max.iter) {
    if((i.iter%%50) == 0) {
      print(paste("We have run the first ", i.iter, " iterations",sep=""))
    }
    err<-tol+1

    ## compute posterior cluster membership
    clustlike<-matrix(0,xrow,2)
    clustlike[,1]<-log(1-p)+L0
    clustlike[,2]<-log(p)+L1

    tempmax<-apply(clustlike,1,max)
    for(j in 1:2) {
      clustlike[,j]<-exp(clustlike[,j]-tempmax)
    }
    tempsum<-apply(clustlike,1,sum)

    ## update motif occurrence rate
    for(j in 1:2) {
      clustlike[,j]<-clustlike[,j]/tempsum
    }

    p.new<-(sum(clustlike[,2])+1)/(xrow+2)

    ## evaluate convergence
    err<-abs(p.new-p)/p

    ## evaluate whether the log.likelihood increases
    loglike.new<-(sum(tempmax+log(tempsum))+log(p.new)+log(1-p.new))/xrow

    loglike.old<-loglike.new
    p<-p.new

    if(err<tol) {
      break;
    }
  }

  ## compute posterior p
  clustlike<-matrix(0,xrow,2)
  clustlike[,1]<-log(1-p)+L0
  clustlike[,2]<-log(p)+L1

  tempmax<-apply(clustlike,1,max)
  for(j in 1:2) {
    clustlike[,j]<-exp(clustlike[,j]-tempmax)
  }
  tempsum<-apply(clustlike,1,sum)

  for(j in 1:2) {
    clustlike[,j]<-clustlike[,j]/tempsum
  }

  p.post<-matrix(0,xrow,xcol)
  for(i in 1:xcol) {
    p.post[,i]<-clustlike[,2]
  }

  ## return

  #calculate back loglikelihood
  loglike.old<-loglike.old-(log(p)+log(1-p))/xrow
  loglike.old<-loglike.old*xrow
  result<-list(p.post=p.post, motif.prior=p, loglike=loglike.old)
}

## Fit each dataset separately
cmfitsep<-function(x, type, tol=1e-3, max.iter=100) {
  ## initialize
  xrow<-nrow(x)
  xcol<-ncol(x)
  loglike0<-list()
  loglike1<-list()
  p<-0.01*rep(1,xcol)
  loglike.final<-rep(0,xcol)

  ## compute loglikelihood
  for(i in 1:xcol) {
    f0<-type[[i]][[1]]
    f0param<-type[[i]][[2]]
    f1<-type[[i]][[3]]
    f1param<-type[[i]][[4]]
    loglike0[[i]]<-f0(x[,i],f0param)
    loglike1[[i]]<-f1(x[,i],f1param)
  }

  p.post<-matrix(0,xrow,xcol)

  ## EM algorithm to get MLE of p
  for(coli in 1:xcol) {
    loglike.old <- -1e10
    for(i.iter in 1:max.iter) {
      if((i.iter%%50) == 0) {
        print(paste("We have run the first ", i.iter, " iterations",sep=""))
      }
      err<-tol+1

      ## compute posterior cluster membership
      clustlike<-matrix(0,xrow,2)
      clustlike[,1]<-log(1-p[coli])+loglike0[[coli]]
      clustlike[,2]<-log(p[coli])+loglike1[[coli]]

      tempmax<-apply(clustlike,1,max)
      for(j in 1:2) {
        clustlike[,j]<-exp(clustlike[,j]-tempmax)
      }
      tempsum<-apply(clustlike,1,sum)

      ## evaluate whether the log.likelihood increases
      loglike.new<-sum(tempmax+log(tempsum))/xrow

      ## update motif occurrence rate
      for(j in 1:2) {
        clustlike[,j]<-clustlike[,j]/tempsum
      }

      p.new<-(sum(clustlike[,2]))/(xrow)

      ## evaluate convergence
      err<-abs(p.new-p[coli])/p[coli]
      loglike.old<-loglike.new
      p[coli]<-p.new

      if(err<tol) {
        break;
      }
    }

    ## compute posterior p
    clustlike<-matrix(0,xrow,2)
    clustlike[,1]<-log(1-p[coli])+loglike0[[coli]]
    clustlike[,2]<-log(p[coli])+loglike1[[coli]]

    tempmax<-apply(clustlike,1,max)
    for(j in 1:2) {
      clustlike[,j]<-exp(clustlike[,j]-tempmax)
    }
    tempsum<-apply(clustlike,1,sum)

    for(j in 1:2) {
      clustlike[,j]<-clustlike[,j]/tempsum
    }

    p.post[,coli]<-clustlike[,2]
    loglike.final[coli]<-loglike.old
  }


  ## return
  loglike.final<-loglike.final*xrow
  result<-list(p.post=p.post, motif.prior=p, loglike=loglike.final)
}

## Fit the full model
cmfitfull<-function(x, type, tol=1e-3, max.iter=100) {
  ## initialize
  xrow<-nrow(x)
  xcol<-ncol(x)
  loglike0<-list()
  loglike1<-list()
  K<-2^xcol
  p<-rep(1,K)/K
  pattern<-rep(0,xcol)
  patid<-matrix(0,K,xcol)

  ## compute loglikelihood
  for(i in 1:xcol) {
    f0<-type[[i]][[1]]
    f0param<-type[[i]][[2]]
    f1<-type[[i]][[3]]
    f1param<-type[[i]][[4]]
    loglike0[[i]]<-f0(x[,i],f0param)
    loglike1[[i]]<-f1(x[,i],f1param)
  }
  L<-matrix(0,xrow,K)
  for(i in 1:K)
  {
    patid[i,]<-pattern
    for(j in 1:xcol) {
      if(pattern[j] < 0.5) {
        L[,i]<-L[,i]+loglike0[[j]]
      } else {
        L[,i]<-L[,i]+loglike1[[j]]
      }
    }

    if(i < K) {
      pattern[xcol]<-pattern[xcol]+1
      j<-xcol
      while(pattern[j] > 1) {
        pattern[j]<-0
        j<-j-1
        pattern[j]<-pattern[j]+1
      }
    }
  }

  ## EM algorithm to get MLE of p and q
  loglike.old <- -1e10
  for(i.iter in 1:max.iter) {
    if((i.iter%%50) == 0) {
      print(paste("We have run the first ", i.iter, " iterations",sep=""))
    }
    err<-tol+1

    ## compute posterior cluster membership
    clustlike<-matrix(0,xrow,K)
    for(j in 1:K) {
      clustlike[,j]<-log(p[j])+L[,j]
    }

    tempmax<-apply(clustlike,1,max)
    for(j in 1:K) {
      clustlike[,j]<-exp(clustlike[,j]-tempmax)
    }
    tempsum<-apply(clustlike,1,sum)

    ## update motif occurrence rate
    for(j in 1:K) {
      clustlike[,j]<-clustlike[,j]/tempsum
    }

    p.new<-(apply(clustlike,2,sum)+1)/(xrow+K)

    ## evaluate convergence
    err<-max(abs(p.new-p)/p)

    ## evaluate whether the log.likelihood increases
    loglike.new<-(sum(tempmax+log(tempsum))+sum(log(p.new)))/xrow

    loglike.old<-loglike.new
    p<-p.new

    if(err<tol) {
      break;
    }
  }

  ## compute posterior p
  clustlike<-matrix(0,xrow,K)
  for(j in 1:K) {
    clustlike[,j]<-log(p[j])+L[,j]
  }

  tempmax<-apply(clustlike,1,max)
  for(j in 1:K) {
    clustlike[,j]<-exp(clustlike[,j]-tempmax)
  }
  tempsum<-apply(clustlike,1,sum)

  for(j in 1:K) {
    clustlike[,j]<-clustlike[,j]/tempsum
  }

  p.post<-matrix(0,xrow,xcol)
  for(j in 1:K) {
    for(i in 1:xcol) {
      if(patid[j,i] > 0.5) {
        p.post[,i]<-p.post[,i]+clustlike[,j]
      }
    }
  }

  ## return
  #calculate back loglikelihood
  loglike.old<-loglike.old-sum(log(p))/xrow
  loglike.old<-loglike.old*xrow
  result<-list(p.post=p.post, motif.prior=p, loglike=loglike.old)
}

generatetype<-function(limfitted)
{
  jtype<-list()
  df<-limfitted$g1num+limfitted$g2num-2+limfitted$df0
  for(j in 1:limfitted$compnum)
  {
    jtype[[j]]<-list(f0=modt.f0.loglike, f0.param=df[j], f1=modt.f1.loglike, f1.param=c(df[j],limfitted$g1num[j],limfitted$g2num[j],limfitted$v0[j]))
  }
  jtype
}

cormotiffit <- function(exprs, groupid=NULL, compid=NULL, K=1, tol=1e-3,
                        max.iter=100, BIC=TRUE, norm.factor.method="TMM",
                        voom.normalize.method = "none", runtype=c("logCPM","counts","limmafits"), each=3)
{
  # first I want to do some typechecking. Input can be either a normalized
  # matrix, a count matrix, or a list of limma fits. Dispatch the correct
  # limmafit accordingly.
  # todo: add some typechecking here
  limfitted <- list()
  if (runtype=="counts") {DOX_24T_shared_DEGs
    limfitted <- limmafit.counts(exprs,groupid,compid, norm.factor.method, voom.normalize.method)
  } else if (runtype=="logCPM") {
    limfitted <- limmafit.default(exprs,groupid,compid)
  } else if (runtype=="limmafits") {
    limfitted <- limmafit.list(exprs)
  } else {
    stop("runtype must be one of 'logCPM', 'counts', or 'limmafits'")
  }


  jtype<-generatetype(limfitted)
  fitresult<-list()
  ks <- rep(K, each = each)
  fitresult <- bplapply(1:length(ks), function(i, x, type, ks, tol, max.iter) {
    cmfit.X(x, type, K = ks[i], tol = tol, max.iter = max.iter)
  }, x=limfitted$t, type=jtype, ks=ks, tol=tol, max.iter=max.iter)

  best.fitresults <- list()
  for (i in 1:length(K)) {
    w.k <- which(ks==K[i])
    this.bic <- c()
    for (j in w.k) this.bic[j] <- -2 * fitresult[[j]]$loglike + (K[i] - 1 + K[i] * limfitted$compnum) * log(dim(limfitted$t)[1])
    w.min <- which(this.bic == min(this.bic, na.rm = TRUE))[1]
    best.fitresults[[i]] <- fitresult[[w.min]]
  }
  fitresult <- best.fitresults

  bic <- rep(0, length(K))
  aic <- rep(0, length(K))
  loglike <- rep(0, length(K))
  for (i in 1:length(K)) loglike[i] <- fitresult[[i]]$loglike
  for (i in 1:length(K)) bic[i] <- -2 * fitresult[[i]]$loglike + (K[i] - 1 + K[i] * limfitted$compnum) * log(dim(limfitted$t)[1])
  for (i in 1:length(K)) aic[i] <- -2 * fitresult[[i]]$loglike + 2 * (K[i] - 1 + K[i] * limfitted$compnum)
  if(BIC==TRUE) {
    bestflag=which(bic==min(bic))
  }
  else {
    bestflag=which(aic==min(aic))
  }
  result<-list(bestmotif=fitresult[[bestflag]],bic=cbind(K,bic),
               aic=cbind(K,aic),loglike=cbind(K,loglike), allmotifs=fitresult)

}

cormotiffitall<-function(exprs,groupid,compid, tol=1e-3, max.iter=100)
{
  limfitted<-limmafit(exprs,groupid,compid)
  jtype<-generatetype(limfitted)
  fitresult<-cmfitall(limfitted$t,type=jtype,tol=1e-3,max.iter=max.iter)
}

cormotiffitsep<-function(exprs,groupid,compid, tol=1e-3, max.iter=100)
{
  limfitted<-limmafit(exprs,groupid,compid)
  jtype<-generatetype(limfitted)
  fitresult<-cmfitsep(limfitted$t,type=jtype,tol=1e-3,max.iter=max.iter)
}

cormotiffitfull<-function(exprs,groupid,compid, tol=1e-3, max.iter=100)
{
  limfitted<-limmafit(exprs,groupid,compid)
  jtype<-generatetype(limfitted)
  fitresult<-cmfitfull(limfitted$t,type=jtype,tol=1e-3,max.iter=max.iter)
}

plotIC<-function(fitted_cormotif)
{
  oldpar<-par(mfrow=c(1,2))
  plot(fitted_cormotif$bic[,1], fitted_cormotif$bic[,2], type="b",xlab="Motif Number", ylab="BIC", main="BIC")
  plot(fitted_cormotif$aic[,1], fitted_cormotif$aic[,2], type="b",xlab="Motif Number", ylab="AIC", main="AIC")
}

plotMotif<-function(fitted_cormotif,title="")
{
  layout(matrix(1:2,ncol=2))
  u<-1:dim(fitted_cormotif$bestmotif$motif.q)[2]
  v<-1:dim(fitted_cormotif$bestmotif$motif.q)[1]
  image(u,v,t(fitted_cormotif$bestmotif$motif.q),
        col=gray(seq(from=1,to=0,by=-0.1)),xlab="Study",yaxt = "n",
        ylab="Corr. Motifs",main=paste(title,"pattern",sep=" "))
  axis(2,at=1:length(v))
  for(i in 1:(length(u)+1))
  {
    abline(v=(i-0.5))
  }
  for(i in 1:(length(v)+1))
  {
    abline(h=(i-0.5))
  }
  Ng=10000
  if(is.null(fitted_cormotif$bestmotif$p.post)!=TRUE)
    Ng=nrow(fitted_cormotif$bestmotif$p.post)
  genecount=floor(fitted_cormotif$bestmotif$motif.p*Ng)
  NK=nrow(fitted_cormotif$bestmotif$motif.q)
  plot(0,0.7,pch=".",xlim=c(0,1.2),ylim=c(0.75,NK+0.25),
       frame.plot=FALSE,axes=FALSE,xlab="No. of genes",ylab="", main=paste(title,"frequency",sep=" "))
  segments(0,0.7,fitted_cormotif$bestmotif$motif.p[1],0.7)
  rect(0,1:NK-0.3,fitted_cormotif$bestmotif$motif.p,1:NK+0.3,
       col="dark grey")
  mtext(1:NK,at=1:NK,side=2,cex=0.8)
  text(fitted_cormotif$bestmotif$motif.p+0.15,1:NK,
       labels=floor(fitted_cormotif$bestmotif$motif.p*Ng))
}

```


```{r Cormotif Library}
#Don't load me in if you're using the above function, as it has been modified above
#library(Cormotif)
```


```{r Cormotif Data}

#input the cormotif matrix you're going to use
##this should be tmm normalized log2cpm

#the matrix that I used previously for limma was TMM counts - cpm this
#dge was the name of the DGE list object

cormotif_test <- cpm(dge, log = TRUE)
colnames(cormotif_test) <- (Metadata_2$Final_sample_name)

cormotif_counts <- dge

cormotif_test_df <- cormotif_test %>% 
  as.data.frame() %>% 
  rownames_to_column(., var = "Entrez_ID")

#write.csv(cormotif_test, "data/new/Cormotif_test_matrix.csv")

#reorder my test matrix to match the new groupid I've made
#I want my columns to be in this order:
#DOX24T 1-6, DOX24R 1-6, DOX144R 1-6, DMSO24T 1-6, DMSO24R 1-6, DMSO144R 1-6
Cormotif <- read.csv("data/new/Cormotif_matrix_final.csv")
dim(Cormotif)
#14319 genes across 37 cols (1 is Entrez_ID)
Cormotif_df <- data.frame(Cormotif)

rownames(Cormotif_df) <- Cormotif_df$Entrez_ID
exprs.cormotif <- as.matrix(Cormotif_df[,2:37])
dim(exprs.cormotif)

#put together my group id and comparison id to make the correct comparisons between experimental conditions

#groupid tells which experimental conditions are grouped together
#compid tells which experimental conditions should be compared against one another
##ie DOX24T vs DMSO24T matched control

groupid_csv <- read.csv("data/new/GroupID.csv")
#now I have to make this into a vector (named vector)
groupid <- c(
  DOX_24T_1 = 1, 
  DOX_24T_2 = 1, 
  DOX_24T_3 = 1, 
  DOX_24T_4 = 1, 
  DOX_24T_5 = 1, 
  DOX_24T_6 = 1,
  DOX_24R_1 = 2, 
  DOX_24R_2 = 2, 
  DOX_24R_3 = 2, 
  DOX_24R_4 = 2, 
  DOX_24R_5 = 2, 
  DOX_24R_6 = 2,
  DOX_144R_1 = 3, 
  DOX_144R_2 = 3, 
  DOX_144R_3 = 3, 
  DOX_144R_4 = 3, 
  DOX_144R_5 = 3, 
  DOX_144R_6 = 3,
  DMSO_24T_1 = 4, 
  DMSO_24T_2 = 4, 
  DMSO_24T_3 = 4, 
  DMSO_24T_4 = 4, 
  DMSO_24T_5 = 4, 
  DMSO_24T_6 = 4,
  DMSO_24R_1 = 5, 
  DMSO_24R_2 = 5, 
  DMSO_24R_3 = 5, 
  DMSO_24R_4 = 5, 
  DMSO_24R_5 = 5, 
  DMSO_24R_6 = 5,
  DMSO_144R_1 = 6, 
  DMSO_144R_2 = 6, 
  DMSO_144R_3 = 6, 
  DMSO_144R_4 = 6, 
  DMSO_144R_5 = 6, 
  DMSO_144R_6 = 6
)
#saveRDS(groupid, "data/new/groupidCormotif.RDS")

compid <- data.frame(Cond1 = c(1, 2, 3), Cond2 = c(4, 5, 6))
#saveRDS(compid, "data/new/compidCormotif.RDS")
```

```{r Run Cormotif}
#fit Cormotif model
# set.seed(19191)
#only set the seed ONCE

# motif.fitted_new <- cormotiffit(
#   exprs = exprs.cormotif,
#   groupid = groupid,
#   compid = compid,
#   K = 1:8,
#   max.iter = 1000,
#   BIC = TRUE,
#   runtype = "logCPM"
# )

# saveRDS(motif.fitted, "data/new/motif.fitted_new_250604.RDS")
motif.fitted <- readRDS("data/new/motif.fitted_final_3motif.RDS")
```

```{r Plot Cormotif}

#plot BIC and AIC to see which number of motifs was best for both models
plotIC(motif.fitted)

motif.fitted$bic

#now plot the motifs themselves
plotMotif(motif.fitted, title = "Fitted Motifs for DXR")

#plot the probability legend
myColors <-  rev(c("#FFFFFF", "#E6E6E6" ,"#CCCCCC", "#B3B3B3", "#999999", "#808080", "#666666","#4C4C4C", "#333333", "#191919","#000000"))

plot.new()
legend('bottomleft',fill=myColors, legend =rev(c("0", "0.1", "0.2", "0.3", "0.4",  "0.5", "0.6", "0.7", "0.8","0.9", "1")), box.col="white",title = "Probability\nlegend", horiz=FALSE,title.cex=.8)

```



```{r Extract gene probabilities}
#extract the posterior probability that these DEGs belong to motifs
gene_prob_all <- motif.fitted$bestmotif$p.post
rownames(gene_prob_all) <- rownames(Cormotif_df)

#assign each gene to a motif with max post prob
assigned_motifs <- apply(gene_prob_all, 1, which.max)
max_probs <- apply(gene_prob_all, 1, max)

#combine these into a dataframe - motif assigned genes (p.post)
motif_assignment_df <- gene_prob_all %>%
  as.data.frame() %>%
  rownames_to_column("Gene") %>%
  mutate(
    Assigned_Motif = assigned_motifs[Gene],
    Max_Probability = max_probs[Gene]
  )

#make some histograms of the unfiltered data from Cormotif p.post

gene_prob_all %>% 
  as.data.frame() %>% 
  ggplot(., aes(x = V1))+
  geom_histogram(bins = 50)+
  xlim(0,1)+
  ggtitle("Cormotif Genes p.post Distribution M1")

gene_prob_all %>% 
  as.data.frame() %>% 
  ggplot(., aes(x = V2))+
  geom_histogram(bins = 50)+
  xlim(0,1)+
  ggtitle("Cormotif Genes p.post Distribution M2")

gene_prob_all %>% 
  as.data.frame() %>% 
  ggplot(., aes(x = V3))+
  geom_histogram(bins = 50)+
  xlim(0,1)+
  ggtitle("Cormotif Genes p.post Distribution M3")

#now change the probability cutoffs to get the ideal gene set with no overlaps

# Define gene probability groups
prob_all_1  <- rownames(gene_prob_all[(gene_prob_all[,1] >0.05 & gene_prob_all[,1] <0.3 & gene_prob_all[,2] <0.5 & gene_prob_all[,3] <0.5),])

length(prob_all_1)
#5675

prob_all_2  <- rownames(gene_prob_all[(gene_prob_all[,1] >0.5 & gene_prob_all[,2] <0.5 & gene_prob_all[,3] <0.5),])

length(prob_all_2)
#6353

prob_all_3  <- rownames(gene_prob_all[(gene_prob_all[,1] >0.3 & gene_prob_all[,1] <0.9 & gene_prob_all[,2] >0.5 & gene_prob_all[,3] >0.5),])

length(prob_all_3)
#231 genes with >0.3 <0.9 1

#compare between motif 1 and 2
mf1_genes <- prob_all_1
mf2_genes <- prob_all_2
mf3_genes <- prob_all_3

vennCor <- list(mf1_genes, mf2_genes, mf3_genes)
ggVennDiagram(
  vennCor,
  category.names = c("Motif 1", "Motif 2", "Motif 3")
) + ggtitle("Cormotif Specific and Shared DEGs p.post")+
  theme(
    plot.title = element_text(size = 16, face = "bold"),  # Increase title size
    text = element_text(size = 16)  # Increase text size globally
  )


#extract the cluster likelihood - which DEGs are most likely to be in this cluster
motif_prob <- motif.fitted$bestmotif$clustlike
rownames(motif_prob) <- rownames(gene_prob_all)
#write.csv(motif_prob,"data/new/cormotif_probability_genelist_all.csv")

#make some histograms to look at the distribution of clustlike genes without filtering
motif_prob %>% 
  as.data.frame() %>% 
  ggplot(., aes(x = V1))+
  geom_histogram(bins = 50)+
  xlim(0,1)+
  ggtitle("Cormotif Genes clustlike Distribution M1")

motif_prob %>% 
  as.data.frame() %>% 
  ggplot(., aes(x = V2))+
  geom_histogram(bins = 50)+
  xlim(0,1)+
  ggtitle("Cormotif Genes clustlike Distribution M2")

motif_prob %>% 
  as.data.frame() %>% 
  ggplot(., aes(x = V3))+
  geom_histogram(bins = 50)+
  xlim(0,1)+
  ggtitle("Cormotif Genes clustlike Distribution M3")

####try this Renee's way####
clust1_p <- motif_prob %>%
  as.data.frame() %>%
  filter(V1>0.5 & V2<0.5 & V3<0.5) %>% 
  rownames
clust2_p <- motif_prob %>%
  as.data.frame() %>%
  filter(V2>0.5 & V1<0.5 & V3<0.5) %>% 
  rownames
clust3_p <- motif_prob %>%
  as.data.frame() %>%
  filter(V3>0.5 & V1 <0.5 & V2 <0.5) %>% 
  rownames

length(clust1_p)
#6827 (too many)
length(clust2_p)
#6474
length(clust3_p)
#607

mf1_genes_p <- clust1_p
mf2_genes_p <- clust2_p
mf3_genes_p <- clust3_p

vennCor <- list(mf1_genes_p, mf2_genes_p, mf3_genes_p)
ggVennDiagram(
  vennCor,
  category.names = c("Motif 1", "Motif 2", "Motif 3")
) + ggtitle("Cormotif Specific and Shared DEGs clustlike")+
  theme(
    plot.title = element_text(size = 16, face = "bold"),  # Increase title size
    text = element_text(size = 16)  # Increase text size globally
  )

```


```{r Extract Gene Probability clust then p.post}
#begin with the clustlike cutoffs and then overlay the p.post to check if the genes are present in both

#these filters are the combination of the above analysis to get a gene set that fits in both p.post and clustlike

####motif 1####
#filter 1: clustlike
clust1_genes <- motif_prob %>%
  as.data.frame() %>%
  filter(V1>0.5 & V2<0.5 & V3<0.5) %>% 
  rownames
### Filter 2: Gene-level posterior pattern
prob_filtered_genes_1 <- rownames(gene_prob_all[(gene_prob_all[,1] >0.05 & gene_prob_all[,1] <0.3 & gene_prob_all[,2] <0.5 & gene_prob_all[,3] <0.5),])
### Final intersection of both filters
final_genes_1 <- intersect(clust1_genes, prob_filtered_genes_1)
cat("Number of genes passing both filters:", length(final_genes_1), "\n")

#5638 genes pass both filters here

####motif 2####
#filter 1: clustlike
clust2_genes <- motif_prob %>%
  as.data.frame() %>%
  filter(V2>0.5 & V1<0.5 & V3<0.5) %>% 
  rownames
### Filter 2: Gene-level posterior pattern
prob_filtered_genes_2 <- rownames(gene_prob_all[(gene_prob_all[,1] >0.5 & gene_prob_all[,2] <0.5 & gene_prob_all[,3] <0.5),])
### Final intersection of both filters
final_genes_2 <- intersect(clust2_genes, prob_filtered_genes_2)
cat("Number of genes passing both filters:", length(final_genes_2), "\n")

#6218 genes pass both filters here


####motif3####
#filter 1: clustlike
clust3_genes <- motif_prob %>%
  as.data.frame() %>%
  filter(V3 > 0.5 & V1 < 0.5 & V2 < 0.5) %>%
  rownames()
### Filter 2: Gene-level posterior pattern (Motif 2 & 3 high, Motif 1 intermediate)
prob_filtered_genes <- rownames(gene_prob_all[
  gene_prob_all[,1] > 0.3 & gene_prob_all[,1] < 0.9 &
  gene_prob_all[,2] > 0.5 &
  gene_prob_all[,3] > 0.5, ])
### Final intersection of both filters
final_genes_3 <- intersect(clust3_genes, prob_filtered_genes)
cat("Number of genes passing both filters:", length(final_genes_3), "\n")

#231 genes pass both filters here

#what is the proportion of my genes that are included?
5638+6218+231
#12087
(12087/14319)*100
#84.4% of my genes are represented here out of the 14319 original

#want to find out which genes are not assigned to motifs

final_genes_list <- union(final_genes_1, union(final_genes_2, final_genes_3))
length(final_genes_list)
#12087 genes as found above
initial_genes_list <- rownames(filcpm_matrix)
length(initial_genes_list)
#14319 genes as usual
unassigned_genes_list <- setdiff(initial_genes_list, final_genes_list)
length(unassigned_genes_list)
#2232 genes not assigned - correct number

#saveRDS(unassigned_genes_list, "data/new/Cormotif/unassigned_genes_Cormotif.RDS")

#now, ensure that none of these genes are shared amongst categories
vennCor_final <- list(final_genes_1, final_genes_2, final_genes_3)
ggVennDiagram(
  vennCor_final,
  category.names = c("Motif 1", "Motif 2", "Motif 3")
) + ggtitle("Cormotif Specific and Shared DEGs clustlike + p.post")+
  theme(
    plot.title = element_text(size = 16, face = "bold"),  # Increase title size
    text = element_text(size = 16)  # Increase text size globally
  )

#no overlapping genes found in these gene sets

clusterdata_dxr_fin <- data.frame(
  Category = c("Motif 1", "Motif 2", "Motif 3"), 
  Value = c(length(final_genes_1), length(final_genes_2), length(final_genes_3))
)

piecolors_dxr_fin <- c("Motif 1" = "#007896", 
                       "Motif 2" = "#58508D",
                       "Motif 3" = "#BC5090")

#make a piechart of these distributions
clusterdata_dxr_fin %>% ggplot(aes(x = "", y = Value, fill = Category))+
  geom_bar(width = 1, stat = "identity")+
  coord_polar("y", start = 0)+
  geom_text(aes(label = Value),
            position = position_stack(vjust = 0.5),
            size = 4, color = "black")+
  labs(title = "Distribution of Gene Clusters Identified By Cormotif", x = NULL, y = NULL)+
  theme_void()+
  scale_fill_manual(values = piecolors_dxr_fin)

#now, continue by plotting the logFC of all of these gene sets per motif, as well as look at some random genes for log2cpm to see if the patterns are reflected in the example genes


```

```{r logFC of Clustlike vs P.post Cormotif}
####clustlike logFC of initial set####
##motif 1
length(mf1_genes_p)
##motif 2 
length(mf2_genes_p)
##motif 3
length(mf3_genes_p)

#Combine the toptables I have from pairwise analysis into a single dataframe
d24_toptable_dxr <- Toptable_V.D24T %>% 
  rownames_to_column(var = "entrezgene_ID") %>% 
  mutate(Time = "24")

d24r_toptable_dxr <- Toptable_V.D24R %>% 
  rownames_to_column(var = "entrezgene_ID") %>% 
  mutate(Time = "24R")

d144r_toptable_dxr <- Toptable_V.D144R %>% 
  rownames_to_column(var = "entrezgene_ID") %>% 
  mutate(Time = "144R")

combined_toptables_dxr <- bind_rows(
  d24_toptable_dxr,
  d24r_toptable_dxr,
  d144r_toptable_dxr)

#Filter the data based on each motif
filt_toptable_dxr_fin <- combined_toptables_dxr %>% 
  dplyr::filter(entrezgene_ID  %in% mf1_genes_p) %>% 
  mutate(absFC = abs(logFC)) %>% 
  mutate(time = factor(Time, levels = c("24", "24R", "144R"), labels = c("24hr", "24hr Recovery", "144hr Recovery"))) %>% 
  ggplot(., aes(x = time, y = logFC))+
  geom_boxplot(aes(fill = time))+
  scale_fill_manual(values = time_col)+
  guides(fill = guide_legend(title = "Time"))+
  theme_bw()+
  xlab(" ")+
  ylab("logFC")+
  theme_bw()+
  ggtitle("LogFC for all genes in Motif 1 (n=6827)")+
  theme(plot.title = element_text(size = rel(1.5), hjust = 0.5),
        axis.title = element_text(size = 15, colour = "black"),
        strip.background = element_rect(fill = "#CAD899"),
        axis.text.x = element_text(size = 8, colour = "white", angle = 15),
        strip.text.x = element_text(size = 12, colour = "black", face = "bold"))

#motif 2
filt_toptable_2_dxr_fin <- combined_toptables_dxr %>% 
  dplyr::filter(entrezgene_ID  %in% final_genes_2) %>% 
  mutate(absFC = abs(logFC)) %>% 
  mutate(time = factor(Time, levels = c("24", "24R", "144R"), labels = c("24hr", "24hr Recovery", "144hr Recovery"))) %>% 
  ggplot(., aes(x = time, y = logFC))+
  geom_boxplot(aes(fill = time))+
  scale_fill_manual(values = time_col)+
  guides(fill = guide_legend(title = "Time"))+
  theme_bw()+
  xlab(" ")+
  ylab("logFC")+
  theme_bw()+
  ggtitle("LogFC for all genes in Motif 2 (n=6218)")+
  theme(plot.title = element_text(size = rel(1.5), hjust = 0.5),
        axis.title = element_text(size = 15, colour = "black"),
        strip.background = element_rect(fill = "#CAD899"),
        axis.text.x = element_text(size = 8, colour = "white", angle = 15),
        strip.text.x = element_text(size = 12, colour = "black", face = "bold"))

#motif 3
filt_toptable_3_dxr_fin <- combined_toptables_dxr %>% 
  dplyr::filter(entrezgene_ID  %in% final_genes_3) %>% 
  mutate(absFC = abs(logFC)) %>% 
  mutate(time = factor(Time, levels = c("24", "24R", "144R"), labels = c("24hr", "24hr Recovery", "144hr Recovery"))) %>% 
  ggplot(., aes(x = time, y = logFC))+
  geom_boxplot(aes(fill = time))+
  scale_fill_manual(values = time_col)+
  guides(fill = guide_legend(title = "Time"))+
  theme_bw()+
  xlab(" ")+
  ylab("logFC")+
  theme_bw()+
  ggtitle("LogFC for all genes in Motif 3 (n=231)")+
  theme(plot.title = element_text(size = rel(1.5), hjust = 0.5),
        axis.title = element_text(size = 15, colour = "black"),
        strip.background = element_rect(fill = "#CAD899"),
        axis.text.x = element_text(size = 8, colour = "white", angle = 15),
        strip.text.x = element_text(size = 12, colour = "black", face = "bold"))

#plots
filt_toptable_dxr_fin
filt_toptable_2_dxr_fin 
filt_toptable_3_dxr_fin


#now plot the abs logFC for each of these too
filt_toptable_abs_fin <- combined_toptables_dxr %>% 
  dplyr::filter(entrezgene_ID  %in% final_genes_1) %>% 
  mutate(absFC = abs(logFC)) %>% 
  mutate(time = factor(Time, levels = c("24", "24R", "144R"), labels = c("24hr", "24hr Recovery", "144hr Recovery"))) %>% 
  ggplot(., aes(x = time, y = absFC))+
  geom_boxplot(aes(fill = time))+
  scale_fill_manual(values = time_col)+
  guides(fill = guide_legend(title = "Time"))+
  theme_bw()+
  xlab(" ")+
  ylab("|logFC|")+
  theme_bw()+
  ggtitle("Abs LogFC for all genes in Motif 1 (n=5638)")+
  theme(plot.title = element_text(size = rel(1.5), hjust = 0.5),
        axis.title = element_text(size = 15, colour = "black"),
        strip.background = element_rect(fill = "#CAD899"),
        axis.text.x = element_text(size = 8, colour = "white", angle = 15),
        strip.text.x = element_text(size = 12, colour = "black", face = "bold"))

#motif 2
filt_toptable_2_abs_fin <- combined_toptables_dxr %>% 
  dplyr::filter(entrezgene_ID  %in% final_genes_2) %>% 
  mutate(absFC = abs(logFC)) %>% 
  mutate(time = factor(Time, levels = c("24", "24R", "144R"), labels = c("24hr", "24hr Recovery", "144hr Recovery"))) %>% 
  ggplot(., aes(x = time, y = absFC))+
  geom_boxplot(aes(fill = time))+
  scale_fill_manual(values = time_col)+
  guides(fill = guide_legend(title = "Time"))+
  theme_bw()+
  xlab(" ")+
  ylab("|logFC|")+
  theme_bw()+
  ggtitle("Abs LogFC for all genes in Motif 2 (n=6218)")+
  theme(plot.title = element_text(size = rel(1.5), hjust = 0.5),
        axis.title = element_text(size = 15, colour = "black"),
        strip.background = element_rect(fill = "#CAD899"),
        axis.text.x = element_text(size = 8, colour = "white", angle = 15),
        strip.text.x = element_text(size = 12, colour = "black", face = "bold"))

#motif 2
filt_toptable_3_abs_fin <- combined_toptables_dxr %>% 
  dplyr::filter(entrezgene_ID  %in% final_genes_3) %>% 
  mutate(absFC = abs(logFC)) %>% 
  mutate(time = factor(Time, levels = c("24", "24R", "144R"), labels = c("24hr", "24hr Recovery", "144hr Recovery"))) %>% 
  ggplot(., aes(x = time, y = absFC))+
  geom_boxplot(aes(fill = time))+
  scale_fill_manual(values = time_col)+
  guides(fill = guide_legend(title = "Time"))+
  theme_bw()+
  xlab(" ")+
  ylab("|logFC|")+
  theme_bw()+
  ggtitle("Abs LogFC for all genes in Motif 3 (n=231)")+
  theme(plot.title = element_text(size = rel(1.5), hjust = 0.5),
        axis.title = element_text(size = 15, colour = "black"),
        strip.background = element_rect(fill = "#CAD899"),
        axis.text.x = element_text(size = 8, colour = "white", angle = 15),
        strip.text.x = element_text(size = 12, colour = "black", face = "bold"))

#plots
filt_toptable_abs_fin
filt_toptable_2_abs_fin
filt_toptable_3_abs_fin



```


```{r logFC of Cormotif Motifs}
##motif 1
motif1_genes_fin <- final_genes_1
length(motif1_genes_fin)

##motif 2 
motif2_genes_fin <- final_genes_2
length(motif2_genes_fin)

##motif 3
motif3_genes_fin <- final_genes_3
length(motif3_genes_fin)

#Combine the toptables I have from pairwise analysis into a single dataframe
d24_toptable_dxr <- Toptable_V.D24T %>% 
  rownames_to_column(var = "entrezgene_ID") %>% 
  mutate(Time = "24")

d24r_toptable_dxr <- Toptable_V.D24R %>% 
  rownames_to_column(var = "entrezgene_ID") %>% 
  mutate(Time = "24R")

d144r_toptable_dxr <- Toptable_V.D144R %>% 
  rownames_to_column(var = "entrezgene_ID") %>% 
  mutate(Time = "144R")

combined_toptables_dxr <- bind_rows(
  d24_toptable_dxr,
  d24r_toptable_dxr,
  d144r_toptable_dxr)

#Filter the data based on each motif
filt_toptable_dxr_fin <- combined_toptables_dxr %>% 
  dplyr::filter(entrezgene_ID  %in% final_genes_1) %>% 
  mutate(absFC = abs(logFC)) %>% 
  mutate(time = factor(Time, levels = c("24", "24R", "144R"), labels = c("24hr", "24hr Recovery", "144hr Recovery"))) %>% 
  ggplot(., aes(x = time, y = logFC))+
  geom_boxplot(aes(fill = time))+
  scale_fill_manual(values = time_col)+
  guides(fill = guide_legend(title = "Time"))+
  theme_bw()+
  xlab(" ")+
  ylab("logFC")+
  theme_bw()+
  ggtitle("LogFC for all genes in Motif 1 (n=5638)")+
  theme(plot.title = element_text(size = rel(1.5), hjust = 0.5),
        axis.title = element_text(size = 15, colour = "black"),
        strip.background = element_rect(fill = "#CAD899"),
        axis.text.x = element_text(size = 8, colour = "white", angle = 15),
        strip.text.x = element_text(size = 12, colour = "black", face = "bold"))

#motif 2
filt_toptable_2_dxr_fin <- combined_toptables_dxr %>% 
  dplyr::filter(entrezgene_ID  %in% final_genes_2) %>% 
  mutate(absFC = abs(logFC)) %>% 
  mutate(time = factor(Time, levels = c("24", "24R", "144R"), labels = c("24hr", "24hr Recovery", "144hr Recovery"))) %>% 
  ggplot(., aes(x = time, y = logFC))+
  geom_boxplot(aes(fill = time))+
  scale_fill_manual(values = time_col)+
  guides(fill = guide_legend(title = "Time"))+
  theme_bw()+
  xlab(" ")+
  ylab("logFC")+
  theme_bw()+
  ggtitle("LogFC for all genes in Motif 2 (n=6218)")+
  theme(plot.title = element_text(size = rel(1.5), hjust = 0.5),
        axis.title = element_text(size = 15, colour = "black"),
        strip.background = element_rect(fill = "#CAD899"),
        axis.text.x = element_text(size = 8, colour = "white", angle = 15),
        strip.text.x = element_text(size = 12, colour = "black", face = "bold"))

#motif 3
filt_toptable_3_dxr_fin <- combined_toptables_dxr %>% 
  dplyr::filter(entrezgene_ID  %in% final_genes_3) %>% 
  mutate(absFC = abs(logFC)) %>% 
  mutate(time = factor(Time, levels = c("24", "24R", "144R"), labels = c("24hr", "24hr Recovery", "144hr Recovery"))) %>% 
  ggplot(., aes(x = time, y = logFC))+
  geom_boxplot(aes(fill = time))+
  scale_fill_manual(values = time_col)+
  guides(fill = guide_legend(title = "Time"))+
  theme_bw()+
  xlab(" ")+
  ylab("logFC")+
  theme_bw()+
  ggtitle("LogFC for all genes in Motif 3 (n=231)")+
  theme(plot.title = element_text(size = rel(1.5), hjust = 0.5),
        axis.title = element_text(size = 15, colour = "black"),
        strip.background = element_rect(fill = "#CAD899"),
        axis.text.x = element_text(size = 8, colour = "white", angle = 15),
        strip.text.x = element_text(size = 12, colour = "black", face = "bold"))

#plots
filt_toptable_dxr_fin
filt_toptable_2_dxr_fin 
filt_toptable_3_dxr_fin


#now plot the abs logFC for each of these too
filt_toptable_abs_fin <- combined_toptables_dxr %>% 
  dplyr::filter(entrezgene_ID  %in% final_genes_1) %>% 
  mutate(absFC = abs(logFC)) %>% 
  mutate(time = factor(Time, levels = c("24", "24R", "144R"), labels = c("24hr", "24hr Recovery", "144hr Recovery"))) %>% 
  ggplot(., aes(x = time, y = absFC))+
  geom_boxplot(aes(fill = time))+
  scale_fill_manual(values = time_col)+
  guides(fill = guide_legend(title = "Time"))+
  theme_bw()+
  xlab(" ")+
  ylab("|logFC|")+
  theme_bw()+
  ggtitle("Abs LogFC for all genes in Motif 1 (n=5638)")+
  theme(plot.title = element_text(size = rel(1.5), hjust = 0.5),
        axis.title = element_text(size = 15, colour = "black"),
        strip.background = element_rect(fill = "#CAD899"),
        axis.text.x = element_text(size = 8, colour = "white", angle = 15),
        strip.text.x = element_text(size = 12, colour = "black", face = "bold"))

#motif 2
filt_toptable_2_abs_fin <- combined_toptables_dxr %>% 
  dplyr::filter(entrezgene_ID  %in% final_genes_2) %>% 
  mutate(absFC = abs(logFC)) %>% 
  mutate(time = factor(Time, levels = c("24", "24R", "144R"), labels = c("24hr", "24hr Recovery", "144hr Recovery"))) %>% 
  ggplot(., aes(x = time, y = absFC))+
  geom_boxplot(aes(fill = time))+
  scale_fill_manual(values = time_col)+
  guides(fill = guide_legend(title = "Time"))+
  theme_bw()+
  xlab(" ")+
  ylab("|logFC|")+
  theme_bw()+
  ggtitle("Abs LogFC for all genes in Motif 2 (n=6218)")+
  theme(plot.title = element_text(size = rel(1.5), hjust = 0.5),
        axis.title = element_text(size = 15, colour = "black"),
        strip.background = element_rect(fill = "#CAD899"),
        axis.text.x = element_text(size = 8, colour = "white", angle = 15),
        strip.text.x = element_text(size = 12, colour = "black", face = "bold"))

#motif 2
filt_toptable_3_abs_fin <- combined_toptables_dxr %>% 
  dplyr::filter(entrezgene_ID  %in% final_genes_3) %>% 
  mutate(absFC = abs(logFC)) %>% 
  mutate(time = factor(Time, levels = c("24", "24R", "144R"), labels = c("24hr", "24hr Recovery", "144hr Recovery"))) %>% 
  ggplot(., aes(x = time, y = absFC))+
  geom_boxplot(aes(fill = time))+
  scale_fill_manual(values = time_col)+
  guides(fill = guide_legend(title = "Time"))+
  theme_bw()+
  xlab(" ")+
  ylab("|logFC|")+
  theme_bw()+
  ggtitle("Abs LogFC for all genes in Motif 3 (n=231)")+
  theme(plot.title = element_text(size = rel(1.5), hjust = 0.5),
        axis.title = element_text(size = 15, colour = "black"),
        strip.background = element_rect(fill = "#CAD899"),
        axis.text.x = element_text(size = 8, colour = "white", angle = 15),
        strip.text.x = element_text(size = 12, colour = "black", face = "bold"))

#plots
filt_toptable_abs_fin
filt_toptable_2_abs_fin
filt_toptable_3_abs_fin

```

```{r log2cpm Cormotif Genes}
#use the final genes from cross-verifying with clustlike + p.post

#Load in my count matrices
# final_genes_1
# final_genes_2
# final_genes_3

#these are all the genes that are present in each category, make them into dataframes by filtering out the rest of the genes in my main boxplot df
boxplots_cormotif <- boxplot1

motif1_genes_fin <- boxplots_cormotif[boxplots_cormotif$Entrez_ID %in% final_genes_1,]
dim(motif1_genes_fin)
#5638 genes in 44 cols
motif2_genes_fin <- boxplots_cormotif[boxplots_cormotif$Entrez_ID %in% final_genes_2,]
dim(motif2_genes_fin)
#6218 genes in 44 cols
motif3_genes_fin <- boxplots_cormotif[boxplots_cormotif$Entrez_ID %in% final_genes_3,]
dim(motif3_genes_fin)
#231 genes in 44 cols

#pull out some random genes for each using sample

m1_genes_fin <- motif1_genes_fin[sample(nrow(motif1_genes_fin), 3), , drop = FALSE]

#Define gene list(s)
#these are the genes pulled out by m1_genes
initial_test_genes1_fin <- c(m1_genes_fin$SYMBOL)  
#Add more gene symbols as needed or add more categories

#Now put in the function I want to use to generate boxplots of genes
process_gene_data_1_fin <- function(gene) {
  gene_data <- motif1_genes_fin %>% filter(SYMBOL == gene)
  long_data <- gene_data %>%
    pivot_longer(cols = -c(Entrez_ID, SYMBOL), names_to = "Sample", values_to = "log2CPM") %>%
    mutate(
      Drug = case_when(
        grepl("DOX", Sample) ~ "DOX",
        grepl("DMSO", Sample) ~ "DMSO",
        TRUE ~ NA_character_
      ),
      Timepoint = case_when(
        grepl("_24T_", Sample) ~ "24T",
        grepl("_24R_", Sample) ~ "24R",
        grepl("_144R_", Sample) ~ "144R",
        TRUE ~ NA_character_
      ),
      Indv = case_when(
        grepl("Ind1$", Sample) ~ "1",
        grepl("Ind2$", Sample) ~ "2",
        grepl("Ind3$", Sample) ~ "3",
        grepl("Ind4$", Sample) ~ "4",
        grepl("Ind5$", Sample) ~ "5",
        grepl("Ind6$", Sample) ~ "6",
        grepl("Ind6REP$", Sample) ~ "6R",
        TRUE ~ NA_character_
      ),
      Condition = paste(Drug, Timepoint, sep = "_")
    )
  long_data$Condition <- factor(
    long_data$Condition,
    levels = c(
      "DOX_24T", 
      "DMSO_24T", 
      "DOX_24R", 
      "DMSO_24R", 
      "DOX_144R", 
      "DMSO_144R"
    )
  )
  return(long_data)
}

#Generate Boxplots from the above function using our gene list above
for (gene in initial_test_genes1_fin) {
  gene_data <- process_gene_data_1_fin(gene)
  p <- ggplot(gene_data, aes(x = Condition, y = log2CPM, fill = Drug)) +
    geom_boxplot(outlier.shape = NA) +
    geom_point(aes(color = Indv), size = 2, alpha = 0.5, position = position_jitter(width = -1, height = 0)) +
    scale_fill_manual(values = c("DOX" = "#499FBD", "DMSO" = "#BBBBBC")) +
    ggtitle(paste("Log2CPM Expression of", gene, "Motif 1")) +
    labs(x = "Treatment", y = "log2CPM") +
    theme_bw() +
    theme(
      plot.title = element_text(size = rel(2), hjust = 0.5),
      axis.title = element_text(size = 15, color = "black"),
      axis.text.x = element_text(size = 10, color = "black", angle = 90, hjust = 1)
    )
  print(p)
}

#####motif 2#####

m2_genes_fin <- motif2_genes_fin[sample(nrow(motif2_genes_fin), 3), , drop = FALSE]

#Define gene list(s)
#these are the genes pulled out by m1_genes
initial_test_genes2_fin <- c(m2_genes_fin$SYMBOL)  
#Add more gene symbols as needed or add more categories

#Now put in the function I want to use to generate boxplots of genes
process_gene_datam2_fin <- function(gene) {
  gene_data <- motif2_genes_fin %>% filter(SYMBOL == gene)
  long_data <- gene_data %>%
    pivot_longer(cols = -c(Entrez_ID, SYMBOL), names_to = "Sample", values_to = "log2CPM") %>%
    mutate(
      Drug = case_when(
        grepl("DOX", Sample) ~ "DOX",
        grepl("DMSO", Sample) ~ "DMSO",
        TRUE ~ NA_character_
      ),
      Timepoint = case_when(
        grepl("_24T_", Sample) ~ "24T",
        grepl("_24R_", Sample) ~ "24R",
        grepl("_144R_", Sample) ~ "144R",
        TRUE ~ NA_character_
      ),
      Indv = case_when(
        grepl("Ind1$", Sample) ~ "1",
        grepl("Ind2$", Sample) ~ "2",
        grepl("Ind3$", Sample) ~ "3",
        grepl("Ind4$", Sample) ~ "4",
        grepl("Ind5$", Sample) ~ "5",
        grepl("Ind6$", Sample) ~ "6",
        grepl("Ind6REP$", Sample) ~ "6R",
        TRUE ~ NA_character_
      ),
      Condition = paste(Drug, Timepoint, sep = "_")
    )
  long_data$Condition <- factor(
    long_data$Condition,
    levels = c(
      "DOX_24T", 
      "DMSO_24T", 
      "DOX_24R", 
      "DMSO_24R", 
      "DOX_144R", 
      "DMSO_144R"
    )
  )
  return(long_data)
}

#this function is saved under process_gene_data so I will save as an R object

#saveRDS(process_gene_data, "data/new/process_gene_data_funct.RDS")

#Generate Boxplots from the above function using our gene list above
for (gene in initial_test_genes2_fin) {
  gene_data <- process_gene_datam2_fin(gene)
  p <- ggplot(gene_data, aes(x = Condition, y = log2CPM, fill = Drug)) +
    geom_boxplot(outlier.shape = NA) +
    geom_point(aes(color = Indv), size = 2, alpha = 0.5, position = position_jitter(width = -1, height = 0)) +
    scale_fill_manual(values = c("DOX" = "#499FBD", "DMSO" = "#BBBBBC")) +
    ggtitle(paste("Log2CPM Expression of", gene, "Motif 2")) +
    labs(x = "Treatment", y = "log2CPM") +
    theme_bw() +
    theme(
      plot.title = element_text(size = rel(2), hjust = 0.5),
      axis.title = element_text(size = 15, color = "black"),
      axis.text.x = element_text(size = 10, color = "black", angle = 90, hjust = 1)
    )
  print(p)
}

#####motif 3#####

m3_genes_fin <- motif3_genes_fin[sample(nrow(motif3_genes_fin), 3), , drop = FALSE]

#Define gene list(s)
#these are the genes pulled out by m3_genes
initial_test_genes3_fin <- c(m3_genes_fin$SYMBOL)  
#Add more gene symbols as needed or add more categories

#Now put in the function I want to use to generate boxplots of genes
process_gene_datam3_fin <- function(gene) {
  gene_data <- motif3_genes_fin %>% filter(SYMBOL == gene)
  long_data <- gene_data %>%
    pivot_longer(cols = -c(Entrez_ID, SYMBOL), names_to = "Sample", values_to = "log2CPM") %>%
    mutate(
      Drug = case_when(
        grepl("DOX", Sample) ~ "DOX",
        grepl("DMSO", Sample) ~ "DMSO",
        TRUE ~ NA_character_
      ),
      Timepoint = case_when(
        grepl("_24T_", Sample) ~ "24T",
        grepl("_24R_", Sample) ~ "24R",
        grepl("_144R_", Sample) ~ "144R",
        TRUE ~ NA_character_
      ),
      Indv = case_when(
        grepl("Ind1$", Sample) ~ "1",
        grepl("Ind2$", Sample) ~ "2",
        grepl("Ind3$", Sample) ~ "3",
        grepl("Ind4$", Sample) ~ "4",
        grepl("Ind5$", Sample) ~ "5",
        grepl("Ind6$", Sample) ~ "6",
        grepl("Ind6REP$", Sample) ~ "6R",
        TRUE ~ NA_character_
      ),
      Condition = paste(Drug, Timepoint, sep = "_")
    )
  long_data$Condition <- factor(
    long_data$Condition,
    levels = c(
      "DOX_24T", 
      "DMSO_24T", 
      "DOX_24R", 
      "DMSO_24R", 
      "DOX_144R", 
      "DMSO_144R"
    )
  )
  return(long_data)
}

#Generate Boxplots from the above function using our gene list above
for (gene in initial_test_genes3_fin) {
  gene_data <- process_gene_datam3_fin(gene)
  p <- ggplot(gene_data, aes(x = Condition, y = log2CPM, fill = Drug)) +
    geom_boxplot(outlier.shape = NA) +
    geom_point(aes(color = Indv), size = 2, alpha = 0.5, position = position_jitter(width = -1, height = 0)) +
    scale_fill_manual(values = c("DOX" = "#499FBD", "DMSO" = "#BBBBBC")) +
    ggtitle(paste("Log2CPM Expression of", gene, "Motif 3")) +
    labs(x = "Treatment", y = "log2CPM") +
    theme_bw() +
    theme(
      plot.title = element_text(size = rel(2), hjust = 0.5),
      axis.title = element_text(size = 15, color = "black"),
      axis.text.x = element_text(size = 10, color = "black", angle = 90, hjust = 1)
    )
  print(p)
}

```


```{r Cormotif GO KEGG Final Genes}
#now take these final gene sets for each motif - clustlike + p.post consensus genes

# final_genes_1
# final_genes_2
# final_genes_3

library(gprofiler2)
#####Motif 1 Gene Set#####
# motif1_genes_matrix <- as.matrix(final_genes_1) 
# colnames(motif1_genes_matrix) <- c("entrezgene_ID")

# saveRDS(motif1_genes_matrix, "data/new/motif1_genes_matrix.RDS")

motif1_genes_matrix <- readRDS("data/new/motif1_genes_matrix.RDS")
length(motif1_genes_matrix)
#5638 genes in this set for motif 1

motif1_mat_GOKEGG <- gost(query = motif1_genes_matrix,
                          organism = "hsapiens",
                          ordered_query = FALSE,
                          measure_underrepresentation = FALSE,
                          evcodes = FALSE,
                          user_threshold = 0.05,
                          correction_method = c("fdr"),
                          sources = c("GO:BP", "KEGG"))

motif1_GOKEGG_genes <- gostplot(motif1_mat_GOKEGG, capped = FALSE, interactive = TRUE)
motif1_GOKEGG_genes

table_motif1_GOKEGG_genes <- motif1_mat_GOKEGG$result %>% 
  dplyr::select(c(source, term_id, term_name, intersection_size, term_size, p_value))

table_motif1_GOKEGG_genes %>% 
  mutate_at(.vars = 6, .funs = scales::label_scientific(digits=4)) %>% 
  kableExtra::kable(.,) %>% 
  kableExtra::kable_paper("striped", full_width = FALSE) %>% 
  kableExtra::kable_styling(full_width = FALSE, position = "left", bootstrap_options = c("striped", "hover")) %>% 
  kableExtra::scroll_box(width = "100%", height = "400px")

# write.csv(table_motif1_GOKEGG_genes, "data/new/table_motif1_GOKEGG_genes.csv")

#GO:BP
table_motif1_genes_GOBP <- table_motif1_GOKEGG_genes %>% 
  dplyr::filter(source=="GO:BP") %>% 
  dplyr::select(p_value, term_name, intersection_size) %>% 
  dplyr::slice_min(., n=10, order_by=p_value) %>% 
  mutate(log_val = -log10(p_value))

# saveRDS(table_motif1_genes_GOBP, "data/table_motif1_genes_GOBP.RDS")

table_motif1_genes_GOBP %>% ggplot(., aes(x = log_val, y = reorder(term_name, p_value), col= intersection_size)) +
  geom_point(aes(size = intersection_size)) +
  ggtitle("Cormotif Motif 1 Enriched GO:BP Terms")+
  xlab(expression("-log"[10]~"p-value"))+
  guides(col="none", size= guide_legend(title = "# of intersected \n terms"))+
  ylab("GO:BP term")+
  scale_y_discrete(labels = scales::label_wrap(30))+
  theme_bw()+
  theme(plot.title = element_text(size = rel(1.5), hjust = 0.5),
        axis.title = element_text(size = 15, colour = "black"),
        axis.ticks = element_line(linewidth = 1.5),
        axis.line = element_line(linewidth = 1.5),
        axis.text = element_text(size = 10, colour = "black", angle = 0),
        strip.text = element_text(size = 15, colour = "black", face = "bold"))

#KEGG
table_motif1_genes_KEGG <- table_motif1_GOKEGG_genes %>% 
  dplyr::filter(source=="KEGG") %>% 
  dplyr::select(p_value, term_name, intersection_size) %>% 
  dplyr::slice_min(., n=10, order_by=p_value) %>% 
  mutate(log_val = -log10(p_value))

table_motif1_genes_KEGG %>% ggplot(., aes(x = log_val, y = reorder(term_name, p_value), col= intersection_size)) +
  geom_point(aes(size = intersection_size)) +
  ggtitle("Cormotif Motif 1 DEGs Enriched KEGG Terms")+
  xlab(expression("-log"[10]~"p-value"))+
  guides(col="none", size= guide_legend(title = "# of intersected \n terms"))+
  ylab("KEGG term")+
  scale_y_discrete(labels = scales::label_wrap(30))+
  theme_bw()+
  theme(plot.title = element_text(size = rel(1.5), hjust = 0.5),
        axis.title = element_text(size = 15, colour = "black"),
        axis.ticks = element_line(linewidth = 1.5),
        axis.line = element_line(linewidth = 1.5),
        axis.text = element_text(size = 10, colour = "black", angle = 0),
        strip.text = element_text(size = 15, colour = "black", face = "bold"))

#####Motif 2 Genes#####
# motif2_genes_matrix <- as.matrix(final_genes_2) 
# colnames(motif2_genes_matrix) <- c("entrezgene_ID")

# saveRDS(motif2_genes_matrix, "data/new/motif2_genes_matrix.RDS")
motif2_genes_matrix <- readRDS("data/new/motif2_genes_matrix.RDS")
length(motif2_genes_matrix)
#6218 genes in this set for motif 2

motif2_mat_GOKEGG <- gost(query = motif2_genes_matrix,
                          organism = "hsapiens",
                          ordered_query = FALSE,
                          measure_underrepresentation = FALSE,
                          evcodes = FALSE,
                          user_threshold = 0.05,
                          correction_method = c("fdr"),
                          sources = c("GO:BP", "KEGG"))

motif2_GOKEGG_genes <- gostplot(motif2_mat_GOKEGG, capped = FALSE, interactive = TRUE)
motif2_GOKEGG_genes

table_motif2_GOKEGG_genes <- motif2_mat_GOKEGG$result %>% 
  dplyr::select(c(source, term_id, term_name, intersection_size, term_size, p_value))

table_motif2_GOKEGG_genes %>% 
  mutate_at(.vars = 6, .funs = scales::label_scientific(digits=4)) %>% 
  kableExtra::kable(.,) %>% 
  kableExtra::kable_paper("striped", full_width = FALSE) %>% 
  kableExtra::kable_styling(full_width = FALSE, position = "left", bootstrap_options = c("striped", "hover")) %>% 
  kableExtra::scroll_box(width = "100%", height = "400px")

# write.csv(table_motif2_GOKEGG_genes, "data/new/table_motif2_GOKEGG_genes.csv")

#GO:BP
table_motif2_genes_GOBP <- table_motif2_GOKEGG_genes %>% 
  dplyr::filter(source=="GO:BP") %>% 
  dplyr::select(p_value, term_name, intersection_size) %>% 
  dplyr::slice_min(., n=10, order_by=p_value) %>% 
  mutate(log_val = -log10(p_value))

# saveRDS(table_motif2_genes_GOBP, "data/table_motif2_genes_GOBP.RDS")

table_motif2_genes_GOBP %>% ggplot(., aes(x = log_val, y = reorder(term_name, p_value), col= intersection_size)) +
  geom_point(aes(size = intersection_size)) +
  ggtitle("Cormotif Motif 2 Enriched GO:BP Terms")+
  xlab(expression("-log"[10]~"p-value"))+
  guides(col="none", size= guide_legend(title = "# of intersected \n terms"))+
  ylab("GO:BP term")+
  scale_y_discrete(labels = scales::label_wrap(30))+
  theme_bw()+
  theme(plot.title = element_text(size = rel(1.5), hjust = 0.5),
        axis.title = element_text(size = 15, colour = "black"),
        axis.ticks = element_line(linewidth = 1.5),
        axis.line = element_line(linewidth = 1.5),
        axis.text = element_text(size = 10, colour = "black", angle = 0),
        strip.text = element_text(size = 15, colour = "black", face = "bold"))

#KEGG
table_motif2_genes_KEGG <- table_motif2_GOKEGG_genes %>% 
  dplyr::filter(source=="KEGG") %>% 
  dplyr::select(p_value, term_name, intersection_size) %>% 
  dplyr::slice_min(., n=10, order_by=p_value) %>% 
  mutate(log_val = -log10(p_value))

table_motif2_genes_KEGG %>% ggplot(., aes(x = log_val, y = reorder(term_name, p_value), col= intersection_size)) +
  geom_point(aes(size = intersection_size)) +
  ggtitle("Cormotif Motif 2 DEGs Enriched KEGG Terms")+
  xlab(expression("-log"[10]~"p-value"))+
  guides(col="none", size= guide_legend(title = "# of intersected \n terms"))+
  ylab("KEGG term")+
  scale_y_discrete(labels = scales::label_wrap(30))+
  theme_bw()+
  theme(plot.title = element_text(size = rel(1.5), hjust = 0.5),
        axis.title = element_text(size = 15, colour = "black"),
        axis.ticks = element_line(linewidth = 1.5),
        axis.line = element_line(linewidth = 1.5),
        axis.text = element_text(size = 10, colour = "black", angle = 0),
        strip.text = element_text(size = 15, colour = "black", face = "bold"))


#####Motif 3 DEGs GO KEGG#####
# motif3_genes_matrix <- as.matrix(final_genes_3) 
# colnames(motif3_genes_matrix) <- c("entrezgene_ID")

# saveRDS(motif3_genes_matrix, "data/new/motif3_genes_matrix.RDS")

motif3_genes_matrix <- readRDS("data/new/motif3_genes_matrix.RDS")
length(motif3_genes_matrix)
#231 genes in this set for motif 3

motif3_mat_GOKEGG <- gost(query = motif3_genes_matrix,
                          organism = "hsapiens",
                          ordered_query = FALSE,
                          measure_underrepresentation = FALSE,
                          evcodes = FALSE,
                          user_threshold = 0.05,
                          correction_method = c("fdr"),
                          sources = c("GO:BP", "KEGG"))

motif3_GOKEGG_genes <- gostplot(motif3_mat_GOKEGG, capped = FALSE, interactive = TRUE)
motif3_GOKEGG_genes

table_motif3_GOKEGG_genes <- motif3_mat_GOKEGG$result %>% 
  dplyr::select(c(source, term_id, term_name, intersection_size, term_size, p_value))

table_motif3_GOKEGG_genes %>% 
  mutate_at(.vars = 6, .funs = scales::label_scientific(digits=4)) %>% 
  kableExtra::kable(.,) %>% 
  kableExtra::kable_paper("striped", full_width = FALSE) %>% 
  kableExtra::kable_styling(full_width = FALSE, position = "left", bootstrap_options = c("striped", "hover")) %>% 
  kableExtra::scroll_box(width = "100%", height = "400px")

# write.csv(table_motif3_GOKEGG_genes, "data/new/table_motif3_GOKEGG_genes.csv")

#GO:BP
table_motif3_genes_GOBP <- table_motif3_GOKEGG_genes %>% 
  dplyr::filter(source=="GO:BP") %>% 
  dplyr::select(p_value, term_name, intersection_size) %>% 
  dplyr::slice_min(., n=10, order_by=p_value) %>% 
  mutate(log_val = -log10(p_value))

# saveRDS(table_motif3_genes_GOBP, "data/table_motif3_genes_GOBP.RDS")

table_motif3_genes_GOBP %>% ggplot(., aes(x = log_val, y = reorder(term_name, p_value), col= intersection_size)) +
  geom_point(aes(size = intersection_size)) +
  ggtitle("Cormotif Motif 3 Enriched GO:BP Terms")+
  xlab(expression("-log"[10]~"p-value"))+
  guides(col="none", size= guide_legend(title = "# of intersected \n terms"))+
  ylab("GO:BP term")+
  scale_y_discrete(labels = scales::label_wrap(30))+
  theme_bw()+
  theme(plot.title = element_text(size = rel(1.5), hjust = 0.5),
        axis.title = element_text(size = 15, colour = "black"),
        axis.ticks = element_line(linewidth = 1.5),
        axis.line = element_line(linewidth = 1.5),
        axis.text = element_text(size = 10, colour = "black", angle = 0),
        strip.text = element_text(size = 15, colour = "black", face = "bold"))

#KEGG
table_motif3_genes_KEGG <- table_motif3_GOKEGG_genes %>% 
  dplyr::filter(source=="KEGG") %>% 
  dplyr::select(p_value, term_name, intersection_size) %>% 
  dplyr::slice_min(., n=10, order_by=p_value) %>% 
  mutate(log_val = -log10(p_value))

table_motif3_genes_KEGG %>% ggplot(., aes(x = log_val, y = reorder(term_name, p_value), col= intersection_size)) +
  geom_point(aes(size = intersection_size)) +
  ggtitle("Cormotif Motif 3 DEGs Enriched KEGG Terms")+
  xlab(expression("-log"[10]~"p-value"))+
  guides(col="none", size= guide_legend(title = "# of intersected \n terms"))+
  ylab("KEGG term")+
  scale_y_discrete(labels = scales::label_wrap(30))+
  theme_bw()+
  theme(plot.title = element_text(size = rel(1.5), hjust = 0.5),
        axis.title = element_text(size = 15, colour = "black"),
        axis.ticks = element_line(linewidth = 1.5),
        axis.line = element_line(linewidth = 1.5),
        axis.text = element_text(size = 10, colour = "black", angle = 0),
        strip.text = element_text(size = 15, colour = "black", face = "bold"))

```

```{r Cormotif Unassigned Gene Set, include = FALSE}
#now let's pull out the genes that were not assigned to a motif from above

#this one is giving me an issue with wflow_build so I'll fix it later

unassigned_genes_list <- readRDS("data/new/Cormotif/unassigned_genes_Cormotif.RDS")

#with these unassigned genes, I want to plot logFC and GO/KEGG of unassigned genes
#####logFC#####

##no motif genes
unassign_genes_fin <- unassigned_genes_list
length(unassign_genes_fin)
#2232 genes 

#Combine the toptables I have from pairwise analysis into a single dataframe
combined_toptables_dxr <- bind_rows(
  d24_toptable_dxr,
  d24r_toptable_dxr,
  d144r_toptable_dxr)

#Filter the data based on each motif
# filt_toptable_dxr_fin_unassign <- as.data.frame(combined_toptables_dxr) %>% 
#   dplyr::filter(Entrez_ID  %in% unassign_genes_fin) %>% 
#   mutate(absFC = abs(logFC)) %>% 
#   mutate(time = factor(Time, levels = c("24", "24R", "144R"), labels = c("24hr", "24hr Recovery", "144hr Recovery"))) %>% 
#   ggplot(., aes(x = time, y = logFC))+
#   geom_boxplot(aes(fill = time))+
#   scale_fill_manual(values = time_col)+
#   guides(fill = guide_legend(title = "Time"))+
#   theme_bw()+
#   xlab(" ")+
#   ylab("logFC")+
#   theme_bw()+
#   ggtitle("LogFC of Unassigned Genes (n=2232)")+
#   theme(plot.title = element_text(size = rel(1.5), hjust = 0.5),
#         axis.title = element_text(size = 15, colour = "black"),
#         strip.background = element_rect(fill = "#CAD899"),
#         axis.text.x = element_text(size = 8, colour = "white", angle = 15),
#         strip.text.x = element_text(size = 12, colour = "black", face = "bold"))
# 
# filt_toptable_dxr_fin_unassign


# filt_toptable_abs_fin_unassign <- as.data.frame(combined_toptables_dxr) %>% 
#   dplyr::filter(Entrez_ID  %in% unassign_genes_fin) %>% 
#   mutate(absFC = abs(logFC)) %>% 
#   mutate(time = factor(Time, levels = c("24", "24R", "144R"), labels = c("24hr", "24hr Recovery", "144hr Recovery"))) %>% 
#   ggplot(., aes(x = time, y = absFC))+
#   geom_boxplot(aes(fill = time))+
#   scale_fill_manual(values = time_col)+
#   guides(fill = guide_legend(title = "Time"))+
#   theme_bw()+
#   xlab(" ")+
#   ylab("|logFC|")+
#   theme_bw()+
#   ggtitle("Abs LogFC of Unassigned Genes (n=2232)")+
#   theme(plot.title = element_text(size = rel(1.5), hjust = 0.5),
#         axis.title = element_text(size = 15, colour = "black"),
#         strip.background = element_rect(fill = "#CAD899"),
#         axis.text.x = element_text(size = 8, colour = "white", angle = 15),
#         strip.text.x = element_text(size = 12, colour = "black", face = "bold"))
# 
# filt_toptable_abs_fin_unassign

####GO KEGG####
unassigned_genes_matrix <- as.matrix(unassigned_genes_list)
length(unassigned_genes_matrix)
#2232 genes in this set

unassign_mat_GOKEGG <- gost(query = unassigned_genes_matrix,
                          organism = "hsapiens",
                          ordered_query = FALSE,
                          measure_underrepresentation = FALSE,
                          evcodes = FALSE,
                          user_threshold = 0.05,
                          correction_method = c("fdr"),
                          sources = c("GO:BP", "KEGG"))

unassign_GOKEGG_genes <- gostplot(unassign_mat_GOKEGG, capped = FALSE, interactive = TRUE)
unassign_GOKEGG_genes

table_unassign_GOKEGG_genes <- unassign_mat_GOKEGG$result %>% 
  dplyr::select(c(source, term_id, term_name, intersection_size, term_size, p_value))

table_unassign_GOKEGG_genes %>% 
  mutate_at(.vars = 6, .funs = scales::label_scientific(digits=4)) %>% 
  kableExtra::kable(.,) %>% 
  kableExtra::kable_paper("striped", full_width = FALSE) %>% 
  kableExtra::kable_styling(full_width = FALSE, position = "left", bootstrap_options = c("striped", "hover")) %>% 
  kableExtra::scroll_box(width = "100%", height = "400px")

#GO:BP
table_unassign_genes_GOBP <- table_unassign_GOKEGG_genes %>% 
  dplyr::filter(source=="GO:BP") %>% 
  dplyr::select(p_value, term_name, intersection_size) %>% 
  dplyr::slice_min(., n=10, order_by=p_value) %>% 
  mutate(log_val = -log10(p_value))

table_unassign_genes_GOBP %>% ggplot(., aes(x = log_val, y = reorder(term_name, p_value), col= intersection_size)) +
  geom_point(aes(size = intersection_size)) +
  ggtitle("Cormotif Unassigned Enriched GO:BP Terms")+
  xlab(expression("-log"[10]~"p-value"))+
  guides(col="none", size= guide_legend(title = "# of intersected \n terms"))+
  ylab("GO:BP term")+
  scale_y_discrete(labels = scales::label_wrap(30))+
  theme_bw()+
  theme(plot.title = element_text(size = rel(1.5), hjust = 0.5),
        axis.title = element_text(size = 15, colour = "black"),
        axis.ticks = element_line(linewidth = 1.5),
        axis.line = element_line(linewidth = 1.5),
        axis.text = element_text(size = 10, colour = "black", angle = 0),
        strip.text = element_text(size = 15, colour = "black", face = "bold"))

#KEGG
table_unassign_genes_KEGG <- table_unassign_GOKEGG_genes %>% 
  dplyr::filter(source=="KEGG") %>% 
  dplyr::select(p_value, term_name, intersection_size) %>% 
  dplyr::slice_min(., n=10, order_by=p_value) %>% 
  mutate(log_val = -log10(p_value))

table_unassign_genes_KEGG %>% ggplot(., aes(x = log_val, y = reorder(term_name, p_value), col= intersection_size)) +
  geom_point(aes(size = intersection_size)) +
  ggtitle("Cormotif Unassigned DEGs Enriched KEGG Terms")+
  xlab(expression("-log"[10]~"p-value"))+
  guides(col="none", size= guide_legend(title = "# of intersected \n terms"))+
  ylab("KEGG term")+
  scale_y_discrete(labels = scales::label_wrap(30))+
  theme_bw()+
  theme(plot.title = element_text(size = rel(1.5), hjust = 0.5),
        axis.title = element_text(size = 15, colour = "black"),
        axis.ticks = element_line(linewidth = 1.5),
        axis.line = element_line(linewidth = 1.5),
        axis.text = element_text(size = 10, colour = "black", angle = 0),
        strip.text = element_text(size = 15, colour = "black", face = "bold"))



```

```{r  RUVs Cormotif with Norm Counts}
# #read in the norm counts df (normalized counts from RUV)
set1 <- readRDS("data/new/RUV/set1_RUVsk1_normcounts.RDS")
NormCounts_RUV_rep <- as.data.frame(set1$normalizedCounts)
# 
# #read in my metadata sheet that I'll use as the standard for labelling
# #this one already has the replicate individual removed
Metadata_2 <- readRDS("data/new/Metadata_2_norep.RDS")
# 
# #I'll have to remove the replicate at this stage so I can properly run Cormotif
NormCounts_RUV <- NormCounts_RUV_rep %>%
  dplyr::select(-(contains("6R")))
# 
# #now ensure the column names match the original dge$counts with Sample_name
colnames(NormCounts_RUV) <- Metadata_2$Sample_name
# 
# #now, make this into a dge object as I did for DE + Cormotif
dge_RUV <- DGEList(counts = NormCounts_RUV)
# 
# #put the Condition names as a factor onto the dge object for further sorting
dge_RUV$samples$group <- factor(Metadata_2[colnames(NormCounts_RUV), "Condition"])
# 
# #TMM normalize the normalized counts input with the dge object
dge_RUV_calc <- calcNormFactors(dge_RUV, method = "TMM")
# #this is producing a lot of NaNs warnings, perhaps because TMM should occur before norm counts?
# 
# #try by performing TMM normalization before norm counts in set1
# 
counts <- readRDS("data/new/RUV/filt_counts_matrix.RDS")
# #use this counts file to feed into set1 - but instead TMM normalize it first
# 
counts_tmm <- calcNormFactors(counts, method = "TMM")
# 
# set1_tmm <- RUVSeq::RUVs(x = counts_tmm, k =1, scIdx = scIdx, isLog = FALSE)
# error with tmm normalized counts going into RUVseq
# 
# summary(colSums(NormCounts_RUV))
# dge_RUV$samples
# # 
ncol(NormCounts_RUV) == nrow(Metadata_2)           # Should be TRUE
all(colnames(NormCounts_RUV) == rownames(Metadata_2))
# 
# 
# #save this file so I can read it in later!
# #saveRDS(dge_RUV_calc, "data/new/Cormotif/dge_matrix_forCormotif.RDS")
# 
# #check normalization factors from TMM normalization of LIBRARIES
# dge_RUV_calc$samples
# #it was normalized properly but generated NaNs warnings?
# #still has the same number of columns, properly labelled and in order according to metadata
#  #should be okay - let's try running it and see if it works properly
# 
# Metadata_2_ordered <- Metadata_2[match(colnames(NormCounts_RUV), Metadata_2$Sample_name), ]
# 
# #now cpm these TMM normalized norm counts
# cmf_RUV_cpm <- cpm(dge_RUV_calc, log = TRUE)
# 
# #change the column names to match the Metadata sheet I have
# colnames(cmf_RUV_cpm) <- (Metadata_2$Final_sample_name)
# 
# cmf_RUV_counts <- dge_RUV_calc
# 
# #now make your TMM normalized cpm of norm counts into a dataframe + add Entrez_ID as a col
# cmf_RUV_df <- cmf_RUV_cpm %>%
  # as.data.frame() %>%
  # rownames_to_column(., var = "Entrez_ID")
# 
# #save this to a csv file so I can reorder this matrix easily
# #write.csv(cmf_RUV_cpm, "data/new/Cormotif/RUV/Cormotif_RUVk1_cpm_matrix.csv")
# 
# #reorder my test matrix to match the new groupid I've made
# #I want my columns to be in this order:
# #DOX24T 1-6, DOX24R 1-6, DOX144R 1-6, DMSO24T 1-6, DMSO24R 1-6, DMSO144R 1-6
# Cormotif_RUV <- read.csv("data/new/cmf_RUV_final.csv")
# dim(Cormotif_RUV)
# # #14319 genes across 37 cols (1 is Entrez_ID)
# Cormotif_RUV_df <- data.frame(Cormotif_RUV)
# # 
# rownames(Cormotif_RUV_df) <- Cormotif_RUV_df$Entrez_ID
# exprs.cmf_RUV <- as.matrix(Cormotif_RUV_df[,2:37])
# dim(exprs.cmf_RUV)
# # 
# 
# #put together my group id and comparison id to make the correct comparisons between experimental conditions
# 
# #groupid tells which experimental conditions are grouped together
# #compid tells which experimental conditions should be compared against one another
# ##ie DOX24T vs DMSO24T matched control
# 
# groupid <- c(
#   DOX_24T_1 = 1,
#   DOX_24T_2 = 1,
#   DOX_24T_3 = 1,
#   DOX_24T_4 = 1,
#   DOX_24T_5 = 1,
#   DOX_24T_6 = 1,
#   DOX_24R_1 = 2,
#   DOX_24R_2 = 2,
#   DOX_24R_3 = 2,
#   DOX_24R_4 = 2,
#   DOX_24R_5 = 2,
#   DOX_24R_6 = 2,
#   DOX_144R_1 = 3,
#   DOX_144R_2 = 3,
#   DOX_144R_3 = 3,
#   DOX_144R_4 = 3,
#   DOX_144R_5 = 3,
#   DOX_144R_6 = 3,
#   DMSO_24T_1 = 4,
#   DMSO_24T_2 = 4,
#   DMSO_24T_3 = 4,
#   DMSO_24T_4 = 4,
#   DMSO_24T_5 = 4,
#   DMSO_24T_6 = 4,
#   DMSO_24R_1 = 5,
#   DMSO_24R_2 = 5,
#   DMSO_24R_3 = 5,
#   DMSO_24R_4 = 5,
#   DMSO_24R_5 = 5,
#   DMSO_24R_6 = 5,
#   DMSO_144R_1 = 6,
#   DMSO_144R_2 = 6,
#   DMSO_144R_3 = 6,
#   DMSO_144R_4 = 6,
#   DMSO_144R_5 = 6,
#   DMSO_144R_6 = 6
# )
# #saveRDS(groupid, "data/new/groupidCormotif.RDS")
# 
# compid <- data.frame(Cond1 = c(1, 2, 3), Cond2 = c(4, 5, 6))
# #saveRDS(compid, "data/new/compidCormotif.RDS")
```

```{r RUVs Cormotif Test}

#raw counts file
counts <- readRDS("data/new/RUV/filt_counts_matrix.RDS")

#create a dgelist object from these counts
dge_test <- DGEList(counts = counts)
dim(dge_test$counts)
#14319 genes as normal, still contains replicate needed for RUVs

#apply TMM normalization to this DGElist object
dge_test_tmm <- calcNormFactors(object = dge_test, method = "TMM")
#this ran through just fine, must be something to do with applying TMM to normalized counts
dim(dge_test_tmm$counts)
#14319 genes as normal, still have the replicate so 42 cols
#this still has the entrez_id so I should probably make sure that this is carried down

#pass this TMM normalized DGElist into RUVs correction
colnames(dge_test_tmm) <- Metadata$Final_sample_name
dim(dge_test_tmm)
#14319 genes as normal


RUV_filt_counts_tmm <- dge_test_tmm$counts %>% 
  as.data.frame() 

Entrez_ID_tmm_RUV <- RUV_filt_counts_tmm$Entrez_ID
# saveRDS(Entrez_ID_tmm_RUV, "data/new/RUV/entrezID_tmm_RUV_list.RDS")

dim(RUV_filt_counts_tmm)
#14319 genes as normal, no need to add the filtering step as the counts are already filtered

#add in the annotation files
ind_num <- readRDS("data/new/ind_num.RDS")
annot <- read.csv("data/new/Metadata.csv")

#counts need to be integer values and in a numeric matrix
#note: the log transformation needs to be accounted for in the isLog argument in RUVs function.
counts_test_tmm <- as.matrix(RUV_filt_counts_tmm)
#saveRDS(counts_test_tmm, "data/new/RUV/counts_tmm_filtered.RDS")

# Create a DataFrame for the phenoData
phenoData <- DataFrame(annot)

# Now create the RangedSummarizedExperiment necessary for RUVs input
# looks like it did need both the phenodata and the counts.
set_tmm <- SummarizedExperiment(assays = counts_test_tmm, metadata = phenoData)
dim(set_tmm)
#14319 genes as before

# Generate a background matrix
# The column "Cond" holds the comparisons that you actually want to make. DOX_24, DMSO_24,5FU_24, DOX_3,etc.
scIdx <-RUVSeq::makeGroups(phenoData$Condition)
scIdx

#now run through RUV correction with my tmm normalized data to generate normalized counts
set1_tmm <- RUVSeq::RUVs(x = counts_test_tmm, k =1, scIdx = scIdx, isLog = FALSE)
dim(set1_tmm$normalizedCounts)
#14319 genes as before, still containing the replicate individual

#saveRDS(set1_tmm, "data/new/RUV/set1_TMMnorm_RUVsk1_normcounts.RDS")

#make a df of the data for Cormotif?
RUV_df1_tmm <- set1_tmm$W %>% as.data.frame()
RUV_df1_tmm$Names <- rownames(RUV_df1_tmm)

#ensure that the names match across samples
RUV_df_rm1_tmm <- RUV_df1_tmm[RUV_df1_tmm$Names %in% annot$Final_sample_name, ] 
RUV_1_tmm <-  RUV_df_rm1_tmm$W_1

#now that I've passed my TMM normalized counts into the set_tmm, proceed to Cormotif

#####Cormotif Data Setup#####
set1_tmm <- readRDS("data/new/RUV/set1_TMMnorm_RUVsk1_normcounts.RDS")
NormCounts_RUV_rep <- as.data.frame(set1_tmm$normalizedCounts)

#read in my metadata sheet that I'll use as the standard for labelling
#this one already has the replicate individual removed
Metadata_2 <- readRDS("data/new/Metadata_2_norep.RDS")

#I'll have to remove the replicate at this stage so I can properly run Cormotif
NormCounts_RUV <- NormCounts_RUV_rep %>% 
  dplyr::select(-(contains("6R")))
#14319 genes and 36 columns, the right size matrix for Cormotif

#now ensure the column names match the original dge$counts with Sample_name
colnames(NormCounts_RUV) <- Metadata_2$Sample_name
rownames(NormCounts_RUV) <- Entrez_ID_tmm_RUV

#now cpm the cormotif matrix you're going to use
##this should be tmm normalized log2cpm at the end for going into Cormotif
cmf_test <- cpm(NormCounts_RUV, log = TRUE)
colnames(cmf_test) <- (Metadata_2$Final_sample_name)

cmf_counts <- dge_test_tmm$counts %>% 
  as.data.frame() %>% 
  dplyr::select(-(contains("6R")))

cmf_test_df <- cmf_test %>% 
  as.data.frame() %>% 
  rownames_to_column(., var = "Entrez_ID")

#write.csv(x = cmf_test, file = "data/new/RUV/cormotif_test_matrix_TMMnorm.csv")

#reorder my test matrix to match the new groupid I've made
#I want my columns to be in this order:
#DOX24T 1-6, DOX24R 1-6, DOX144R 1-6, DMSO24T 1-6, DMSO24R 1-6, DMSO144R 1-6
Cormotif_ruv <- read.csv("data/new/RUV/Cormotif_RUV_final.csv")
dim(Cormotif_ruv)
#14319 genes across 37 cols (1 is Entrez_ID)
Cormotif_ruv_df <- data.frame(Cormotif_ruv)

rownames(Cormotif_ruv_df) <- Cormotif_ruv_df$Entrez_ID
exprs.cmf_ruv <- as.matrix(Cormotif_ruv_df[,2:37])
dim(exprs.cormotif)
#14319 genes in 36 columns, set up for plugging into Cormotif

#now I need to set up my groupid and compid accordingly

#put together my group id and comparison id to make the correct comparisons between experimental conditions

#groupid tells which experimental conditions are grouped together
#compid tells which experimental conditions should be compared against one another
##ie DOX24T vs DMSO24T matched control

groupid_csv <- read.csv("data/new/GroupID.csv")
#now I have to make this into a vector (named vector)?
groupid <- c(
  DOX_24T_1 = 1, 
  DOX_24T_2 = 1, 
  DOX_24T_3 = 1, 
  DOX_24T_4 = 1, 
  DOX_24T_5 = 1, 
  DOX_24T_6 = 1,
  DOX_24R_1 = 2, 
  DOX_24R_2 = 2, 
  DOX_24R_3 = 2, 
  DOX_24R_4 = 2, 
  DOX_24R_5 = 2, 
  DOX_24R_6 = 2,
  DOX_144R_1 = 3, 
  DOX_144R_2 = 3, 
  DOX_144R_3 = 3, 
  DOX_144R_4 = 3, 
  DOX_144R_5 = 3, 
  DOX_144R_6 = 3,
  DMSO_24T_1 = 4, 
  DMSO_24T_2 = 4, 
  DMSO_24T_3 = 4, 
  DMSO_24T_4 = 4, 
  DMSO_24T_5 = 4, 
  DMSO_24T_6 = 4,
  DMSO_24R_1 = 5, 
  DMSO_24R_2 = 5, 
  DMSO_24R_3 = 5, 
  DMSO_24R_4 = 5, 
  DMSO_24R_5 = 5, 
  DMSO_24R_6 = 5,
  DMSO_144R_1 = 6, 
  DMSO_144R_2 = 6, 
  DMSO_144R_3 = 6, 
  DMSO_144R_4 = 6, 
  DMSO_144R_5 = 6, 
  DMSO_144R_6 = 6
)
#saveRDS(groupid, "data/new/groupidCormotif.RDS")

compid <- data.frame(Cond1 = c(1, 2, 3), Cond2 = c(4, 5, 6))
#saveRDS(compid, "data/new/compidCormotif.RDS")
compid_cmf <- readRDS("data/new/compidCormotif.RDS")
```

```{r RUVs Cormotif Run}
#set the seed the same as the previous one to ensure consistency

#fit Cormotif model
# set.seed(19191)
#only set the seed ONCE
# 
# motif.fitted_ruv <- cormotiffit(
#   exprs = exprs.cmf_ruv,
#   groupid = groupid_csv,
#   compid = compid_cmf,
#   K = 1:10,
#   max.iter = 1000,
#   BIC = TRUE,
#   runtype = "logCPM"
# )

# saveRDS(motif.fitted_RUV, "data/new/RUV/motif.fitted_ruv_250624.RDS")
motif.fitted_RUV <- readRDS("data/new/RUV/motif.fitted_ruv_250624.RDS")

```

```{r RUVs Cormotif Plots}

#plot BIC and AIC to see which number of motifs was best for both models
plotIC(motif.fitted_RUV)

motif.fitted_RUV$bic

#now plot the motifs themselves
plotMotif(motif.fitted_RUV, title = "Fitted Motifs for DXR RUVs")

#plot the probability legend
myColors <-  rev(c("#FFFFFF", "#E6E6E6" ,"#CCCCCC", "#B3B3B3", "#999999", "#808080", "#666666","#4C4C4C", "#333333", "#191919","#000000"))

plot.new()
legend('bottomleft',fill=myColors, legend =rev(c("0", "0.1", "0.2", "0.3", "0.4",  "0.5", "0.6", "0.7", "0.8","0.9", "1")), box.col="white",title = "Probability\nlegend", horiz=FALSE,title.cex=.8)

```

```{r RUVs Plot Cormotif no TMM}
#plot the AIC and BIC (we're interested in the Bayesian most of all)
# plotIC(motif.fit_RUV)
# 
# #visual check of the lowest BIC
# motif.fit_RUV$bic
# 
# #plot the motifs
# plotMotif(motif.fit_RUV)
# 
# #plot the probability legend
# myColors <-  rev(c("#FFFFFF", "#E6E6E6" ,"#CCCCCC", "#B3B3B3", "#999999", "#808080", "#666666","#4C4C4C", "#333333", "#191919","#000000"))
# 
# plot.new()
# legend('bottomleft',fill=myColors, legend =rev(c("0", "0.1", "0.2", "0.3", "0.4",  "0.5", "0.6", "0.7", "0.8","0.9", "1")), box.col="white",title = "Probability\nlegend", horiz=FALSE,title.cex=.8)

```

```{r RUVs Cormotif log2 Norm Counts}

# lognormcounts_CMF_rep <- as.matrix(set1$normalizedCounts)
# lognormcounts_CMF <- log2(lognormcounts_CMF_rep + 1)
# #add a pseudocount to ensure any values are not negative or zero
# 
# #first want to cut out the replicate samples as not needed for Cormotif
# lognormcounts_CMF <- as.data.frame(lognormcounts_CMF) %>% 
#   dplyr::select(-(contains("6R"))) %>% 
#   as.matrix()
# 
# #14319 genes in 36 columns, set up for plugging into Cormotif
# 
# #now I need to set up my groupid and compid accordingly
# 
# #put together my group id and comparison id to make the correct comparisons between experimental conditions
# 
# #groupid tells which experimental conditions are grouped together
# #compid tells which experimental conditions should be compared against one another
# ##ie DOX24T vs DMSO24T matched control
# 
# groupid_other <- readRDS("data/new/RUV/groupid_other_unrearranged.RDS")
# 
# #now put together your compid
# compid1 <- data.frame(Cond1 = c(1, 2, 3), Cond2 = c(4, 5, 6))

```

```{r RUVs Cormotif log2 normalized counts Run}
#set the seed the same as the previous one to ensure consistency

#fit Cormotif model
# set.seed(19191)
#only set the seed ONCE

# motif.fit_RUV_log2 <- cormotiffit(
#   exprs = lognormcounts_CMF,
#   groupid = groupid_other,
#   compid = compid1,
#   K = 1:8,
#   max.iter = 500,
#   BIC = TRUE,
#   runtype = "logCPM"
# )

#Warning: Zero sample variances detected, have been offset away from zero#

# saveRDS(motif.fit_RUV_log2, "data/new/RUV/motif.fit_RUVnormcounts_log2NC_250629.RDS")
# motif.fit_RUV_log2 <- readRDS("data/new/RUV/motif.fit_RUVnormcounts_log2NC_250629.RDS")

```

```{r RUVs Plot Cormotif log2 of normcounts}
# #plot the AIC and BIC (we're interested in the Bayesian most of all)
# plotIC(motif.fit_RUV_log2)
# 
# #visual check of the lowest BIC
# motif.fit_RUV_log2$bic
# 
# #plot the motifs
# plotMotif(motif.fit_RUV_log2, title = "Log2 RUVs Norm Counts")
# 
# #plot the probability legend
# myColors <-  rev(c("#FFFFFF", "#E6E6E6" ,"#CCCCCC", "#B3B3B3", "#999999", "#808080", "#666666","#4C4C4C", "#333333", "#191919","#000000"))
# 
# plot.new()
# legend('bottomleft',fill=myColors, legend =rev(c("0", "0.1", "0.2", "0.3", "0.4",  "0.5", "0.6", "0.7", "0.8","0.9", "1")), box.col="white",title = "Probability\nlegend", horiz=FALSE,title.cex=.8)

```

```{r RUVs Cormotif log2cpm norm counts}
#since both the TMM normalized norm counts and the cpm norm counts are giving me issues:
#I am going to try this with just the log2 of the normalized counts from RUVs

lognormcounts_CMF_rep <- as.matrix(set1$normalizedCounts)
lognormcounts_CMF_cpm <- cpm(lognormcounts_CMF_rep + 1, log = TRUE)
#add a pseudocount to ensure any values are not negative or zero

#first want to cut out the replicate samples as not needed for Cormotif
lognormcounts_CMF_cpm <- as.data.frame(lognormcounts_CMF_cpm) %>% 
  dplyr::select(-(contains("6R"))) %>% 
  as.matrix()

#write.csv(x = logNC_CMF_RUV, file = "data/new/RUV/Cormotif_log2normcounts_RUV_matrix.csv")

#14319 genes in 36 columns, set up for plugging into Cormotif

#now I need to set up my groupid and compid accordingly

#put together my group id and comparison id to make the correct comparisons between experimental conditions

#groupid tells which experimental conditions are grouped together
#compid tells which experimental conditions should be compared against one another
##ie DOX24T vs DMSO24T matched control

groupid_other <- readRDS("data/new/RUV/groupid_other_unrearranged.RDS")

#now I have to make this into a vector (named vector)?

compid <- data.frame(Cond1 = c(1, 3, 5), Cond2 = c(2, 4, 6))
compid1 <- data.frame(Cond1 = c(1, 2, 3), Cond2 = c(4, 5, 6))


```

```{r RUVs Run Cormotif log2cpm normcounts}

#set the seed the same as the previous one to ensure consistency

#fit Cormotif model
# set.seed(19191)
#only set the seed ONCE

# motif.fit_RUV_logNC <- cormotiffit(
#   exprs = lognormcounts_CMF_cpm,
#   groupid = groupid_other,
#   compid = compid1,
#   K = 1:8,
#   max.iter = 500,
#   BIC = TRUE,
#   runtype = "logCPM"
# )

# saveRDS(motif.fit_RUV_logNC, "data/new/RUV/motif.fit_RUVnormcounts_log2cpm_250630.RDS")
motif.fit_RUV_logNC_cpm <- readRDS("data/new/RUV/motif.fit_RUVnormcounts_log2cpm_250630.RDS")

```

```{r RUVs Plot Cormotif log2cpm normcounts}
#plot the AIC and BIC (we're interested in the Bayesian most of all)
plotIC(motif.fit_RUV_logNC_cpm)

#visual check of the lowest BIC
motif.fit_RUV_logNC_cpm$bic

#plot the motifs
plotMotif(motif.fit_RUV_logNC_cpm)

#plot the probability legend
myColors <-  rev(c("#FFFFFF", "#E6E6E6" ,"#CCCCCC", "#B3B3B3", "#999999", "#808080", "#666666","#4C4C4C", "#333333", "#191919","#000000"))

plot.new()
legend('bottomleft',fill=myColors, legend =rev(c("0", "0.1", "0.2", "0.3", "0.4",  "0.5", "0.6", "0.7", "0.8","0.9", "1")), box.col="white",title = "Probability\nlegend", horiz=FALSE,title.cex=.8)

```

```{r RUVs Cormotif Plain Norm Counts}
# #now since I'm having some strange outputs with the transformed data
# #I want to try and just feed in the normalized counts only
# 
normcounts_CMF_rep <- as.data.frame(set1$normalizedCounts)
# 
#first want to cut out the replicate samples as not needed for Cormotif
normcounts_CMF <- as.data.frame(normcounts_CMF_rep) %>%
  dplyr::select(-(contains("6R")))

# #14319 genes in 36 columns, set up for plugging into Cormotif

# #now I need to set up my groupid and compid accordingly
# #put together my group id and comparison id to make the correct comparisons between experimental conditions

# #groupid tells which experimental conditions are grouped together
# #compid tells which experimental conditions should be compared against one another
# ##ie DOX24T vs DMSO24T matched control

#groupid that doesn't require changing order of matrix:
# groupid_other <- c(
#   DOX_24T_1 = 1,
#   DMSO_24T_1 = 4,
#   DOX_24R_1 = 2,
#   DMSO_24R_1 = 5,
#   DOX_144R_1 = 3,
#   DMSO_144R_1 = 6,
# 
#   DOX_24T_2 = 1,
#   DMSO_24T_2 = 4,
#   DOX_24R_2 = 2,
#   DMSO_24R_2 = 5,
#   DOX_144R_2 = 3,
#   DMSO_144R_2 = 6,
# 
#   DOX_24T_3 = 1,
#   DMSO_24T_3 = 4,
#   DOX_24R_3 = 2,
#   DMSO_24R_3 = 5,
#   DOX_144R_3 = 3,
#   DMSO_144R_3 = 6,
# 
#   DOX_24T_4 = 1,
#   DMSO_24T_4 = 4,
#   DOX_24R_4 = 2,
#   DMSO_24R_4 = 5,
#   DOX_144R_4 = 3,
#   DMSO_144R_4 = 6,
# 
#   DOX_24T_5 = 1,
#   DMSO_24T_5 = 4,
#   DOX_24R_5 = 2,
#   DMSO_24R_5 = 5,
#   DOX_144R_5 = 3,
#   DMSO_144R_5 = 6,
# 
#   DOX_24T_6 = 1,
#   DMSO_24T_6 = 4,
#   DOX_24R_6 = 2,
#   DMSO_24R_6 = 5,
#   DOX_144R_6 = 3,
#   DMSO_144R_6 = 6
# )

groupid_other <- readRDS("data/new/RUV/groupid_other_unrearranged.RDS")

compid <- data.frame(Cond1 = c(1, 3, 5), Cond2 = c(2, 4, 6))
compid1 <- data.frame(Cond1 = c(1, 2, 3), Cond2 = c(4, 5, 6))

```

```{r RUVs Run Cormotif NormCounts Only}

# #set the seed the same as the previous one to ensure consistency
# 
# #fit Cormotif model
# # set.seed(19191)
# # #only set the seed ONCE
# # 
# # motif.fit_RUV_NC_test <- cormotiffit(
# #   exprs = exprs.NC_CMF_RUV,
# #   groupid = groupid_other,
# #   compid = compid,
# #   K = 1:10,
# #   max.iter = 1000,
# #   BIC = TRUE,
# #   runtype = "counts"
# # )
# 
#saveRDS(motif.fit_RUV_NC_test, "data/new/RUV/motif.fit_RUVnormcounts_compid_250630.RDS")
motif.fit_RUV_NC_test <- readRDS("data/new/RUV/motif.fit_RUVnormcounts_250630.RDS")

```

```{r RUVs Plot Cormotif NormCounts Only}
# #plot the AIC and BIC (we're interested in the Bayesian most of all)

plotIC(motif.fit_RUV_NC_test)
# 
# #visual check of the lowest BIC
# motif.fit_RUV_NC_test$bic
# 
# #plot the motifs
plotMotif(motif.fit_RUV_NC_test)
# 
#plot the probability legend
myColors <-  rev(c("#FFFFFF", "#E6E6E6" ,"#CCCCCC", "#B3B3B3", "#999999", "#808080", "#666666","#4C4C4C", "#333333", "#191919","#000000"))

plot.new()
legend('bottomleft',fill=myColors, legend =rev(c("0", "0.1", "0.2", "0.3", "0.4",  "0.5", "0.6", "0.7", "0.8","0.9", "1")), box.col="white",title = "Probability\nlegend", horiz=FALSE,title.cex=.8)

```

```{r RUVs Cormotif Input}
#I have tried a few different ways to input data into Cormotif after RUVs correction

#1st way - TMM normalized norm counts from RUVs, cpm transformed
#2nd way - TMM normalized FILT counts into RUVs, cpm transformed
#3rd way - log2 converted normalized counts from RUVs
#4th way - just norm counts from RUVs (runtype = "counts" does limma + TMM for me)
#5th way - log2cpm norm counts from RUVs, runtype = logCPM

# #try the original one without doing cpm just for comparisons' sake
# counts_CMF_original <- dge
# colnames(counts_CMF_original) <- (Metadata_2$Final_sample_name)
# 
# cormotif_counts_df <- counts_CMF_original %>% 
#   as.data.frame() %>% 
#   rownames_to_column(., var = "Entrez_ID")
# 
# #write.csv(cormotif_test, "data/new/Cormotif_test_matrix.csv")
# 
# #reorder my test matrix to match the new groupid I've made
# #I want my columns to be in this order:
# #DOX24T 1-6, DOX24R 1-6, DOX144R 1-6, DMSO24T 1-6, DMSO24R 1-6, DMSO144R 1-6
# # Cormotif <- read.csv("data/new/Cormotif_matrix_final.csv")
# # dim(Cormotif)
# #14319 genes across 37 cols (1 is Entrez_ID)
# # Cormotif_df <- data.frame(Cormotif)
# 
# # rownames(cormotif_counts_df) <- cormotif_counts_df$Entrez_ID
# # exprs.cormotif_counts <- as.matrix(cormotif_counts_df[,2:37])
# # dim(exprs.cormotif_counts)
# 
# #put together my group id and comparison id to make the correct comparisons between experimental conditions
# 
# #groupid tells which experimental conditions are grouped together
# #compid tells which experimental conditions should be compared against one another
# ##ie DOX24T vs DMSO24T matched control
# 
# #use counts_CMF_original
# # View(counts_CMF_original)
# 
# groupid_other <- readRDS("data/new/RUV/groupid_other_unrearranged.RDS")
# 
# compid1 <- data.frame(Cond1 = c(1, 3, 5), Cond2 = c(2, 4, 6))
# #saveRDS(compid, "data/new/compidCormotif.RDS")
```

```{r Run Cormotif original counts}
# #fit Cormotif model
# set.seed(19191)
# #only set the seed ONCE
# 
# motif.fitted_counts <- cormotiffit(
#   exprs = counts_CMF_original,
#   groupid = groupid_other,
#   compid = compid,
#   K = 1:8,
#   max.iter = 1000,
#   BIC = TRUE,
#   runtype = "counts"
# )
# 
# 

# saveRDS(motif.fitted_counts, "data/new/RUV/motif.filtcountsinput_EMP_250629.RDS")

motif.fitted_counts <- readRDS("data/new/RUV/motif.filtcountsinput_EMP_250629.RDS")

plotIC(motif.fitted_counts)
plotMotif(motif.fitted_counts)

```


Now that I've finished up with Cormotif, I want to make comparisons across DEGs and Cormotif analysis to identify DEGs within my motifs
I also want to find out if any of my DEGs within a certain category (DDR, DIC, p53 target genes) are enriched in a motif.
```{r DDR Genes Enrichment Motifs}
#start by reading in the DEG list





```

